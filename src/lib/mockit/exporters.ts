// Export utilities for Mockit

import type {
  Screenshot,
  AnimationConfig,
  BackgroundConfig,
  MockupLayout,
  DeviceType,
  ExportFormat,
} from './types';
import { DEVICE_FRAMES } from './types';
import { generateSEOFilename, generateAltText, generateTitle } from './seo-filename';

interface ExportOptions {
  screenshots: Screenshot[];
  animation: AnimationConfig;
  background: BackgroundConfig;
  layout: MockupLayout;
  sourceUrl: string;
}

/**
 * Generates React/TSX code for the mockup
 */
export function generateReactCode(options: ExportOptions): string {
  const { screenshots, animation, background, layout, sourceUrl } = options;
  const devices = screenshots.map(s => s.device);
  const componentName = 'MockupShowcase';

  const hasAnimation = animation.type !== 'none';

  const imports = [
    `import React from 'react';`,
    hasAnimation ? `import { motion } from 'framer-motion';` : '',
  ].filter(Boolean).join('\n');

  const animationVariants = hasAnimation ? generateAnimationVariants(animation) : '';

  const backgroundStyle = generateBackgroundStyle(background);

  const deviceComponents = screenshots.map((screenshot, index) => {
    const frame = DEVICE_FRAMES[screenshot.device];
    const transform = getDeviceTransform(screenshot.device, index, layout);

    return `
      <${hasAnimation ? 'motion.' : ''}div
        className="relative"
        style={{
          width: ${frame.width * frame.scale}px,
          transform: '${transform}',
        }}
        ${hasAnimation ? `
        variants={deviceVariants}
        initial="initial"
        animate="animate"
        ` : ''}
      >
        {/* Device Frame */}
        <div
          className="relative bg-gradient-to-b from-gray-800 to-gray-900 rounded-[${frame.bezel.radius}px] shadow-2xl overflow-hidden"
          style={{
            padding: '${frame.bezel.top}px ${frame.bezel.right}px ${frame.bezel.bottom}px ${frame.bezel.left}px',
          }}
        >
          ${screenshot.device === 'mobile' ? `
          {/* Dynamic Island */}
          <div className="absolute top-4 left-1/2 -translate-x-1/2 w-32 h-8 bg-black rounded-full" />
          ` : ''}
          ${screenshot.device === 'desktop' ? `
          {/* MacBook Notch */}
          <div className="absolute top-0 left-1/2 -translate-x-1/2 w-48 h-6 bg-black rounded-b-lg" />
          ` : ''}

          {/* Screenshot */}
          <img
            src="${screenshot.dataUrl}"
            alt="${generateAltText(sourceUrl, [screenshot.device])}"
            className="w-full h-auto rounded-lg"
          />
        </div>

        ${layout.shadow.enabled ? `
        {/* Shadow */}
        <div
          className="absolute -bottom-4 left-1/2 -translate-x-1/2 w-3/4 h-8 bg-black/20 blur-xl rounded-full"
        />
        ` : ''}
      </${hasAnimation ? 'motion.' : ''}div>`;
  }).join('\n');

  return `${imports}

${animationVariants}

/**
 * ${generateTitle(sourceUrl, devices)}
 * Generated by Mockit - https://jamesisthetest.com/mockit
 */
export function ${componentName}() {
  return (
    <div
      className="relative flex items-center justify-center min-h-screen p-8"
      style={{
        ${backgroundStyle}
      }}
    >
      <div className="relative flex items-end justify-center gap-${layout.spacing}">
        ${deviceComponents}
      </div>
    </div>
  );
}

export default ${componentName};
`;
}

/**
 * Generates JSON export with all mockup data
 */
export function generateJSON(options: ExportOptions): string {
  const { screenshots, animation, background, layout, sourceUrl } = options;
  const devices = screenshots.map(s => s.device);

  const exportData = {
    version: '1.0',
    generator: 'Mockit by 8gent',
    metadata: {
      title: generateTitle(sourceUrl, devices),
      altText: generateAltText(sourceUrl, devices),
      sourceUrl,
      createdAt: new Date().toISOString(),
    },
    config: {
      animation,
      background,
      layout,
    },
    screenshots: screenshots.map(s => ({
      device: s.device,
      width: s.width,
      height: s.height,
      frame: DEVICE_FRAMES[s.device],
      dataUrl: s.dataUrl,
    })),
    // Include animation keyframes for external use
    keyframes: animation.type !== 'none' ? generateKeyframes(animation) : null,
  };

  return JSON.stringify(exportData, null, 2);
}

/**
 * Creates a downloadable blob for the export
 */
export async function createExportBlob(
  options: ExportOptions & { format: ExportFormat }
): Promise<{ blob: Blob; filename: string }> {
  const { format, screenshots, sourceUrl, animation } = options;
  const devices = screenshots.map(s => s.device);

  const filename = generateSEOFilename({
    sourceUrl,
    devices,
    animation: animation.type,
    format,
  });

  switch (format) {
    case 'json': {
      const json = generateJSON(options);
      const blob = new Blob([json], { type: 'application/json' });
      return { blob, filename };
    }

    case 'react': {
      const code = generateReactCode(options);
      const blob = new Blob([code], { type: 'text/typescript' });
      return { blob, filename };
    }

    case 'png': {
      // For PNG, we'll render to canvas and export
      const blob = await renderToImage(options);
      return { blob, filename };
    }

    case 'gif': {
      // GIF export with animation frames
      const blob = await renderToGif(options);
      return { blob, filename };
    }

    case 'webm': {
      // WebM video export
      const blob = await renderToWebM(options);
      return { blob, filename };
    }

    default:
      throw new Error(`Unsupported export format: ${format}`);
  }
}

// Helper functions

function generateAnimationVariants(animation: AnimationConfig): string {
  const { type, duration, intensity, easing } = animation;

  switch (type) {
    case 'float':
      return `
const deviceVariants = {
  initial: { y: 0 },
  animate: {
    y: [0, -${intensity}, 0],
    transition: {
      duration: ${duration / 1000},
      repeat: Infinity,
      ease: "${easing}",
    },
  },
};`;

    case 'rotate3d':
      return `
const deviceVariants = {
  initial: { rotateY: 0, rotateX: 0 },
  animate: {
    rotateY: [-${intensity / 2}, ${intensity / 2}, -${intensity / 2}],
    rotateX: [-${intensity / 4}, ${intensity / 4}, -${intensity / 4}],
    transition: {
      duration: ${duration / 1000},
      repeat: Infinity,
      ease: "${easing}",
    },
  },
};`;

    case 'pulse':
      return `
const deviceVariants = {
  initial: { scale: 1 },
  animate: {
    scale: [1, ${1 + intensity / 100}, 1],
    transition: {
      duration: ${duration / 1000},
      repeat: Infinity,
      ease: "${easing}",
    },
  },
};`;

    case 'bounce':
      return `
const deviceVariants = {
  initial: { y: 0 },
  animate: {
    y: [0, -${intensity * 2}, 0],
    transition: {
      duration: ${duration / 1000},
      repeat: Infinity,
      ease: [0.68, -0.55, 0.265, 1.55],
    },
  },
};`;

    default:
      return `
const deviceVariants = {
  initial: {},
  animate: {},
};`;
  }
}

function generateBackgroundStyle(background: BackgroundConfig): string {
  if (background.type === 'transparent') {
    return 'background: transparent,';
  }

  if (background.type === 'solid') {
    return `background: '${background.primaryColor}',`;
  }

  if (background.type === 'gradient') {
    return `background: 'linear-gradient(${background.angle || 135}deg, ${background.primaryColor}, ${background.secondaryColor})',`;
  }

  return `background: 'linear-gradient(135deg, ${background.primaryColor}, ${background.secondaryColor})',`;
}

function getDeviceTransform(
  device: DeviceType,
  index: number,
  layout: MockupLayout
): string {
  const { arrangement, rotation } = layout;

  switch (arrangement) {
    case 'fan':
      const fanAngle = (index - (layout.devices.length - 1) / 2) * rotation;
      return `rotate(${fanAngle}deg)`;

    case 'cascade':
      return `translateX(${index * 20}px) translateY(${index * 20}px)`;

    case 'perspective':
      if (device === 'mobile') return 'rotateY(15deg) translateZ(-50px)';
      if (device === 'tablet') return 'rotateY(0deg) translateZ(0)';
      return 'rotateY(-15deg) translateZ(-50px)';

    default:
      return '';
  }
}

function generateKeyframes(animation: AnimationConfig): object {
  const { type, duration, intensity } = animation;

  switch (type) {
    case 'float':
      return {
        '0%, 100%': { transform: 'translateY(0)' },
        '50%': { transform: `translateY(-${intensity}px)` },
      };

    case 'rotate3d':
      return {
        '0%, 100%': { transform: 'rotateY(0) rotateX(0)' },
        '25%': { transform: `rotateY(-${intensity / 2}deg) rotateX(-${intensity / 4}deg)` },
        '75%': { transform: `rotateY(${intensity / 2}deg) rotateX(${intensity / 4}deg)` },
      };

    case 'pulse':
      return {
        '0%, 100%': { transform: 'scale(1)' },
        '50%': { transform: `scale(${1 + intensity / 100})` },
      };

    default:
      return {};
  }
}

/**
 * Renders mockup to a PNG image
 */
async function renderToImage(options: ExportOptions): Promise<Blob> {
  // Create an offscreen canvas
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  if (!ctx) throw new Error('Failed to get canvas context');

  // Set canvas size (2x for retina)
  const width = 1920;
  const height = 1080;
  canvas.width = width * 2;
  canvas.height = height * 2;
  ctx.scale(2, 2);

  // Draw background
  drawBackground(ctx, width, height, options.background);

  // Draw each device
  const { screenshots, layout } = options;
  const totalDevices = screenshots.length;
  const startX = (width - totalDevices * 300) / 2;

  for (let i = 0; i < screenshots.length; i++) {
    const screenshot = screenshots[i];
    const frame = DEVICE_FRAMES[screenshot.device];

    const x = startX + i * (300 + layout.spacing);
    const y = height / 2 - (frame.height * frame.scale) / 2;

    await drawDevice(ctx, screenshot, frame, x, y, layout);
  }

  return new Promise((resolve, reject) => {
    canvas.toBlob(
      blob => blob ? resolve(blob) : reject(new Error('Failed to create blob')),
      'image/png',
      1.0
    );
  });
}

/**
 * Renders mockup to an animated GIF
 */
async function renderToGif(options: ExportOptions): Promise<Blob> {
  // For GIF export, we use a simplified approach
  // In production, you'd use a library like gif.js

  const { animation } = options;

  if (animation.type === 'none') {
    // No animation, just return a static PNG
    return renderToImage(options);
  }

  // For animated GIFs, we need to render multiple frames
  // This is a placeholder - in production use gif.js or similar
  const frames: ImageData[] = [];
  const frameCount = 30;
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  if (!ctx) throw new Error('Failed to get canvas context');

  const width = 800;
  const height = 600;
  canvas.width = width;
  canvas.height = height;

  for (let i = 0; i < frameCount; i++) {
    const progress = i / frameCount;
    const animationOffset = getAnimationOffset(animation, progress);

    ctx.clearRect(0, 0, width, height);
    drawBackground(ctx, width, height, options.background);

    // Draw devices with animation offset
    const { screenshots, layout } = options;
    const totalDevices = screenshots.length;
    const startX = (width - totalDevices * 200) / 2;

    for (let j = 0; j < screenshots.length; j++) {
      const screenshot = screenshots[j];
      const frame = DEVICE_FRAMES[screenshot.device];

      const x = startX + j * (200 + layout.spacing / 2);
      const y = height / 2 - (frame.height * frame.scale * 0.7) / 2 + animationOffset.y;

      ctx.save();
      ctx.translate(x + 100, y + 150);
      ctx.rotate((animationOffset.rotation * Math.PI) / 180);
      ctx.scale(1 + animationOffset.scale, 1 + animationOffset.scale);
      ctx.translate(-100, -150);

      await drawDevice(ctx, screenshot, frame, 0, 0, layout, 0.7);

      ctx.restore();
    }

    frames.push(ctx.getImageData(0, 0, width, height));
  }

  // Encode to GIF (simplified - returns PNG for now)
  // In production, use gif.js to properly encode animated GIF
  return new Promise((resolve, reject) => {
    canvas.toBlob(
      blob => blob ? resolve(blob) : reject(new Error('Failed to create blob')),
      'image/png',
      0.9
    );
  });
}

/**
 * Renders mockup to WebM video
 */
async function renderToWebM(options: ExportOptions): Promise<Blob> {
  // WebM export using MediaRecorder
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  if (!ctx) throw new Error('Failed to get canvas context');

  const width = 1280;
  const height = 720;
  canvas.width = width;
  canvas.height = height;

  const stream = canvas.captureStream(30);
  const mediaRecorder = new MediaRecorder(stream, {
    mimeType: 'video/webm;codecs=vp9',
    videoBitsPerSecond: 5000000,
  });

  const chunks: Blob[] = [];
  mediaRecorder.ondataavailable = e => chunks.push(e.data);

  return new Promise((resolve, reject) => {
    mediaRecorder.onstop = () => {
      const blob = new Blob(chunks, { type: 'video/webm' });
      resolve(blob);
    };

    mediaRecorder.onerror = reject;
    mediaRecorder.start();

    const { animation } = options;
    const duration = animation.duration || 3000;
    const frameRate = 30;
    const totalFrames = Math.floor((duration / 1000) * frameRate);
    let frame = 0;

    const renderFrame = async () => {
      const progress = frame / totalFrames;
      const animationOffset = getAnimationOffset(animation, progress);

      ctx.clearRect(0, 0, width, height);
      drawBackground(ctx, width, height, options.background);

      const { screenshots, layout } = options;
      const totalDevices = screenshots.length;
      const startX = (width - totalDevices * 250) / 2;

      for (let j = 0; j < screenshots.length; j++) {
        const screenshot = screenshots[j];
        const deviceFrame = DEVICE_FRAMES[screenshot.device];

        const x = startX + j * (250 + layout.spacing / 2);
        const y = height / 2 - (deviceFrame.height * deviceFrame.scale * 0.6) / 2 + animationOffset.y;

        ctx.save();
        ctx.translate(x + 125, y + 180);
        ctx.rotate((animationOffset.rotation * Math.PI) / 180);
        ctx.scale(1 + animationOffset.scale, 1 + animationOffset.scale);
        ctx.translate(-125, -180);

        await drawDevice(ctx, screenshot, deviceFrame, 0, 0, layout, 0.6);

        ctx.restore();
      }

      frame++;

      if (frame < totalFrames) {
        requestAnimationFrame(renderFrame);
      } else {
        // Loop once more for smooth looping
        frame = 0;
        if (frame < totalFrames / 2) {
          requestAnimationFrame(renderFrame);
        } else {
          mediaRecorder.stop();
        }
      }
    };

    renderFrame();

    // Stop after duration
    setTimeout(() => {
      if (mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
      }
    }, duration + 500);
  });
}

// Drawing helpers

function drawBackground(
  ctx: CanvasRenderingContext2D,
  width: number,
  height: number,
  background: BackgroundConfig
) {
  if (background.type === 'transparent') {
    return;
  }

  if (background.type === 'solid') {
    ctx.fillStyle = background.primaryColor;
    ctx.fillRect(0, 0, width, height);
    return;
  }

  // Gradient
  const angle = ((background.angle || 135) * Math.PI) / 180;
  const x1 = width / 2 - Math.cos(angle) * width;
  const y1 = height / 2 - Math.sin(angle) * height;
  const x2 = width / 2 + Math.cos(angle) * width;
  const y2 = height / 2 + Math.sin(angle) * height;

  const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
  gradient.addColorStop(0, background.primaryColor);
  gradient.addColorStop(1, background.secondaryColor);

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, width, height);
}

async function drawDevice(
  ctx: CanvasRenderingContext2D,
  screenshot: Screenshot,
  frame: typeof DEVICE_FRAMES[DeviceType],
  x: number,
  y: number,
  layout: MockupLayout,
  scaleFactor: number = 1
) {
  const scale = frame.scale * scaleFactor;
  const deviceWidth = frame.width * scale;
  const deviceHeight = frame.height * scale;
  const bezel = {
    top: frame.bezel.top * scale,
    bottom: frame.bezel.bottom * scale,
    left: frame.bezel.left * scale,
    right: frame.bezel.right * scale,
    radius: frame.bezel.radius * scale,
  };

  // Draw shadow if enabled
  if (layout.shadow.enabled) {
    ctx.save();
    ctx.shadowColor = `rgba(0, 0, 0, ${layout.shadow.opacity})`;
    ctx.shadowBlur = layout.shadow.blur;
    ctx.shadowOffsetX = layout.shadow.offsetX;
    ctx.shadowOffsetY = layout.shadow.offsetY;

    ctx.fillStyle = '#1a1a1a';
    roundRect(ctx, x, y, deviceWidth, deviceHeight, bezel.radius);
    ctx.fill();

    ctx.restore();
  }

  // Draw device frame
  const frameGradient = ctx.createLinearGradient(x, y, x, y + deviceHeight);
  frameGradient.addColorStop(0, '#2d2d2d');
  frameGradient.addColorStop(1, '#1a1a1a');

  ctx.fillStyle = frameGradient;
  roundRect(ctx, x, y, deviceWidth, deviceHeight, bezel.radius);
  ctx.fill();

  // Draw screen bezel
  ctx.fillStyle = '#000';
  roundRect(
    ctx,
    x + bezel.left / 2,
    y + bezel.top / 2,
    deviceWidth - bezel.left,
    deviceHeight - bezel.top - bezel.bottom / 2,
    bezel.radius - 8
  );
  ctx.fill();

  // Draw screenshot
  const img = new Image();
  img.crossOrigin = 'anonymous';

  await new Promise<void>((resolve, reject) => {
    img.onload = () => resolve();
    img.onerror = () => reject(new Error('Failed to load screenshot'));
    img.src = screenshot.dataUrl;
  });

  const screenX = x + bezel.left;
  const screenY = y + bezel.top;
  const screenWidth = deviceWidth - bezel.left - bezel.right;
  const screenHeight = deviceHeight - bezel.top - bezel.bottom;

  ctx.save();
  roundRect(ctx, screenX, screenY, screenWidth, screenHeight, bezel.radius - 12);
  ctx.clip();
  ctx.drawImage(img, screenX, screenY, screenWidth, screenHeight);
  ctx.restore();

  // Draw device-specific elements
  if (screenshot.device === 'mobile') {
    // Dynamic Island
    ctx.fillStyle = '#000';
    const islandWidth = 90 * scale;
    const islandHeight = 24 * scale;
    roundRect(
      ctx,
      x + (deviceWidth - islandWidth) / 2,
      y + 12 * scale,
      islandWidth,
      islandHeight,
      islandHeight / 2
    );
    ctx.fill();
  }

  if (screenshot.device === 'desktop') {
    // MacBook notch
    ctx.fillStyle = '#000';
    const notchWidth = 140 * scale;
    const notchHeight = 18 * scale;
    roundRect(
      ctx,
      x + (deviceWidth - notchWidth) / 2,
      y,
      notchWidth,
      notchHeight,
      notchHeight / 2
    );
    ctx.fill();
  }
}

function roundRect(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  width: number,
  height: number,
  radius: number
) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
}

function getAnimationOffset(
  animation: AnimationConfig,
  progress: number
): { y: number; rotation: number; scale: number } {
  const { type, intensity } = animation;

  // Use sine wave for smooth looping
  const wave = Math.sin(progress * Math.PI * 2);
  const halfWave = Math.sin(progress * Math.PI);

  switch (type) {
    case 'float':
      return { y: wave * intensity, rotation: 0, scale: 0 };

    case 'rotate3d':
      return { y: 0, rotation: wave * (intensity / 10), scale: 0 };

    case 'pulse':
      return { y: 0, rotation: 0, scale: halfWave * (intensity / 100) };

    case 'bounce':
      const bounceWave = Math.abs(Math.sin(progress * Math.PI * 2));
      return { y: -bounceWave * intensity * 2, rotation: 0, scale: 0 };

    case 'swing':
      return { y: wave * (intensity / 2), rotation: wave * (intensity / 5), scale: 0 };

    default:
      return { y: 0, rotation: 0, scale: 0 };
  }
}
