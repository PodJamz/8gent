{"version":3,"sources":["../../../src/lib/video/ltx-video.ts","../../../src/lib/lynkr/client.ts","../../../src/lib/channels/outbound-router.ts","../../../src/lib/memory/manager.ts","../../../src/lib/memory/ai-ingestion.ts"],"sourcesContent":["/**\n * LTX-2 Video Generation via Fal AI\n *\n * LTX-2 is Lightricks' 19B parameter DiT-based diffusion model for\n * synchronized audio-video generation.\n *\n * Capabilities:\n * - Text-to-Video (T2V)\n * - Image-to-Video (I2V)\n * - Video extension\n *\n * Model: fal-ai/ltx-video\n */\n\n// LTX-2 API endpoints on Fal AI\nconst FAL_API_URL = 'https://queue.fal.run';\nconst LTX_TEXT_TO_VIDEO = 'fal-ai/ltx-video';\nconst LTX_IMAGE_TO_VIDEO = 'fal-ai/ltx-video/image-to-video';\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Types\n// ─────────────────────────────────────────────────────────────────────────────\n\nexport interface LTXTextToVideoRequest {\n  /** Text description of the video to generate */\n  prompt: string;\n  /** What to avoid in the generation */\n  negative_prompt?: string;\n  /** Number of frames (must be 8n+1, e.g., 97, 121, 145) */\n  num_frames?: number;\n  /** Width in pixels (must be divisible by 32) */\n  width?: number;\n  /** Height in pixels (must be divisible by 32) */\n  height?: number;\n  /** Random seed for reproducibility */\n  seed?: number;\n  /** Number of inference steps (default: 30) */\n  num_inference_steps?: number;\n  /** Guidance scale (default: 7.5) */\n  guidance_scale?: number;\n}\n\nexport interface LTXImageToVideoRequest {\n  /** Text description of the motion/animation */\n  prompt: string;\n  /** Starting image URL */\n  image_url: string;\n  /** What to avoid in the generation */\n  negative_prompt?: string;\n  /** Number of frames (must be 8n+1) */\n  num_frames?: number;\n  /** Random seed for reproducibility */\n  seed?: number;\n  /** Number of inference steps */\n  num_inference_steps?: number;\n  /** Guidance scale */\n  guidance_scale?: number;\n}\n\nexport interface LTXVideoResponse {\n  video: {\n    url: string;\n    content_type: string;\n    file_name: string;\n    file_size: number;\n  };\n  seed?: number;\n  timings?: {\n    inference: number;\n  };\n}\n\nexport interface LTXVideoPreset {\n  name: string;\n  width: number;\n  height: number;\n  num_frames: number;\n  description: string;\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Presets\n// ─────────────────────────────────────────────────────────────────────────────\n\nexport const LTX_PRESETS: Record<string, LTXVideoPreset> = {\n  landscape_short: {\n    name: 'Landscape Short',\n    width: 768,\n    height: 512,\n    num_frames: 97, // ~4 seconds at 24fps\n    description: '16:9 landscape, 4 seconds',\n  },\n  landscape_long: {\n    name: 'Landscape Long',\n    width: 768,\n    height: 512,\n    num_frames: 145, // ~6 seconds at 24fps\n    description: '16:9 landscape, 6 seconds',\n  },\n  portrait_short: {\n    name: 'Portrait Short',\n    width: 512,\n    height: 768,\n    num_frames: 97,\n    description: '9:16 portrait (stories/reels), 4 seconds',\n  },\n  portrait_long: {\n    name: 'Portrait Long',\n    width: 512,\n    height: 768,\n    num_frames: 145,\n    description: '9:16 portrait (stories/reels), 6 seconds',\n  },\n  square: {\n    name: 'Square',\n    width: 512,\n    height: 512,\n    num_frames: 97,\n    description: '1:1 square, 4 seconds',\n  },\n  cinematic: {\n    name: 'Cinematic',\n    width: 832,\n    height: 448,\n    num_frames: 121, // ~5 seconds\n    description: '2.39:1 cinematic widescreen, 5 seconds',\n  },\n};\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Fal Queue Helpers\n// ─────────────────────────────────────────────────────────────────────────────\n\ninterface FalQueueResponse {\n  request_id: string;\n  status: string;\n  response_url?: string;\n}\n\ninterface FalStatusResponse {\n  status: 'IN_QUEUE' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED';\n  response_url?: string;\n  logs?: { message: string; timestamp: string }[];\n  error?: string;\n}\n\nasync function submitToFalQueue<T>(\n  model: string,\n  input: Record<string, unknown>,\n  options?: {\n    maxAttempts?: number;\n    pollInterval?: number;\n    onProgress?: (status: string, logs?: { message: string; timestamp: string }[]) => void;\n  }\n): Promise<T> {\n  const apiKey = process.env.FAL_KEY;\n  if (!apiKey) {\n    throw new Error('FAL_KEY not configured');\n  }\n\n  const maxAttempts = options?.maxAttempts ?? 180; // 15 minutes max\n  const pollInterval = options?.pollInterval ?? 5000; // 5 seconds\n\n  // Submit to queue\n  const submitResponse = await fetch(`${FAL_API_URL}/${model}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Authorization: `Key ${apiKey}`,\n    },\n    body: JSON.stringify(input),\n  });\n\n  if (!submitResponse.ok) {\n    const error = await submitResponse.text();\n    throw new Error(`LTX-2 submit error: ${error}`);\n  }\n\n  const queueData: FalQueueResponse = await submitResponse.json();\n  const statusUrl = `${FAL_API_URL}/${model}/requests/${queueData.request_id}/status`;\n  const resultUrl = `${FAL_API_URL}/${model}/requests/${queueData.request_id}`;\n\n  // Poll for completion\n  let attempts = 0;\n\n  while (attempts < maxAttempts) {\n    await new Promise((resolve) => setTimeout(resolve, pollInterval));\n\n    const statusResponse = await fetch(statusUrl, {\n      headers: { Authorization: `Key ${apiKey}` },\n    });\n\n    if (!statusResponse.ok) {\n      attempts++;\n      continue;\n    }\n\n    const status: FalStatusResponse = await statusResponse.json();\n    options?.onProgress?.(status.status, status.logs);\n\n    if (status.status === 'COMPLETED') {\n      const resultResponse = await fetch(resultUrl, {\n        headers: { Authorization: `Key ${apiKey}` },\n      });\n\n      if (!resultResponse.ok) {\n        throw new Error('Failed to fetch LTX-2 result');\n      }\n\n      return resultResponse.json();\n    }\n\n    if (status.status === 'FAILED') {\n      throw new Error(`LTX-2 job failed: ${status.error || 'Unknown error'}`);\n    }\n\n    attempts++;\n  }\n\n  throw new Error('LTX-2 job timed out');\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Public API\n// ─────────────────────────────────────────────────────────────────────────────\n\n/**\n * Generate a video from a text prompt using LTX-2\n */\nexport async function generateVideoFromText(\n  request: LTXTextToVideoRequest,\n  options?: {\n    onProgress?: (status: string) => void;\n  }\n): Promise<LTXVideoResponse> {\n  // Validate frame count (must be 8n+1)\n  if (request.num_frames && (request.num_frames - 1) % 8 !== 0) {\n    const corrected = Math.floor((request.num_frames - 1) / 8) * 8 + 1;\n    console.warn(`LTX-2: Correcting num_frames from ${request.num_frames} to ${corrected} (must be 8n+1)`);\n    request.num_frames = corrected;\n  }\n\n  // Validate dimensions (must be divisible by 32)\n  if (request.width && request.width % 32 !== 0) {\n    request.width = Math.floor(request.width / 32) * 32;\n  }\n  if (request.height && request.height % 32 !== 0) {\n    request.height = Math.floor(request.height / 32) * 32;\n  }\n\n  return submitToFalQueue<LTXVideoResponse>(\n    LTX_TEXT_TO_VIDEO,\n    {\n      prompt: request.prompt,\n      negative_prompt: request.negative_prompt || 'blurry, low quality, distorted, watermark',\n      num_frames: request.num_frames || 97,\n      width: request.width || 768,\n      height: request.height || 512,\n      seed: request.seed,\n      num_inference_steps: request.num_inference_steps || 30,\n      guidance_scale: request.guidance_scale || 7.5,\n    },\n    {\n      onProgress: (status) => options?.onProgress?.(status),\n    }\n  );\n}\n\n/**\n * Generate a video from an image using LTX-2 (Image-to-Video)\n */\nexport async function generateVideoFromImage(\n  request: LTXImageToVideoRequest,\n  options?: {\n    onProgress?: (status: string) => void;\n  }\n): Promise<LTXVideoResponse> {\n  // Validate frame count (must be 8n+1)\n  if (request.num_frames && (request.num_frames - 1) % 8 !== 0) {\n    const corrected = Math.floor((request.num_frames - 1) / 8) * 8 + 1;\n    request.num_frames = corrected;\n  }\n\n  return submitToFalQueue<LTXVideoResponse>(\n    LTX_IMAGE_TO_VIDEO,\n    {\n      prompt: request.prompt,\n      image_url: request.image_url,\n      negative_prompt: request.negative_prompt || 'blurry, low quality, distorted, watermark',\n      num_frames: request.num_frames || 97,\n      seed: request.seed,\n      num_inference_steps: request.num_inference_steps || 30,\n      guidance_scale: request.guidance_scale || 7.5,\n    },\n    {\n      onProgress: (status) => options?.onProgress?.(status),\n    }\n  );\n}\n\n/**\n * Generate video with a preset configuration\n */\nexport async function generateVideoWithPreset(\n  prompt: string,\n  presetName: keyof typeof LTX_PRESETS,\n  options?: {\n    negative_prompt?: string;\n    seed?: number;\n    image_url?: string;\n    onProgress?: (status: string) => void;\n  }\n): Promise<LTXVideoResponse> {\n  const preset = LTX_PRESETS[presetName];\n  if (!preset) {\n    throw new Error(`Unknown preset: ${presetName}`);\n  }\n\n  // If image_url provided, use I2V, otherwise T2V\n  if (options?.image_url) {\n    return generateVideoFromImage(\n      {\n        prompt,\n        image_url: options.image_url,\n        negative_prompt: options.negative_prompt,\n        num_frames: preset.num_frames,\n        seed: options.seed,\n      },\n      { onProgress: options?.onProgress }\n    );\n  }\n\n  return generateVideoFromText(\n    {\n      prompt,\n      negative_prompt: options?.negative_prompt,\n      width: preset.width,\n      height: preset.height,\n      num_frames: preset.num_frames,\n      seed: options?.seed,\n    },\n    { onProgress: options?.onProgress }\n  );\n}\n\n/**\n * Check if LTX-2 is configured (Fal API key available)\n */\nexport function isLTXConfigured(): boolean {\n  return !!process.env.FAL_KEY;\n}\n\n/**\n * Get estimated duration from frame count\n * LTX-2 generates at ~24fps\n */\nexport function getEstimatedDuration(numFrames: number): number {\n  return numFrames / 24;\n}\n\n/**\n * Get recommended frame count for a target duration\n * Returns the nearest valid frame count (8n+1)\n */\nexport function getFrameCountForDuration(targetSeconds: number): number {\n  const targetFrames = Math.round(targetSeconds * 24);\n  // Round to nearest 8n+1\n  return Math.floor((targetFrames - 1) / 8) * 8 + 1;\n}\n","/**\n * Lynkr Client - Universal LLM Proxy Integration\n *\n * Lynkr is a self-hosted proxy that routes AI requests to:\n * - Local models (Ollama, llama.cpp, LM Studio)\n * - Cloud providers (OpenRouter, Anthropic, OpenAI, AWS Bedrock, etc.)\n *\n * This client connects to a Lynkr instance (local or via tunnel) and\n * sends requests in Anthropic format, which Lynkr converts as needed.\n *\n * SECURITY:\n * - API key required (min 32 chars for production)\n * - SSRF protection blocks internal IPs\n * - Audit logging for all requests\n */\n\n// ============================================================================\n// Security Constants\n// ============================================================================\n\n/** Minimum API key length for production use */\nconst MIN_API_KEY_LENGTH = 32;\n\n/** Internal IP patterns that should be blocked (SSRF protection) */\nconst BLOCKED_IP_PATTERNS = [\n  /^127\\./,                           // Loopback\n  /^10\\./,                            // Private Class A\n  /^172\\.(1[6-9]|2[0-9]|3[0-1])\\./,   // Private Class B\n  /^192\\.168\\./,                      // Private Class C\n  /^169\\.254\\./,                      // Link-local\n  /^0\\./,                             // \"This\" network\n  /^100\\.(6[4-9]|[7-9][0-9]|1[0-2][0-7])\\./,  // Carrier-grade NAT\n  /^::1$/,                            // IPv6 loopback\n  /^fc00:/i,                          // IPv6 unique local\n  /^fe80:/i,                          // IPv6 link-local\n  /^localhost$/i,                     // Hostname\n  /^.*\\.local$/i,                     // mDNS\n  /metadata\\.google\\.internal/i,      // GCP metadata\n  /169\\.254\\.169\\.254/,               // AWS/GCP/Azure metadata\n];\n\n/** Allowed URL schemes */\nconst ALLOWED_SCHEMES = ['https:', 'http:'];\n\nexport interface LynkrConfig {\n  /** Lynkr endpoint URL (e.g., http://localhost:8081 or https://tunnel.example.com) */\n  baseUrl: string;\n  /** API key - required for production (min 32 chars) */\n  apiKey?: string;\n  /** Request timeout in ms */\n  timeout?: number;\n  /** Default model to use (pinned to gpt-oss:20b) */\n  defaultModel?: string;\n  /** Skip API key validation (for local dev only) */\n  skipApiKeyValidation?: boolean;\n  /** Skip SSRF validation (for local dev only) */\n  skipSsrfValidation?: boolean;\n}\n\nexport interface LynkrMessage {\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n}\n\nexport interface LynkrTool {\n  name: string;\n  description: string;\n  input_schema: {\n    type: 'object';\n    properties: Record<string, unknown>;\n    required?: string[];\n  };\n}\n\nexport interface LynkrChatRequest {\n  model: string;\n  messages: LynkrMessage[];\n  max_tokens?: number;\n  temperature?: number;\n  tools?: LynkrTool[];\n  system?: string;\n  stream?: boolean;\n}\n\nexport interface LynkrToolUse {\n  type: 'tool_use';\n  id: string;\n  name: string;\n  input: Record<string, unknown>;\n}\n\nexport interface LynkrTextContent {\n  type: 'text';\n  text: string;\n}\n\nexport type LynkrContentBlock = LynkrTextContent | LynkrToolUse;\n\nexport interface LynkrChatResponse {\n  id: string;\n  type: 'message';\n  role: 'assistant';\n  model: string;\n  content: LynkrContentBlock[];\n  stop_reason: 'end_turn' | 'tool_use' | 'max_tokens' | 'stop_sequence';\n  stop_sequence?: string | null;\n  usage: {\n    input_tokens: number;\n    output_tokens: number;\n    cache_creation_input_tokens?: number;\n    cache_read_input_tokens?: number;\n  };\n}\n\nexport interface LynkrHealthStatus {\n  connected: boolean;\n  latencyMs?: number;\n  error?: string;\n  provider?: string;\n  model?: string;\n  version?: string;\n  features?: {\n    memory?: boolean;\n    tools?: boolean;\n    streaming?: boolean;\n    embeddings?: boolean;\n  };\n}\n\nexport interface LynkrMetrics {\n  requestCount: number;\n  totalTokens: number;\n  avgLatency: number;\n  routingDecisions: {\n    local: number;\n    cloud: number;\n  };\n}\n\n// ============================================================================\n// Security Validation\n// ============================================================================\n\nexport interface LynkrSecurityError extends Error {\n  code: 'INVALID_API_KEY' | 'SSRF_BLOCKED' | 'INVALID_URL';\n}\n\n/**\n * Validate API key meets minimum security requirements\n */\nexport function validateApiKey(apiKey: string | undefined, skipValidation?: boolean): void {\n  if (skipValidation) return;\n\n  if (!apiKey || apiKey.length < MIN_API_KEY_LENGTH) {\n    const error = new Error(\n      `Lynkr API key must be at least ${MIN_API_KEY_LENGTH} characters. ` +\n      `Generate with: openssl rand -base64 48`\n    ) as LynkrSecurityError;\n    error.code = 'INVALID_API_KEY';\n    throw error;\n  }\n\n  // Block obviously insecure default keys\n  const insecureKeys = ['lynkr-local', 'dummy', 'test', 'local', 'dev'];\n  if (insecureKeys.includes(apiKey.toLowerCase())) {\n    const error = new Error(\n      'Lynkr API key cannot be a default/test value. Generate a secure key.'\n    ) as LynkrSecurityError;\n    error.code = 'INVALID_API_KEY';\n    throw error;\n  }\n}\n\n/**\n * Validate URL is not targeting internal networks (SSRF protection)\n */\nexport function validateUrlSafety(urlString: string, skipValidation?: boolean): void {\n  if (skipValidation) return;\n\n  try {\n    const url = new URL(urlString);\n\n    // Check scheme\n    if (!ALLOWED_SCHEMES.includes(url.protocol)) {\n      const error = new Error(\n        `URL scheme ${url.protocol} not allowed. Use http: or https:`\n      ) as LynkrSecurityError;\n      error.code = 'INVALID_URL';\n      throw error;\n    }\n\n    // Check hostname against blocked patterns\n    const hostname = url.hostname;\n    for (const pattern of BLOCKED_IP_PATTERNS) {\n      if (pattern.test(hostname)) {\n        const error = new Error(\n          `SSRF protection: ${hostname} is not allowed. Internal IPs are blocked.`\n        ) as LynkrSecurityError;\n        error.code = 'SSRF_BLOCKED';\n        throw error;\n      }\n    }\n  } catch (e) {\n    if ((e as LynkrSecurityError).code) throw e;\n\n    const error = new Error(`Invalid URL: ${urlString}`) as LynkrSecurityError;\n    error.code = 'INVALID_URL';\n    throw error;\n  }\n}\n\n/**\n * Check if running in local development mode\n */\nfunction isLocalDev(): boolean {\n  if (typeof window !== 'undefined') return false;\n  return process.env.NODE_ENV === 'development' ||\n         process.env.LYNKR_SKIP_SECURITY === 'true';\n}\n\n// ============================================================================\n// Audit Logging\n// ============================================================================\n\nexport interface LynkrAuditLog {\n  timestamp: number;\n  action: 'chat' | 'stream' | 'health' | 'metrics';\n  model?: string;\n  baseUrl: string;\n  latencyMs?: number;\n  success: boolean;\n  error?: string;\n  inputTokens?: number;\n  outputTokens?: number;\n}\n\n/** Audit log callback - set this to capture all Lynkr requests */\nexport let auditLogCallback: ((log: LynkrAuditLog) => void) | null = null;\n\n/**\n * Set the audit log callback for security monitoring\n */\nexport function setAuditLogCallback(callback: ((log: LynkrAuditLog) => void) | null): void {\n  auditLogCallback = callback;\n}\n\nfunction logAudit(log: LynkrAuditLog): void {\n  if (auditLogCallback) {\n    try {\n      auditLogCallback(log);\n    } catch (error) {\n      // Log audit failures to console as fallback - don't lose security events silently\n      console.error('[Lynkr AUDIT FAILURE] Failed to log audit event:', error);\n      console.error('[Lynkr AUDIT FAILURE] Event data:', JSON.stringify(log));\n    }\n  }\n\n  // Also log to console in development\n  if (isLocalDev()) {\n    console.log('[Lynkr Audit]', JSON.stringify(log));\n  }\n}\n\n// ============================================================================\n// Lynkr Client\n// ============================================================================\n\n/**\n * Lynkr Client\n *\n * Connects to a Lynkr proxy instance and sends AI requests.\n * Lynkr handles routing to the appropriate provider (local or cloud).\n *\n * SECURITY FEATURES:\n * - API key validation (min 32 chars)\n * - SSRF protection (blocks internal IPs)\n * - Audit logging for all requests\n */\nexport class LynkrClient {\n  private config: Required<Omit<LynkrConfig, 'skipApiKeyValidation' | 'skipSsrfValidation'>> & {\n    skipApiKeyValidation: boolean;\n    skipSsrfValidation: boolean;\n  };\n\n  constructor(config: LynkrConfig) {\n    const skipSecurity = isLocalDev();\n    const skipApiKeyValidation = config.skipApiKeyValidation ?? skipSecurity;\n    const skipSsrfValidation = config.skipSsrfValidation ?? skipSecurity;\n\n    // Validate security requirements\n    if (!skipApiKeyValidation) {\n      validateApiKey(config.apiKey, false);\n    }\n\n    if (!skipSsrfValidation) {\n      validateUrlSafety(config.baseUrl, false);\n    }\n\n    this.config = {\n      baseUrl: config.baseUrl.replace(/\\/$/, ''), // Remove trailing slash\n      apiKey: config.apiKey ?? '',\n      timeout: config.timeout ?? 120000, // 2 minutes default\n      defaultModel: config.defaultModel ?? 'gpt-oss:20b', // Pinned to local model\n      skipApiKeyValidation,\n      skipSsrfValidation,\n    };\n  }\n\n  /**\n   * Check if Lynkr is healthy and reachable\n   */\n  async checkHealth(): Promise<LynkrHealthStatus> {\n    const start = Date.now();\n\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 5000);\n\n      const response = await fetch(`${this.config.baseUrl}/health`, {\n        method: 'GET',\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        return {\n          connected: false,\n          latencyMs: Date.now() - start,\n          error: `HTTP ${response.status}: ${response.statusText}`,\n        };\n      }\n\n      const data = await response.json();\n\n      return {\n        connected: true,\n        latencyMs: Date.now() - start,\n        provider: data.provider,\n        model: data.model,\n        version: data.version,\n        features: {\n          memory: data.memory?.enabled ?? false,\n          tools: data.tools?.enabled ?? true,\n          streaming: data.streaming?.enabled ?? true,\n          embeddings: data.embeddings?.enabled ?? false,\n        },\n      };\n    } catch (error) {\n      return {\n        connected: false,\n        latencyMs: Date.now() - start,\n        error: error instanceof Error ? error.message : 'Connection failed',\n      };\n    }\n  }\n\n  /**\n   * Get Lynkr metrics\n   */\n  async getMetrics(): Promise<LynkrMetrics | null> {\n    try {\n      const response = await fetch(`${this.config.baseUrl}/metrics`, {\n        method: 'GET',\n        signal: AbortSignal.timeout(5000),\n      });\n\n      if (!response.ok) return null;\n\n      return await response.json();\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Send a chat request through Lynkr\n   * Uses Anthropic message format (Lynkr converts as needed)\n   */\n  async chat(request: Omit<LynkrChatRequest, 'model'> & { model?: string }): Promise<LynkrChatResponse> {\n    const start = Date.now();\n    const model = request.model ?? this.config.defaultModel;\n\n    const body: LynkrChatRequest = {\n      model,\n      messages: request.messages,\n      max_tokens: request.max_tokens ?? 4096,\n      temperature: request.temperature ?? 0.7,\n      tools: request.tools,\n      system: request.system,\n      stream: false,\n    };\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n\n    try {\n      const response = await fetch(`${this.config.baseUrl}/v1/messages`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'x-api-key': this.config.apiKey,\n          'anthropic-version': '2023-06-01',\n        },\n        body: JSON.stringify(body),\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        const error = new Error(`Lynkr request failed: ${response.status} - ${errorText}`);\n\n        logAudit({\n          timestamp: Date.now(),\n          action: 'chat',\n          model,\n          baseUrl: this.config.baseUrl,\n          latencyMs: Date.now() - start,\n          success: false,\n          error: error.message,\n        });\n\n        throw error;\n      }\n\n      const result: LynkrChatResponse = await response.json();\n\n      logAudit({\n        timestamp: Date.now(),\n        action: 'chat',\n        model,\n        baseUrl: this.config.baseUrl,\n        latencyMs: Date.now() - start,\n        success: true,\n        inputTokens: result.usage?.input_tokens,\n        outputTokens: result.usage?.output_tokens,\n      });\n\n      return result;\n    } catch (error) {\n      clearTimeout(timeoutId);\n\n      // Log if not already logged\n      if (!(error instanceof Error && error.message.includes('Lynkr request failed'))) {\n        logAudit({\n          timestamp: Date.now(),\n          action: 'chat',\n          model,\n          baseUrl: this.config.baseUrl,\n          latencyMs: Date.now() - start,\n          success: false,\n          error: error instanceof Error ? error.message : 'Unknown error',\n        });\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Send a streaming chat request through Lynkr\n   * Returns an async generator of content deltas\n   */\n  async *chatStream(\n    request: Omit<LynkrChatRequest, 'model' | 'stream'> & { model?: string }\n  ): AsyncGenerator<{\n    type: 'content_block_delta' | 'message_start' | 'message_stop' | 'content_block_start' | 'content_block_stop';\n    delta?: { type: 'text_delta'; text: string } | { type: 'tool_use'; id: string; name: string; input: string };\n    index?: number;\n    content_block?: LynkrContentBlock;\n    message?: Partial<LynkrChatResponse>;\n  }> {\n    const body: LynkrChatRequest = {\n      model: request.model ?? this.config.defaultModel,\n      messages: request.messages,\n      max_tokens: request.max_tokens ?? 4096,\n      temperature: request.temperature ?? 0.7,\n      tools: request.tools,\n      system: request.system,\n      stream: true,\n    };\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n\n    try {\n      const response = await fetch(`${this.config.baseUrl}/v1/messages`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'x-api-key': this.config.apiKey,\n          'anthropic-version': '2023-06-01',\n        },\n        body: JSON.stringify(body),\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`Lynkr stream failed: ${response.status} - ${errorText}`);\n      }\n\n      if (!response.body) {\n        throw new Error('No response body for streaming');\n      }\n\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() ?? '';\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6).trim();\n            if (data === '[DONE]') return;\n\n            try {\n              const event = JSON.parse(data);\n              yield event;\n            } catch {\n              // Skip invalid JSON\n            }\n          }\n        }\n      }\n    } catch (error) {\n      clearTimeout(timeoutId);\n      throw error;\n    }\n  }\n\n  /**\n   * Extract text content from a Lynkr response\n   */\n  static extractText(response: LynkrChatResponse): string {\n    return response.content\n      .filter((block): block is LynkrTextContent => block.type === 'text')\n      .map((block) => block.text)\n      .join('');\n  }\n\n  /**\n   * Extract tool calls from a Lynkr response\n   */\n  static extractToolCalls(response: LynkrChatResponse): LynkrToolUse[] {\n    return response.content.filter((block): block is LynkrToolUse => block.type === 'tool_use');\n  }\n\n  /**\n   * Check if response contains tool calls\n   */\n  static hasToolCalls(response: LynkrChatResponse): boolean {\n    return response.stop_reason === 'tool_use' || response.content.some((block) => block.type === 'tool_use');\n  }\n}\n\n/**\n * Get a configured Lynkr client\n *\n * SECURITY: In production, requires:\n * - LYNKR_API_KEY env var with min 32 chars\n * - Non-internal baseUrl (SSRF protection)\n *\n * In development (NODE_ENV=development), security checks are relaxed.\n */\nexport function getLynkrClient(config?: Partial<LynkrConfig>): LynkrClient {\n  // Environment variables are only available on the server\n  const env = typeof window === 'undefined' ? {\n    baseUrl: process.env.LYNKR_BASE_URL,\n    apiKey: process.env.LYNKR_API_KEY,\n    timeout: process.env.LYNKR_TIMEOUT,\n    defaultModel: process.env.LYNKR_DEFAULT_MODEL,\n    skipSecurity: process.env.LYNKR_SKIP_SECURITY === 'true' ||\n                  process.env.NODE_ENV === 'development',\n  } : { skipSecurity: false };\n\n  const skipSecurity = config?.skipApiKeyValidation ?? config?.skipSsrfValidation ?? env.skipSecurity;\n\n  return new LynkrClient({\n    baseUrl: config?.baseUrl ?? env.baseUrl ?? 'http://localhost:8081',\n    apiKey: config?.apiKey ?? env.apiKey,\n    timeout: config?.timeout ?? parseInt(env.timeout ?? '120000', 10),\n    defaultModel: config?.defaultModel ?? env.defaultModel ?? 'gpt-oss:20b', // Pinned to local model\n    skipApiKeyValidation: skipSecurity,\n    skipSsrfValidation: skipSecurity,\n  });\n}\n\n/**\n * Check Lynkr health with a simple function\n *\n * Health checks skip security validation because:\n * 1. They don't require authentication (just checking connectivity)\n * 2. They may use tunnel URLs that would fail SSRF checks\n */\nexport async function checkLynkrHealth(baseUrl?: string): Promise<LynkrHealthStatus> {\n  // Health checks skip security validation - no auth needed for connectivity test\n  const client = getLynkrClient({\n    baseUrl,\n    skipApiKeyValidation: true,\n    skipSsrfValidation: true,\n  });\n  return client.checkHealth();\n}\n","/**\n * Outbound Message Router\n *\n * Unified system for sending messages across all connected platforms.\n * Routes messages to the correct platform-specific API based on integration.\n */\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport type Platform = \"whatsapp\" | \"telegram\" | \"slack\" | \"discord\" | \"imessage\" | \"email\";\n\nexport interface OutboundMessage {\n  integrationId: string;\n  platform: Platform;\n  recipientId: string; // Platform-specific recipient identifier\n  content: string;\n  messageType?: \"text\" | \"voice\" | \"image\" | \"email\";\n  mediaUrl?: string;\n  replyToMessageId?: string;\n  metadata?: Record<string, unknown>;\n  // Email-specific fields\n  emailSubject?: string;\n  emailReplyTo?: string;\n  emailThreadId?: string;\n}\n\nexport interface SendResult {\n  success: boolean;\n  platformMessageId?: string;\n  error?: string;\n  timestamp: number;\n}\n\nexport interface PlatformCredentials {\n  // WhatsApp (Baileys)\n  sessionData?: string;\n  baileysWebhookUrl?: string;\n\n  // Telegram / Discord / Slack bot token (shared field)\n  botToken?: string;\n  chatId?: string; // Telegram-specific\n\n  // Slack OAuth\n  accessToken?: string;\n\n  // iMessage (BlueBubbles)\n  serverUrl?: string;\n  serverPassword?: string;\n\n  // Email (Resend)\n  fromEmail?: string;\n  replyTo?: string;\n}\n\n// =============================================================================\n// Platform Senders\n// =============================================================================\n\n/**\n * Send message via WhatsApp (Baileys bridge)\n */\nasync function sendWhatsApp(\n  message: OutboundMessage,\n  credentials: PlatformCredentials\n): Promise<SendResult> {\n  const webhookUrl = credentials.baileysWebhookUrl || process.env.BAILEYS_WEBHOOK_URL;\n\n  if (!webhookUrl) {\n    return {\n      success: false,\n      error: \"Baileys webhook URL not configured\",\n      timestamp: Date.now(),\n    };\n  }\n\n  try {\n    // Format phone number for WhatsApp\n    const remoteJid = message.recipientId.includes(\"@\")\n      ? message.recipientId\n      : `${message.recipientId}@s.whatsapp.net`;\n\n    const response = await fetch(webhookUrl, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        action: \"sendMessage\",\n        remoteJid,\n        text: message.content,\n        // Include media if present\n        ...(message.mediaUrl && { mediaUrl: message.mediaUrl }),\n        ...(message.replyToMessageId && { quotedMessageId: message.replyToMessageId }),\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      return { success: false, error, timestamp: Date.now() };\n    }\n\n    const data = await response.json();\n    return {\n      success: true,\n      platformMessageId: data.messageId,\n      timestamp: Date.now(),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"WhatsApp send failed\",\n      timestamp: Date.now(),\n    };\n  }\n}\n\n/**\n * Send message via Telegram Bot API\n */\nasync function sendTelegram(\n  message: OutboundMessage,\n  credentials: PlatformCredentials\n): Promise<SendResult> {\n  const botToken = credentials.botToken || process.env.TELEGRAM_BOT_TOKEN;\n\n  if (!botToken) {\n    return {\n      success: false,\n      error: \"Telegram bot token not configured\",\n      timestamp: Date.now(),\n    };\n  }\n\n  try {\n    const chatId = message.recipientId;\n\n    // Send text message\n    const response = await fetch(\n      `https://api.telegram.org/bot${botToken}/sendMessage`,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          chat_id: chatId,\n          text: message.content,\n          parse_mode: \"Markdown\",\n          ...(message.replyToMessageId && {\n            reply_to_message_id: parseInt(message.replyToMessageId),\n          }),\n        }),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      return { success: false, error, timestamp: Date.now() };\n    }\n\n    const data = await response.json();\n    return {\n      success: true,\n      platformMessageId: String(data.result?.message_id),\n      timestamp: Date.now(),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Telegram send failed\",\n      timestamp: Date.now(),\n    };\n  }\n}\n\n/**\n * Send message via Slack Web API\n */\nasync function sendSlack(\n  message: OutboundMessage,\n  credentials: PlatformCredentials\n): Promise<SendResult> {\n  const botToken = credentials.botToken || credentials.accessToken || process.env.SLACK_BOT_TOKEN;\n\n  if (!botToken) {\n    return {\n      success: false,\n      error: \"Slack bot token not configured\",\n      timestamp: Date.now(),\n    };\n  }\n\n  try {\n    const response = await fetch(\"https://slack.com/api/chat.postMessage\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${botToken}`,\n      },\n      body: JSON.stringify({\n        channel: message.recipientId,\n        text: message.content,\n        mrkdwn: true,\n        ...(message.replyToMessageId && { thread_ts: message.replyToMessageId }),\n      }),\n    });\n\n    const data = await response.json();\n\n    if (!data.ok) {\n      return { success: false, error: data.error, timestamp: Date.now() };\n    }\n\n    return {\n      success: true,\n      platformMessageId: data.ts,\n      timestamp: Date.now(),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Slack send failed\",\n      timestamp: Date.now(),\n    };\n  }\n}\n\n/**\n * Send message via Discord REST API\n */\nasync function sendDiscord(\n  message: OutboundMessage,\n  credentials: PlatformCredentials\n): Promise<SendResult> {\n  const botToken = credentials.botToken || process.env.DISCORD_BOT_TOKEN;\n\n  if (!botToken) {\n    return {\n      success: false,\n      error: \"Discord bot token not configured\",\n      timestamp: Date.now(),\n    };\n  }\n\n  try {\n    const body: Record<string, unknown> = { content: message.content };\n\n    if (message.replyToMessageId) {\n      body.message_reference = { message_id: message.replyToMessageId };\n    }\n\n    const response = await fetch(\n      `https://discord.com/api/v10/channels/${message.recipientId}/messages`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bot ${botToken}`,\n        },\n        body: JSON.stringify(body),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      return { success: false, error, timestamp: Date.now() };\n    }\n\n    const data = await response.json();\n    return {\n      success: true,\n      platformMessageId: data.id,\n      timestamp: Date.now(),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Discord send failed\",\n      timestamp: Date.now(),\n    };\n  }\n}\n\n/**\n * Send message via iMessage (BlueBubbles)\n */\nasync function sendIMessage(\n  message: OutboundMessage,\n  credentials: PlatformCredentials\n): Promise<SendResult> {\n  const serverUrl = credentials.serverUrl || process.env.BLUEBUBBLES_SERVER_URL;\n  const password = credentials.serverPassword || process.env.BLUEBUBBLES_PASSWORD;\n\n  if (!serverUrl || !password) {\n    return {\n      success: false,\n      error: \"BlueBubbles server not configured\",\n      timestamp: Date.now(),\n    };\n  }\n\n  try {\n    const response = await fetch(`${serverUrl}/api/v1/message/text`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${password}`,\n      },\n      body: JSON.stringify({\n        chatGuid: message.recipientId,\n        message: message.content,\n        method: \"private-api\", // Use private API for better reliability\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      return { success: false, error, timestamp: Date.now() };\n    }\n\n    const data = await response.json();\n    return {\n      success: true,\n      platformMessageId: data.data?.guid,\n      timestamp: Date.now(),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"iMessage send failed\",\n      timestamp: Date.now(),\n    };\n  }\n}\n\n/**\n * Send message via Email (Resend)\n */\nasync function sendEmail(\n  message: OutboundMessage,\n  credentials: PlatformCredentials\n): Promise<SendResult> {\n  const apiKey = process.env.RESEND_API_KEY;\n\n  if (!apiKey) {\n    return {\n      success: false,\n      error: \"Resend API key not configured\",\n      timestamp: Date.now(),\n    };\n  }\n\n  const fromEmail = credentials.fromEmail || process.env.CLAW_AI_EMAIL || \"ai@openclaw.io\";\n\n  try {\n    // Dynamic import to avoid issues in non-Node environments\n    const { Resend } = await import(\"resend\");\n    const resend = new Resend(apiKey);\n\n    const subject = message.emailSubject || \"Message from Claw AI\";\n    const htmlContent = `<div style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333;\">\n      ${message.content.split(\"\\n\").map((p) => `<p style=\"margin: 0 0 1em 0;\">${p}</p>`).join(\"\")}\n      <hr style=\"border: none; border-top: 1px solid #eee; margin: 2em 0;\" />\n      <p style=\"color: #666; font-size: 0.9em;\">\n        This message was sent by Claw AI, OpenClaw-OS's digital assistant.<br/>\n        <a href=\"https://openclaw.io\" style=\"color: #007AFF;\">openclaw.io</a>\n      </p>\n    </div>`;\n\n    const { data, error } = await resend.emails.send({\n      from: `Claw AI <${fromEmail}>`,\n      to: [message.recipientId],\n      subject,\n      text: message.content,\n      html: htmlContent,\n      replyTo: credentials.replyTo,\n      headers: message.emailThreadId\n        ? { \"In-Reply-To\": message.emailThreadId }\n        : undefined,\n    });\n\n    if (error) {\n      return { success: false, error: error.message, timestamp: Date.now() };\n    }\n\n    return {\n      success: true,\n      platformMessageId: data?.id,\n      timestamp: Date.now(),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Email send failed\",\n      timestamp: Date.now(),\n    };\n  }\n}\n\n// =============================================================================\n// Main Router\n// =============================================================================\n\n/**\n * Route and send a message to the appropriate platform\n */\nexport async function sendMessage(\n  message: OutboundMessage,\n  credentials?: PlatformCredentials\n): Promise<SendResult> {\n  const creds = credentials || {};\n\n  switch (message.platform) {\n    case \"whatsapp\":\n      return sendWhatsApp(message, creds);\n    case \"telegram\":\n      return sendTelegram(message, creds);\n    case \"slack\":\n      return sendSlack(message, creds);\n    case \"discord\":\n      return sendDiscord(message, creds);\n    case \"imessage\":\n      return sendIMessage(message, creds);\n    case \"email\":\n      return sendEmail(message, creds);\n    default:\n      return {\n        success: false,\n        error: `Unsupported platform: ${message.platform}`,\n        timestamp: Date.now(),\n      };\n  }\n}\n\n/**\n * Send message with Convex integration lookup\n * This version fetches credentials from the integration record\n */\nexport async function sendMessageWithIntegration(\n  convexClient: { query: (api: unknown, args: unknown) => Promise<unknown> },\n  getIntegrationQuery: unknown,\n  message: Omit<OutboundMessage, \"platform\">\n): Promise<SendResult> {\n  try {\n    // Look up the integration\n    const integration = (await convexClient.query(getIntegrationQuery, {\n      integrationId: message.integrationId,\n    })) as {\n      platform: Platform;\n      credentials: PlatformCredentials;\n      settings: { enabled: boolean };\n    } | null;\n\n    if (!integration) {\n      return {\n        success: false,\n        error: `Integration not found: ${message.integrationId}`,\n        timestamp: Date.now(),\n      };\n    }\n\n    if (!integration.settings.enabled) {\n      return {\n        success: false,\n        error: \"Integration is disabled\",\n        timestamp: Date.now(),\n      };\n    }\n\n    // Send via the appropriate platform\n    return sendMessage(\n      { ...message, platform: integration.platform },\n      integration.credentials\n    );\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Failed to send message\",\n      timestamp: Date.now(),\n    };\n  }\n}\n\n// =============================================================================\n// Batch Operations\n// =============================================================================\n\n/**\n * Send the same message to multiple platforms\n */\nexport async function broadcastMessage(\n  messages: OutboundMessage[]\n): Promise<Map<string, SendResult>> {\n  const results = new Map<string, SendResult>();\n\n  // Send all messages in parallel\n  const promises = messages.map(async (msg) => {\n    const result = await sendMessage(msg);\n    results.set(msg.integrationId, result);\n  });\n\n  await Promise.allSettled(promises);\n  return results;\n}\n","/**\n * MemoryManager\n *\n * Handles memory operations for the RLM (Recursive Memory Layer) system.\n * Provides methods to store, retrieve, and manage episodic, semantic,\n * and working memory for Claw AI interactions.\n *\n * @see docs/philosophy/README.md#self-learning-systems\n * @see docs/planning/recursive-memory-layer-scope.md\n */\n\nimport { ConvexHttpClient, api, Id } from '../convex-shim';\nimport {\n  EpisodicMemory,\n  EpisodicMemoryType,\n  ExtractedPattern,\n  Interaction,\n  MemorySearchOptions,\n  MemorySearchResult,\n  SemanticCategory,\n  SemanticMemory,\n} from \"./types\";\n\n// Dynamic import to handle cases where api types aren't generated yet\n// let api: any;\n// try {\n//   api = require('@/lib/convex-shim').api;\n// } catch {\n//   // API not generated yet - will use string paths\n//   api = null;\n// }\n\nexport class MemoryManager {\n  private convex: ConvexHttpClient | null = null;\n\n  constructor(convexUrl?: string) {\n    const url = convexUrl || process.env.NEXT_PUBLIC_CONVEX_URL;\n    if (url) {\n      this.convex = new ConvexHttpClient(url);\n    }\n  }\n\n  private getClient(): ConvexHttpClient {\n    if (!this.convex) {\n      const url = process.env.NEXT_PUBLIC_CONVEX_URL;\n      if (!url) {\n        throw new Error('NEXT_PUBLIC_CONVEX_URL not configured');\n      }\n      this.convex = new ConvexHttpClient(url);\n    }\n    return this.convex;\n  }\n\n  /**\n   * Get the API reference\n   */\n  private getApiRef(path: string) {\n    // If api is available (from shim or require), try to use it\n    if (api) {\n      const parts = path.split(\".\");\n      let ref: any = api;\n      for (const part of parts) {\n        if (ref) {\n          ref = ref[part];\n        }\n      }\n      if (ref) return ref;\n    }\n    // Fallback: return the path string\n    return path;\n  }\n\n  // ==========================================================================\n  // MEMORY LOADING\n  // ==========================================================================\n\n  /**\n   * Load relevant memories for a user query.\n   * Combines episodic (events) and semantic (facts) memories.\n   */\n  async loadRelevantMemories(\n    userId: string,\n    query: string,\n    options: MemorySearchOptions = {}\n  ): Promise<MemorySearchResult> {\n    const {\n      limit = 10,\n      includeEpisodic = true,\n      includeSemantic = true,\n      projectId,\n    } = options;\n\n    // Parallel fetch of episodic and semantic memories\n    const [episodic, semantic] = await Promise.all([\n      includeEpisodic\n        ? this.searchEpisodicMemories(userId, query, projectId, limit)\n        : [],\n      includeSemantic\n        ? this.loadSemanticMemories(userId, this.extractCategories(query))\n        : [],\n    ]);\n\n    // Build context summary for prompt injection\n    const contextSummary = this.buildContextSummary(episodic, semantic);\n\n    return { episodic, semantic, contextSummary };\n  }\n\n  /**\n   * Search episodic memories using text matching.\n   */\n  async searchEpisodicMemories(\n    userId: string,\n    query: string,\n    projectId?: Id<\"productProjects\">,\n    limit: number = 10\n  ): Promise<EpisodicMemory[]> {\n    const results = await this.getClient().query(\n      this.getApiRef(\"memories.searchEpisodic\"),\n      { userId, query, projectId, limit }\n    );\n    return results as EpisodicMemory[];\n  }\n\n  /**\n   * Load semantic memories by categories.\n   */\n  async loadSemanticMemories(\n    userId: string,\n    categories: SemanticCategory[]\n  ): Promise<SemanticMemory[]> {\n    const results = await this.getClient().query(\n      this.getApiRef(\"memories.getSemanticByCategories\"),\n      { userId, categories }\n    );\n    return results as SemanticMemory[];\n  }\n\n  /**\n   * Get all semantic memories for a user.\n   */\n  async getAllSemanticMemories(userId: string): Promise<SemanticMemory[]> {\n    const results = await this.getClient().query(\n      this.getApiRef(\"memories.getAllSemantic\"),\n      { userId }\n    );\n    return results as SemanticMemory[];\n  }\n\n  /**\n   * Get recent episodic memories.\n   */\n  async getRecentMemories(\n    userId: string,\n    projectId?: Id<\"productProjects\">,\n    limit: number = 10\n  ): Promise<EpisodicMemory[]> {\n    const results = await this.getClient().query(\n      this.getApiRef(\"memories.getRecentEpisodic\"),\n      { userId, projectId, limit }\n    );\n    return results as EpisodicMemory[];\n  }\n\n  // ==========================================================================\n  // MEMORY STORAGE\n  // ==========================================================================\n\n  /**\n   * Store an episodic memory.\n   */\n  async storeEpisodicMemory(\n    userId: string,\n    content: string,\n    memoryType: EpisodicMemoryType,\n    importance: number,\n    projectId?: Id<\"productProjects\">,\n    metadata?: {\n      toolsUsed?: string[];\n      outcome?: string;\n      compactionId?: string;\n      messageCount?: number;\n      topics?: string[];\n      [key: string]: unknown;\n    }\n  ): Promise<Id<\"episodicMemories\">> {\n    return await this.getClient().mutation(\n      this.getApiRef(\"memories.storeEpisodic\"),\n      { userId, projectId, content, memoryType, importance, metadata }\n    );\n  }\n\n  /**\n   * Store or update a semantic memory.\n   */\n  async upsertSemanticMemory(\n    userId: string,\n    category: SemanticCategory,\n    key: string,\n    value: string,\n    confidence: number,\n    source: string\n  ): Promise<Id<\"semanticMemories\">> {\n    return await this.getClient().mutation(\n      this.getApiRef(\"memories.upsertSemantic\"),\n      { userId, category, key, value, confidence, source }\n    );\n  }\n\n  // ==========================================================================\n  // INTERACTION PROCESSING\n  // ==========================================================================\n\n  /**\n   * Process an interaction and extract/store relevant memories.\n   */\n  async processInteraction(\n    userId: string,\n    interaction: Interaction,\n    projectId?: Id<\"productProjects\">\n  ): Promise<void> {\n    const importance = this.calculateImportance(interaction);\n\n    // Only store significant interactions (importance > 0.3)\n    if (importance > 0.3) {\n      const memoryType = this.classifyInteraction(interaction);\n      const content = this.summarizeInteraction(interaction);\n\n      await this.storeEpisodicMemory(\n        userId,\n        content,\n        memoryType,\n        importance,\n        projectId,\n        { toolsUsed: interaction.toolsUsed }\n      );\n    }\n\n    // Extract and store patterns/preferences\n    const patterns = this.extractPatterns(interaction);\n    for (const pattern of patterns) {\n      await this.upsertSemanticMemory(\n        userId,\n        pattern.category,\n        pattern.key,\n        pattern.value,\n        pattern.confidence,\n        \"interaction_learning\"\n      );\n    }\n  }\n\n  // ==========================================================================\n  // HELPER METHODS\n  // ==========================================================================\n\n  /**\n   * Extract relevant categories from a query for semantic memory lookup.\n   */\n  extractCategories(query: string): SemanticCategory[] {\n    const categories: SemanticCategory[] = [];\n    const lowerQuery = query.toLowerCase();\n\n    if (/prefer|like|style|theme|mode|favorite/.test(lowerQuery)) {\n      categories.push(\"preference\");\n    }\n    if (/skill|know|experience|proficient|expert|can you/.test(lowerQuery)) {\n      categories.push(\"skill\");\n    }\n    if (/pattern|usually|always|tend to|typically/.test(lowerQuery)) {\n      categories.push(\"pattern\");\n    }\n    if (/fact|is|are|does|what|who|where/.test(lowerQuery)) {\n      categories.push(\"fact\");\n    }\n\n    // Default to common categories if none detected\n    return categories.length > 0\n      ? categories\n      : [\"preference\", \"skill\", \"pattern\"];\n  }\n\n  /**\n   * Build a context summary for prompt injection.\n   */\n  buildContextSummary(\n    episodic: EpisodicMemory[],\n    semantic: SemanticMemory[]\n  ): string {\n    const parts: string[] = [];\n\n    // Add semantic memories (facts/preferences) - highest confidence first\n    if (semantic.length > 0) {\n      const semanticSummary = semantic\n        .sort((a, b) => b.confidence - a.confidence)\n        .slice(0, 5)\n        .map((m) => `- ${m.category}: ${m.value}`)\n        .join(\"\\n\");\n      parts.push(`User Context:\\n${semanticSummary}`);\n    }\n\n    // Add recent relevant episodic memories - highest importance first\n    if (episodic.length > 0) {\n      const episodicSummary = episodic\n        .sort((a, b) => b.importance - a.importance)\n        .slice(0, 3)\n        .map((m) => `- [${m.memoryType}] ${m.content}`)\n        .join(\"\\n\");\n      parts.push(`Recent History:\\n${episodicSummary}`);\n    }\n\n    return parts.join(\"\\n\\n\");\n  }\n\n  /**\n   * Calculate importance score for an interaction.\n   */\n  calculateImportance(interaction: Interaction): number {\n    let score = 0.3; // Base importance\n\n    // Positive feedback signals\n    if (\n      /thanks|perfect|great|exactly|awesome|excellent/i.test(\n        interaction.userMessage\n      )\n    ) {\n      score += 0.2;\n    }\n\n    // Multiple tools indicate complex interaction\n    if (interaction.toolsUsed.length > 2) {\n      score += 0.15;\n    }\n\n    // Decision-making language\n    if (\n      /decide|choose|prefer|want|let's|go with/i.test(interaction.userMessage)\n    ) {\n      score += 0.2;\n    }\n\n    // Creation operations are important\n    if (interaction.toolsUsed.some((t) => /create|update|delete/.test(t))) {\n      score += 0.15;\n    }\n\n    return Math.min(score, 1);\n  }\n\n  /**\n   * Classify an interaction into a memory type.\n   */\n  classifyInteraction(interaction: Interaction): EpisodicMemoryType {\n    const msg = interaction.userMessage.toLowerCase();\n\n    // Check for feedback\n    if (/thanks|great|perfect|awesome|excellent|love it/.test(msg)) {\n      return \"feedback\";\n    }\n\n    // Check for preferences\n    if (/prefer|like|want|rather|always use|my favorite/.test(msg)) {\n      return \"preference\";\n    }\n\n    // Check for decisions\n    if (/decide|choose|let's go with|use this|pick/.test(msg)) {\n      return \"decision\";\n    }\n\n    // Check for milestones based on tools\n    if (\n      interaction.toolsUsed.some((t) =>\n        /create_project|create_prd|shard_prd|launch/.test(t)\n      )\n    ) {\n      return \"milestone\";\n    }\n\n    return \"interaction\";\n  }\n\n  /**\n   * Summarize an interaction for storage.\n   */\n  summarizeInteraction(interaction: Interaction): string {\n    // Truncate user message if too long\n    const userPart =\n      interaction.userMessage.length > 100\n        ? interaction.userMessage.slice(0, 100) + \"...\"\n        : interaction.userMessage;\n\n    if (interaction.toolsUsed.length > 0) {\n      return `User: \"${userPart}\" → Tools: ${interaction.toolsUsed.join(\", \")}`;\n    }\n    return `User: \"${userPart}\"`;\n  }\n\n  /**\n   * Extract patterns/preferences from an interaction.\n   */\n  extractPatterns(interaction: Interaction): ExtractedPattern[] {\n    const patterns: ExtractedPattern[] = [];\n    const msg = interaction.userMessage.toLowerCase();\n\n    // Detect explicit preferences\n    if (/i prefer|i like|i want|my favorite|i always use/.test(msg)) {\n      patterns.push({\n        category: \"preference\",\n        key: `pref_${Date.now()}`,\n        value: interaction.userMessage.slice(0, 200),\n        confidence: 0.7,\n      });\n    }\n\n    // Detect skill mentions\n    if (/i know|i can|experience with|proficient in|expert at/.test(msg)) {\n      patterns.push({\n        category: \"skill\",\n        key: `skill_${Date.now()}`,\n        value: interaction.userMessage.slice(0, 200),\n        confidence: 0.6,\n      });\n    }\n\n    // Detect behavioral patterns\n    if (/i usually|i always|i tend to|typically i/.test(msg)) {\n      patterns.push({\n        category: \"pattern\",\n        key: `pattern_${Date.now()}`,\n        value: interaction.userMessage.slice(0, 200),\n        confidence: 0.5,\n      });\n    }\n\n    return patterns;\n  }\n\n  // ==========================================================================\n  // MEMORY MANAGEMENT\n  // ==========================================================================\n\n  /**\n   * Delete an episodic memory.\n   */\n  async deleteEpisodicMemory(\n    memoryId: Id<\"episodicMemories\">,\n    userId: string\n  ): Promise<void> {\n    await this.getClient().mutation(\n      this.getApiRef(\"memories.deleteEpisodic\"),\n      { memoryId, userId }\n    );\n  }\n\n  /**\n   * Delete a semantic memory.\n   */\n  async deleteSemanticMemory(\n    memoryId: Id<\"semanticMemories\">,\n    userId: string\n  ): Promise<void> {\n    await this.getClient().mutation(\n      this.getApiRef(\"memories.deleteSemantic\"),\n      { memoryId, userId }\n    );\n  }\n\n  /**\n   * Get memory statistics for a user.\n   */\n  async getStats(userId: string) {\n    return await this.getClient().query(\n      this.getApiRef(\"memories.getMemoryStats\"),\n      { userId }\n    );\n  }\n}\n\n// Export singleton instance for convenience\nlet memoryManagerInstance: MemoryManager | null = null;\n\nexport function getMemoryManager(): MemoryManager {\n  if (!memoryManagerInstance) {\n    memoryManagerInstance = new MemoryManager();\n  }\n  return memoryManagerInstance;\n}\n","/**\n * AI-Powered Memory Ingestion\n *\n * Uses OpenAI (GPT-4o) to intelligently parse unstructured data and extract\n * structured memories (both episodic and semantic).\n *\n * @see docs/planning/recursive-memory-layer-scope.md\n */\n\nimport type { EpisodicMemoryType, SemanticCategory } from \"./types\";\n\n/**\n * Extracted memory from AI processing\n */\nexport interface ExtractedEpisodicMemory {\n  content: string;\n  memoryType: EpisodicMemoryType;\n  importance: number; // 0-1\n  context?: string; // Additional context about why this is important\n}\n\nexport interface ExtractedSemanticMemory {\n  category: SemanticCategory;\n  key: string; // Unique identifier like \"preferred_language\" or \"favorite_color\"\n  value: string; // The actual value/fact\n  confidence: number; // 0-1\n  source?: string; // Where this was extracted from\n}\n\nexport interface AIIngestionResult {\n  episodicMemories: ExtractedEpisodicMemory[];\n  semanticMemories: ExtractedSemanticMemory[];\n  summary: string;\n  processingNotes: string[];\n}\n\n/**\n * System prompt for memory extraction\n */\nconst EXTRACTION_SYSTEM_PROMPT = `You are a memory extraction AI for a personal knowledge system. Your job is to analyze text and extract two types of memories:\n\n## EPISODIC MEMORIES (Events/Interactions)\nThese are specific events, decisions, conversations, or milestones. Each should have:\n- content: A clear, standalone summary of what happened (50-200 chars)\n- memoryType: One of \"interaction\", \"decision\", \"preference\", \"feedback\", \"milestone\"\n- importance: 0.0-1.0 (higher = more significant)\n\nMemory type guidelines:\n- \"interaction\": General conversations or exchanges\n- \"decision\": Choices made, directions taken, options selected\n- \"preference\": Expressed likes, dislikes, preferences for how things should be\n- \"feedback\": Reactions to work, opinions given, reviews\n- \"milestone\": Achievements, completions, launches, significant events\n\n## SEMANTIC MEMORIES (Facts/Knowledge)\nThese are learned facts, preferences, patterns, and skills. Each should have:\n- category: One of \"preference\", \"skill\", \"pattern\", \"fact\"\n- key: A unique snake_case identifier (e.g., \"preferred_coding_language\", \"communication_style\")\n- value: The actual knowledge/fact (clear, specific)\n- confidence: 0.0-1.0 (how certain is this information)\n\nCategory guidelines:\n- \"preference\": Likes, dislikes, preferred ways of doing things\n- \"skill\": Abilities, expertise, proficiency levels\n- \"pattern\": Behavioral patterns, habits, tendencies\n- \"fact\": Objective facts about the person (location, job, etc.)\n\n## RULES\n1. Extract MEANINGFUL memories only - skip trivial/obvious content\n2. Be specific and actionable in your extractions\n3. Deduplicate - don't extract the same fact multiple times\n4. For semantic memories, use consistent key naming (snake_case, descriptive)\n5. Higher importance/confidence for explicitly stated things vs inferred\n6. Include context when it adds value\n\nRespond with valid JSON only, no markdown formatting.`;\n\n/**\n * Call OpenAI API directly\n */\nasync function callOpenAI(\n  systemPrompt: string,\n  userPrompt: string\n): Promise<string> {\n  const apiKey = process.env.OPENAI_API_KEY;\n  if (!apiKey) {\n    throw new Error(\"OPENAI_API_KEY not configured\");\n  }\n\n  const response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${apiKey}`,\n    },\n    body: JSON.stringify({\n      model: \"gpt-4o\",\n      max_tokens: 4096,\n      response_format: { type: \"json_object\" },\n      messages: [\n        { role: \"system\", content: systemPrompt },\n        { role: \"user\", content: userPrompt },\n      ],\n    }),\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    throw new Error(`OpenAI API error: ${response.status} - ${error}`);\n  }\n\n  const data = await response.json();\n  return data.choices?.[0]?.message?.content || \"\";\n}\n\n/**\n * Process content with AI and extract structured memories\n */\nexport async function extractMemoriesWithAI(\n  content: string,\n  filename: string,\n  options: {\n    maxEpisodic?: number;\n    maxSemantic?: number;\n  } = {}\n): Promise<AIIngestionResult> {\n  const { maxEpisodic = 50, maxSemantic = 30 } = options;\n\n  // Truncate very long content to avoid token limits\n  const truncatedContent =\n    content.length > 50000\n      ? content.slice(0, 50000) + \"\\n\\n[Content truncated...]\"\n      : content;\n\n  const userPrompt = `Analyze the following content from file \"${filename}\" and extract memories.\n\n<content>\n${truncatedContent}\n</content>\n\nExtract up to ${maxEpisodic} episodic memories and ${maxSemantic} semantic memories.\n\nRespond with this exact JSON structure:\n{\n  \"episodicMemories\": [\n    {\n      \"content\": \"string\",\n      \"memoryType\": \"interaction|decision|preference|feedback|milestone\",\n      \"importance\": 0.0-1.0,\n      \"context\": \"optional string\"\n    }\n  ],\n  \"semanticMemories\": [\n    {\n      \"category\": \"preference|skill|pattern|fact\",\n      \"key\": \"snake_case_key\",\n      \"value\": \"string\",\n      \"confidence\": 0.0-1.0,\n      \"source\": \"optional string\"\n    }\n  ],\n  \"summary\": \"Brief summary of what was extracted\",\n  \"processingNotes\": [\"Any notes about the extraction process\"]\n}`;\n\n  try {\n    const textContent = await callOpenAI(EXTRACTION_SYSTEM_PROMPT, userPrompt);\n\n    if (!textContent) {\n      throw new Error(\"No response from AI\");\n    }\n\n    // Parse JSON response\n    const result = JSON.parse(textContent) as AIIngestionResult;\n\n    // Validate and sanitize the result\n    return sanitizeIngestionResult(result, filename);\n  } catch (error) {\n    console.error(\"AI ingestion error:\", error);\n\n    // Return empty result on error\n    return {\n      episodicMemories: [],\n      semanticMemories: [],\n      summary: `Failed to process ${filename}`,\n      processingNotes: [\n        `Error: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n      ],\n    };\n  }\n}\n\n/**\n * Validate and sanitize AI extraction results\n */\nfunction sanitizeIngestionResult(\n  result: AIIngestionResult,\n  filename: string\n): AIIngestionResult {\n  const validEpisodicTypes: EpisodicMemoryType[] = [\n    \"interaction\",\n    \"decision\",\n    \"preference\",\n    \"feedback\",\n    \"milestone\",\n  ];\n\n  const validSemanticCategories: SemanticCategory[] = [\n    \"preference\",\n    \"skill\",\n    \"pattern\",\n    \"fact\",\n  ];\n\n  // Sanitize episodic memories\n  const episodicMemories = (result.episodicMemories || [])\n    .filter((m) => m && typeof m.content === \"string\" && m.content.length > 10)\n    .map((m) => ({\n      content: m.content.slice(0, 500), // Limit length\n      memoryType: validEpisodicTypes.includes(m.memoryType)\n        ? m.memoryType\n        : \"interaction\",\n      importance: Math.max(0, Math.min(1, Number(m.importance) || 0.5)),\n      context: m.context ? String(m.context).slice(0, 200) : undefined,\n    }));\n\n  // Sanitize semantic memories\n  const semanticMemories = (result.semanticMemories || [])\n    .filter(\n      (m) =>\n        m &&\n        typeof m.key === \"string\" &&\n        m.key.length > 0 &&\n        typeof m.value === \"string\" &&\n        m.value.length > 0\n    )\n    .map((m) => ({\n      category: validSemanticCategories.includes(m.category)\n        ? m.category\n        : \"fact\",\n      key: m.key\n        .toLowerCase()\n        .replace(/[^a-z0-9_]/g, \"_\")\n        .slice(0, 50),\n      value: m.value.slice(0, 500),\n      confidence: Math.max(0, Math.min(1, Number(m.confidence) || 0.5)),\n      source: m.source\n        ? String(m.source).slice(0, 100)\n        : `Extracted from ${filename}`,\n    }));\n\n  return {\n    episodicMemories,\n    semanticMemories,\n    summary: result.summary || `Processed ${filename}`,\n    processingNotes: Array.isArray(result.processingNotes)\n      ? result.processingNotes.map((n) => String(n))\n      : [],\n  };\n}\n\n/**\n * Process multiple content chunks (for large files)\n */\nexport async function processLargeContent(\n  content: string,\n  filename: string,\n  chunkSize: number = 30000\n): Promise<AIIngestionResult> {\n  // If content is small enough, process directly\n  if (content.length <= chunkSize) {\n    return extractMemoriesWithAI(content, filename);\n  }\n\n  // Split into chunks at paragraph boundaries\n  const chunks: string[] = [];\n  let currentChunk = \"\";\n\n  const paragraphs = content.split(/\\n\\n+/);\n  for (const para of paragraphs) {\n    if (currentChunk.length + para.length > chunkSize) {\n      if (currentChunk) {\n        chunks.push(currentChunk);\n      }\n      currentChunk = para;\n    } else {\n      currentChunk += (currentChunk ? \"\\n\\n\" : \"\") + para;\n    }\n  }\n  if (currentChunk) {\n    chunks.push(currentChunk);\n  }\n\n  // Process each chunk\n  const results: AIIngestionResult[] = [];\n  for (let i = 0; i < chunks.length; i++) {\n    const chunkFilename = `${filename} (part ${i + 1}/${chunks.length})`;\n    const result = await extractMemoriesWithAI(chunks[i], chunkFilename);\n    results.push(result);\n  }\n\n  // Merge results\n  return mergeIngestionResults(results, filename);\n}\n\n/**\n * Merge multiple ingestion results\n */\nfunction mergeIngestionResults(\n  results: AIIngestionResult[],\n  filename: string\n): AIIngestionResult {\n  const allEpisodic: ExtractedEpisodicMemory[] = [];\n  const allSemantic: ExtractedSemanticMemory[] = [];\n  const allNotes: string[] = [];\n\n  for (const result of results) {\n    allEpisodic.push(...result.episodicMemories);\n    allSemantic.push(...result.semanticMemories);\n    allNotes.push(...result.processingNotes);\n  }\n\n  // Deduplicate semantic memories by key (keep highest confidence)\n  const semanticByKey = new Map<string, ExtractedSemanticMemory>();\n  for (const mem of allSemantic) {\n    const existing = semanticByKey.get(mem.key);\n    if (!existing || mem.confidence > existing.confidence) {\n      semanticByKey.set(mem.key, mem);\n    }\n  }\n\n  return {\n    episodicMemories: allEpisodic,\n    semanticMemories: Array.from(semanticByKey.values()),\n    summary: `Processed ${filename} in ${results.length} chunks`,\n    processingNotes: allNotes,\n  };\n}\n"],"names":[],"mappings":"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"}