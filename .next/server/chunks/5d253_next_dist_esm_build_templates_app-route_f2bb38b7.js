module.exports=[122324,e=>{"use strict";var t=e.i(457375),r=e.i(174015),n=e.i(116384),a=e.i(63831),o=e.i(868001),i=e.i(842780),s=e.i(763077),l=e.i(502964),d=e.i(993216),c=e.i(783900),u=e.i(295731),p=e.i(726839),h=e.i(775778),g=e.i(40992),m=e.i(432128),f=e.i(193695);e.i(44807);var w=e.i(989978),R=e.i(39334),y=e.i(848920),v=e.i(488782),E=e.i(879389);async function x(e,t){let r=e.headers.get("x-signature-ed25519"),n=e.headers.get("x-signature-timestamp");if(!r||!n)return console.warn("Missing Discord signature headers"),!1;try{let e=function(){let e=process.env.DISCORD_PUBLIC_KEY;if(!e)throw Error("DISCORD_PUBLIC_KEY not configured");return e}(),a=C(e),o=await crypto.subtle.importKey("raw",a,{name:"Ed25519",namedCurve:"Ed25519"},!1,["verify"]),i=new TextEncoder().encode(n+t),s=C(r);return await crypto.subtle.verify("Ed25519",o,s,i)}catch(e){return console.error("Discord signature verification error:",e),!1}}function C(e){let t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=parseInt(e.substr(r,2),16);return t}async function I(e){let t=process.env.NEXT_PUBLIC_APP_URL||"http://localhost:3000";try{if(!function(e){try{let t=new URL(e);return["cdn.discordapp.com","media.discordapp.net"].some(e=>t.hostname===e||t.hostname.endsWith("."+e))}catch{return!1}}(e))return console.error("Attempted to download audio from unauthorized domain:",e),null;let r=await fetch(e);if(!r.ok)return console.error("Failed to download audio"),null;let n=await r.blob(),a=new FormData;a.append("audio",n,"voice.ogg");let o=await fetch(`${t}/api/whisper`,{method:"POST",body:a});if(!o.ok)return console.error("Whisper API error:",await o.text()),null;return(await o.json()).text||null}catch(e){return console.error("Transcription error:",e),null}}async function b(e,t){let r=process.env.DISCORD_APPLICATION_ID;try{await fetch(`https://discord.com/api/v10/interactions/${e.id}/${e.token}/callback`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({type:5})});let n=await t();return(await fetch(`https://discord.com/api/v10/webhooks/${r}/${e.token}/messages/@original`,{method:"PATCH",headers:{"Content-Type":"application/json"},body:JSON.stringify({content:n})})).ok}catch(e){return console.error("Discord deferred response failed:",e),!1}}async function T(e,t,r){let n=process.env.NEXT_PUBLIC_APP_URL||"http://localhost:3000";try{let a=await fetch(`${n}/api/chat`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({messages:[...r,{role:"user",content:function(e,t=5e3){return e.replace(/ignore previous instructions/gi,"[filtered]").replace(/system prompt/gi,"[filtered]").replace(/\[INST\]/gi,"[filtered]").replace(/<\|im_start\|>/gi,"[filtered]").replace(/\[SYSTEM\]/gi,"[filtered]").replace(/assistant:/gi,"[filtered]").slice(0,t)}(t)}],userId:e,channel:"discord"})});if(!a.ok){let e=await a.text();return console.error("8gent error:",e),"I'm having trouble processing that right now. Please try again."}let o=await a.json();return o.content||o.message||"I couldn't generate a response."}catch(e){return console.error("AI processing error:",e),"Sorry, I encountered an error. Please try again."}}async function N(e,t,r){return(await e.query(v.api.channels.getRecentMessages,{integrationId:t,limit:r})).reverse().map(e=>({role:"inbound"===e.direction?"user":"assistant",content:e.content}))}async function P(e){let t=Date.now();try{let r=await e.text();if(!await x(e,r))return R.NextResponse.json({error:"Invalid signature"},{status:401});let n=JSON.parse(r);if(1===n.type)return R.NextResponse.json({type:1});let a=(0,E.getClientIp)(e),o=(0,E.checkRateLimit)(`webhook:discord:${a}`,{maxRequests:30,windowMs:6e4});if(!o.allowed)return console.warn(`[Discord] Rate limit exceeded for ${a}`),R.NextResponse.json({error:"Rate limit exceeded"},{status:429,headers:{"Retry-After":String(Math.ceil((o.resetAt-Date.now())/1e3)),"X-RateLimit-Limit":"30","X-RateLimit-Remaining":String(o.remaining),"X-RateLimit-Reset":String(Math.floor(o.resetAt/1e3))}});let i=function(){let e=process.env.NEXT_PUBLIC_CONVEX_URL;if(!e)throw Error("NEXT_PUBLIC_CONVEX_URL not configured");return new y.ConvexHttpClient(e)}(),s=n.member?.user||n.user;if(!s||s.bot)return R.NextResponse.json({type:4,data:{content:"I can only respond to human users!"}});let l=s.id,d=s.global_name||s.username,c=await i.query(v.api.channels.getIntegrationByPlatformUser,{platform:"discord",platformUserId:l});if(!c)return R.NextResponse.json({type:4,data:{content:`Hey ${d}! I'm 8gent. To chat with me, please connect your Discord account at openclaw.io/settings/channels`}});if(!c.settings.enabled)return R.NextResponse.json({type:4,data:{content:"Your 8gent integration is currently disabled. Enable it in settings to continue chatting."}});if(2===n.type&&n.data){let e=n.data.name,r=n.data.options||[];if("ask"===e||"james"===e){let e,a=r.find(e=>"message"===e.name),o=String(a?.value||""),s=r.find(e=>"audio"===e.name||"voice"===e.name);if(s&&n.data?.resolved?.attachments){let t=String(s.value),r=n.data.resolved.attachments[t];r?.content_type?.startsWith("audio/")&&(e=await I(r.url)||void 0)&&(o=o?`${o}

[Voice: ${e}]`:e)}if(!o)return R.NextResponse.json({type:4,data:{content:"Please provide a message or voice attachment!"}});let l=await b(n,async()=>{let{messageId:e}=await i.mutation(v.api.channels.logInboundMessage,{integrationId:c.integrationId,userId:c.userId,platform:"discord",platformMessageId:n.id,messageType:"text",content:o,platformTimestamp:Date.now()});await i.mutation(v.api.channels.updateMessageStatus,{messageId:e,status:"processing"});let r=await N(i,c.integrationId,c.settings.contextLimit),a=await T(c.userId,o,r),s=Date.now()-t;return await i.mutation(v.api.channels.updateMessageStatus,{messageId:e,status:"responded",aiResponse:a,processingTimeMs:s}),await i.mutation(v.api.channels.logOutboundMessage,{integrationId:c.integrationId,userId:c.userId,platform:"discord",messageType:"text",content:a,processingTimeMs:s}),a});return R.NextResponse.json({ok:!0,sent:l})}}return R.NextResponse.json({type:4,data:{content:"I'm not sure how to handle that interaction."}})}catch(e){return console.error("Discord webhook error:",e),R.NextResponse.json({ok:!1,error:e instanceof Error?e.message:"Webhook processing failed"},{status:500})}}async function S(){return R.NextResponse.json({status:"ok",webhook:"discord",timestamp:new Date().toISOString()})}e.s(["GET",()=>S,"POST",()=>P],206731);var A=e.i(206731);let _=new t.AppRouteRouteModule({definition:{kind:r.RouteKind.APP_ROUTE,page:"/api/webhooks/discord/route",pathname:"/api/webhooks/discord",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/webhooks/discord/route.ts",nextConfigOutput:"",userland:A}),{workAsyncStorage:O,workUnitAsyncStorage:k,serverHooks:D}=_;function U(){return(0,n.patchFetch)({workAsyncStorage:O,workUnitAsyncStorage:k})}async function M(e,t,n){_.isDev&&(0,a.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let R="/api/webhooks/discord/route";R=R.replace(/\/index$/,"")||"/";let y=await _.prepare(e,t,{srcPage:R,multiZoneDraftMode:!1});if(!y)return t.statusCode=400,t.end("Bad Request"),null==n.waitUntil||n.waitUntil.call(n,Promise.resolve()),null;let{buildId:v,params:E,nextConfig:x,parsedUrl:C,isDraftMode:I,prerenderManifest:b,routerServerContext:T,isOnDemandRevalidate:N,revalidateOnlyGenerated:P,resolvedPathname:S,clientReferenceManifest:A,serverActionsManifest:O}=y,k=(0,s.normalizeAppPath)(R),D=!!(b.dynamicRoutes[k]||b.routes[S]),U=async()=>((null==T?void 0:T.render404)?await T.render404(e,t,C,!1):t.end("This page could not be found"),null);if(D&&!I){let e=!!b.routes[S],t=b.dynamicRoutes[k];if(t&&!1===t.fallback&&!e){if(x.experimental.adapterPath)return await U();throw new f.NoFallbackError}}let M=null;!D||_.isDev||I||(M="/index"===(M=S)?"/":M);let j=!0===_.isDev||!D,L=D&&!j;O&&A&&(0,i.setManifestsSingleton)({page:R,clientReferenceManifest:A,serverActionsManifest:O});let H=e.method||"GET",$=(0,o.getTracer)(),q=$.getActiveScopeSpan(),B={params:E,prerenderManifest:b,renderOpts:{experimental:{authInterrupts:!!x.experimental.authInterrupts},cacheComponents:!!x.cacheComponents,supportsDynamicResponse:j,incrementalCache:(0,a.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:x.cacheLife,waitUntil:n.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,n,a)=>_.onRequestError(e,t,n,a,T)},sharedContext:{buildId:v}},X=new l.NodeNextRequest(e),K=new l.NodeNextResponse(t),F=d.NextRequestAdapter.fromNodeNextRequest(X,(0,d.signalFromNodeResponse)(t));try{let i=async e=>_.handle(F,B).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let r=$.getRootSpanAttributes();if(!r)return;if(r.get("next.span_type")!==c.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${r.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let n=r.get("next.route");if(n){let t=`${H} ${n}`;e.setAttributes({"next.route":n,"http.route":n,"next.span_name":t}),e.updateName(t)}else e.updateName(`${H} ${R}`)}),s=!!(0,a.getRequestMeta)(e,"minimalMode"),l=async a=>{var o,l;let d=async({previousCacheEntry:r})=>{try{if(!s&&N&&P&&!r)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let o=await i(a);e.fetchMetrics=B.renderOpts.fetchMetrics;let l=B.renderOpts.pendingWaitUntil;l&&n.waitUntil&&(n.waitUntil(l),l=void 0);let d=B.renderOpts.collectedTags;if(!D)return await (0,p.sendResponse)(X,K,o,B.renderOpts.pendingWaitUntil),null;{let e=await o.blob(),t=(0,h.toNodeOutgoingHttpHeaders)(o.headers);d&&(t[m.NEXT_CACHE_TAGS_HEADER]=d),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==B.renderOpts.collectedRevalidate&&!(B.renderOpts.collectedRevalidate>=m.INFINITE_CACHE)&&B.renderOpts.collectedRevalidate,n=void 0===B.renderOpts.collectedExpire||B.renderOpts.collectedExpire>=m.INFINITE_CACHE?void 0:B.renderOpts.collectedExpire;return{value:{kind:w.CachedRouteKind.APP_ROUTE,status:o.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:n}}}}catch(t){throw(null==r?void 0:r.isStale)&&await _.onRequestError(e,t,{routerKind:"App Router",routePath:R,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:L,isOnDemandRevalidate:N})},!1,T),t}},c=await _.handleResponse({req:e,nextConfig:x,cacheKey:M,routeKind:r.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:b,isRoutePPREnabled:!1,isOnDemandRevalidate:N,revalidateOnlyGenerated:P,responseGenerator:d,waitUntil:n.waitUntil,isMinimalMode:s});if(!D)return null;if((null==c||null==(o=c.value)?void 0:o.kind)!==w.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==c||null==(l=c.value)?void 0:l.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});s||t.setHeader("x-nextjs-cache",N?"REVALIDATED":c.isMiss?"MISS":c.isStale?"STALE":"HIT"),I&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let f=(0,h.fromNodeOutgoingHttpHeaders)(c.value.headers);return s&&D||f.delete(m.NEXT_CACHE_TAGS_HEADER),!c.cacheControl||t.getHeader("Cache-Control")||f.get("Cache-Control")||f.set("Cache-Control",(0,g.getCacheControlHeader)(c.cacheControl)),await (0,p.sendResponse)(X,K,new Response(c.value.body,{headers:f,status:c.value.status||200})),null};q?await l(q):await $.withPropagatedContext(e.headers,()=>$.trace(c.BaseServerSpan.handleRequest,{spanName:`${H} ${R}`,kind:o.SpanKind.SERVER,attributes:{"http.method":H,"http.target":e.url}},l))}catch(t){if(t instanceof f.NoFallbackError||await _.onRequestError(e,t,{routerKind:"App Router",routePath:k,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:L,isOnDemandRevalidate:N})},!1,T),D)throw t;return await (0,p.sendResponse)(X,K,new Response(null,{status:500})),null}}e.s(["handler",()=>M,"patchFetch",()=>U,"routeModule",()=>_,"serverHooks",()=>D,"workAsyncStorage",()=>O,"workUnitAsyncStorage",()=>k],122324)}];

//# sourceMappingURL=5d253_next_dist_esm_build_templates_app-route_f2bb38b7.js.map