module.exports=[918622,(e,t,s)=>{t.exports=e.x("next/dist/compiled/next-server/app-page-turbo.runtime.prod.js",()=>require("next/dist/compiled/next-server/app-page-turbo.runtime.prod.js"))},556704,(e,t,s)=>{t.exports=e.x("next/dist/server/app-render/work-async-storage.external.js",()=>require("next/dist/server/app-render/work-async-storage.external.js"))},832319,(e,t,s)=>{t.exports=e.x("next/dist/server/app-render/work-unit-async-storage.external.js",()=>require("next/dist/server/app-render/work-unit-async-storage.external.js"))},324725,(e,t,s)=>{t.exports=e.x("next/dist/server/app-render/after-task-async-storage.external.js",()=>require("next/dist/server/app-render/after-task-async-storage.external.js"))},193695,(e,t,s)=>{t.exports=e.x("next/dist/shared/lib/no-fallback-error.external.js",()=>require("next/dist/shared/lib/no-fallback-error.external.js"))},224361,(e,t,s)=>{t.exports=e.x("util",()=>require("util"))},500874,(e,t,s)=>{t.exports=e.x("buffer",()=>require("buffer"))},254799,(e,t,s)=>{t.exports=e.x("crypto",()=>require("crypto"))},688947,(e,t,s)=>{t.exports=e.x("stream",()=>require("stream"))},427699,(e,t,s)=>{t.exports=e.x("events",()=>require("events"))},488782,e=>{"use strict";class t{constructor(e){}query(e,t){return Promise.resolve(null)}mutation(e,t){return Promise.resolve(null)}}e.s(["ConvexHttpClient",()=>t,"api",0,{jobs:{getAgentJobs:"jobs:getAgentJobs",cancelJob:"jobs:cancelJob",getJob:"jobs:getJob",queueCodeIteration:"jobs:queueCodeIteration",queueSpecialistDelegation:"jobs:queueSpecialistDelegation",queueAgentTask:"jobs:queueAgentTask",updateJobStatusPublic:"jobs:updateJobStatusPublic",logJobEventPublic:"jobs:logJobEventPublic"},aiSettings:{getSettings:"aiSettings:getSettings"},erv:{createEntity:"erv:createEntity",createRelationship:"erv:createRelationship",createDimension:"erv:createDimension",listDimensions:"erv:listDimensions",searchEntities:"erv:searchEntities",getEntity:"erv:getEntity"},jamz:{createProject:"jamz:createProject",createTrack:"jamz:createTrack",createClip:"jamz:createClip"},messages:{send:"messages:send"},whatsappContacts:{list:"whatsappContacts:list",getContactByPhone:"whatsappContacts:getContactByPhone",listContacts:"whatsappContacts:listContacts",upsertContact:"whatsappContacts:upsertContact"},channels:{list:"channels:list",getChannel:"channels:getChannel",sendMessage:"channels:sendMessage",getUserMessages:"channels:getUserMessages",getUserIntegrations:"channels:getUserIntegrations",getConversations:"channels:getConversations",getIntegration:"channels:getIntegration",logOutboundMessage:"channels:logOutboundMessage",searchMessages:"channels:searchMessages"},scheduling:{list:"scheduling:list",createEvent:"scheduling:createEvent",getEventTypes:"scheduling:getEventTypes",getAvailableSlots:"scheduling:getAvailableSlots",createBooking:"scheduling:createBooking",rescheduleBooking:"scheduling:rescheduleBooking",updateBookingStatus:"scheduling:updateBookingStatus"},userCronJobs:{list:"userCronJobs:list",create:"userCronJobs:create",delete:"userCronJobs:delete",createJob:"userCronJobs:createJob",getUserJobs:"userCronJobs:getUserJobs",toggleJob:"userCronJobs:toggleJob",deleteJob:"userCronJobs:deleteJob"},compaction:{compact:"compaction:compact",getLatestCompaction:"compaction:getLatestCompaction"},kanban:{listLists:"kanban:listLists",createCard:"kanban:createCard",moveCard:"kanban:moveCard",getTaskById:"kanban:getTaskById",searchTasks:"kanban:searchTasks",getTasks:"kanban:getTasks",isSeeded:"kanban:isSeeded",addTask:"kanban:addTask",updateTask:"kanban:updateTask",deleteTask:"kanban:deleteTask",moveTask:"kanban:moveTask",seedTasks:"kanban:seedTasks"},designCanvas:{getCanvas:"designCanvas:getCanvas",updateCanvas:"designCanvas:updateCanvas",createItem:"designCanvas:createItem",createCanvas:"designCanvas:createCanvas",getUserCanvases:"designCanvas:getUserCanvases",getCanvasNodes:"designCanvas:getCanvasNodes",getCanvasEdges:"designCanvas:getCanvasEdges",addNode:"designCanvas:addNode",addEdge:"designCanvas:addEdge",updateNode:"designCanvas:updateNode"},agentic:{createProductProject:"agentic:createProductProject",createPRD:"agentic:createPRD",createEpic:"agentic:createEpic",createTicket:"agentic:createTicket"},discovery:{getSession:"discovery:getSession",storeInsights:"discovery:storeInsights",storeArtifacts:"discovery:storeArtifacts",markNotificationSent:"discovery:markNotificationSent",markError:"discovery:markError",getSessionByCallerId:"discovery:getSessionByCallerId",updateTranscript:"discovery:updateTranscript"},memories:{searchEpisodic:"memories:searchEpisodic",getSemanticByCategories:"memories:getSemanticByCategories",getAllSemantic:"memories:getAllSemantic",getRecentEpisodic:"memories:getRecentEpisodic",storeEpisodic:"memories:storeEpisodic",upsertSemantic:"memories:upsertSemantic",deleteEpisodic:"memories:deleteEpisodic",deleteSemantic:"memories:deleteSemantic",getMemoryStats:"memories:getMemoryStats"},observability:{getSecurityScans:"observability:getSecurityScans",createSecurityScan:"observability:createSecurityScan",getActivityStream:"observability:getActivityStream",getDashboardOverview:"observability:getDashboardOverview",getProviderHealthStatus:"observability:getProviderHealthStatus",logOperation:"observability:logOperation"},roadmap:{submitSuggestion:"roadmap:submitSuggestion",getSuggestions:"roadmap:getSuggestions",updateSuggestionStatus:"roadmap:updateSuggestionStatus",voteSuggestion:"roadmap:voteSuggestion"}}])},572067,e=>{"use strict";e.i(39334);let t=async()=>({id:"mock-user-id",firstName:"James",lastName:"Spalding",emailAddresses:[{emailAddress:"james@example.com"}]});e.s(["auth",0,()=>({userId:"mock-user-id",sessionId:"mock-session-id",getToken:async()=>"mock-token",redirectToSignIn:()=>({})}),"clerkClient",0,{users:{getUser:async()=>t()}}])},710429,e=>{"use strict";var t=e.i(254799);let s=null;function r(){return s||(s=function(){let e=process.env.PASSCODE_SECRET;if(!e)throw Error("PASSCODE_SECRET environment variable is required");if(e.length<32)throw Error("PASSCODE_SECRET must be at least 32 characters long");return e}()),s}function a(e,s){let a=t.default.createHmac("sha256",r()).update(e).digest("hex"),n=Buffer.from(a),i=Buffer.from(s);return n.length===i.length&&t.default.timingSafeEqual(n,i)}function n(e){let s=Buffer.from(JSON.stringify(e)).toString("base64url"),a=t.default.createHmac("sha256",r()).update(s).digest("base64url");return`${s}.${a}`}function i(e){if(!e)return null;let s=e.split(".");if(2!==s.length)return null;let[a,n]=s,i=t.default.createHmac("sha256",r()).update(a).digest("base64url"),o=Buffer.from(n),c=Buffer.from(i);if(o.length!==c.length||!t.default.timingSafeEqual(o,c))return null;try{let e=JSON.parse(Buffer.from(a,"base64url").toString());if(Date.now()>e.exp)return null;return e}catch{return null}}function o(e){return n({type:"admin",subject:e,exp:Date.now()+864e5})}function c(e){return n({type:"area",subject:e,exp:Date.now()+6048e5})}function l(e){return n({type:"ipod",subject:e,exp:Date.now()+6048e5})}function u(e){return`jamos_area_${e}`}function g(e){return/^\d{6}$/.test(e)}e.s(["ADMIN_COOKIE",0,"jamos_admin","IPOD_COOKIE",0,"jamos_ipod","createAdminSession",()=>o,"createAreaSession",()=>c,"createiPodSession",()=>l,"getAreaCookieName",()=>u,"isValidPasscodeFormat",()=>g,"verifyPasscode",()=>a,"verifySession",()=>i])},771366,192650,886230,e=>{"use strict";var t=e.i(488782);class s{convex=null;constructor(e){const s=e||process.env.NEXT_PUBLIC_CONVEX_URL;s&&(this.convex=new t.ConvexHttpClient(s))}getClient(){if(!this.convex){let e=process.env.NEXT_PUBLIC_CONVEX_URL;if(!e)throw Error("NEXT_PUBLIC_CONVEX_URL not configured");this.convex=new t.ConvexHttpClient(e)}return this.convex}getApiRef(e){if(t.api){let s=e.split("."),r=t.api;for(let e of s)r&&(r=r[e]);if(r)return r}return e}async loadRelevantMemories(e,t,s={}){let{limit:r=10,includeEpisodic:a=!0,includeSemantic:n=!0,projectId:i}=s,[o,c]=await Promise.all([a?this.searchEpisodicMemories(e,t,i,r):[],n?this.loadSemanticMemories(e,this.extractCategories(t)):[]]),l=this.buildContextSummary(o,c);return{episodic:o,semantic:c,contextSummary:l}}async searchEpisodicMemories(e,t,s,r=10){return await this.getClient().query(this.getApiRef("memories.searchEpisodic"),{userId:e,query:t,projectId:s,limit:r})}async loadSemanticMemories(e,t){return await this.getClient().query(this.getApiRef("memories.getSemanticByCategories"),{userId:e,categories:t})}async getAllSemanticMemories(e){return await this.getClient().query(this.getApiRef("memories.getAllSemantic"),{userId:e})}async getRecentMemories(e,t,s=10){return await this.getClient().query(this.getApiRef("memories.getRecentEpisodic"),{userId:e,projectId:t,limit:s})}async storeEpisodicMemory(e,t,s,r,a,n){return await this.getClient().mutation(this.getApiRef("memories.storeEpisodic"),{userId:e,projectId:a,content:t,memoryType:s,importance:r,metadata:n})}async upsertSemanticMemory(e,t,s,r,a,n){return await this.getClient().mutation(this.getApiRef("memories.upsertSemantic"),{userId:e,category:t,key:s,value:r,confidence:a,source:n})}async processInteraction(e,t,s){let r=this.calculateImportance(t);if(r>.3){let a=this.classifyInteraction(t),n=this.summarizeInteraction(t);await this.storeEpisodicMemory(e,n,a,r,s,{toolsUsed:t.toolsUsed})}for(let s of this.extractPatterns(t))await this.upsertSemanticMemory(e,s.category,s.key,s.value,s.confidence,"interaction_learning")}extractCategories(e){let t=[],s=e.toLowerCase();return/prefer|like|style|theme|mode|favorite/.test(s)&&t.push("preference"),/skill|know|experience|proficient|expert|can you/.test(s)&&t.push("skill"),/pattern|usually|always|tend to|typically/.test(s)&&t.push("pattern"),/fact|is|are|does|what|who|where/.test(s)&&t.push("fact"),t.length>0?t:["preference","skill","pattern"]}buildContextSummary(e,t){let s=[];if(t.length>0){let e=t.sort((e,t)=>t.confidence-e.confidence).slice(0,5).map(e=>`- ${e.category}: ${e.value}`).join("\n");s.push(`User Context:
${e}`)}if(e.length>0){let t=e.sort((e,t)=>t.importance-e.importance).slice(0,3).map(e=>`- [${e.memoryType}] ${e.content}`).join("\n");s.push(`Recent History:
${t}`)}return s.join("\n\n")}calculateImportance(e){let t=.3;return/thanks|perfect|great|exactly|awesome|excellent/i.test(e.userMessage)&&(t+=.2),e.toolsUsed.length>2&&(t+=.15),/decide|choose|prefer|want|let's|go with/i.test(e.userMessage)&&(t+=.2),e.toolsUsed.some(e=>/create|update|delete/.test(e))&&(t+=.15),Math.min(t,1)}classifyInteraction(e){let t=e.userMessage.toLowerCase();return/thanks|great|perfect|awesome|excellent|love it/.test(t)?"feedback":/prefer|like|want|rather|always use|my favorite/.test(t)?"preference":/decide|choose|let's go with|use this|pick/.test(t)?"decision":e.toolsUsed.some(e=>/create_project|create_prd|shard_prd|launch/.test(e))?"milestone":"interaction"}summarizeInteraction(e){let t=e.userMessage.length>100?e.userMessage.slice(0,100)+"...":e.userMessage;return e.toolsUsed.length>0?`User: "${t}" â†’ Tools: ${e.toolsUsed.join(", ")}`:`User: "${t}"`}extractPatterns(e){let t=[],s=e.userMessage.toLowerCase();return/i prefer|i like|i want|my favorite|i always use/.test(s)&&t.push({category:"preference",key:`pref_${Date.now()}`,value:e.userMessage.slice(0,200),confidence:.7}),/i know|i can|experience with|proficient in|expert at/.test(s)&&t.push({category:"skill",key:`skill_${Date.now()}`,value:e.userMessage.slice(0,200),confidence:.6}),/i usually|i always|i tend to|typically i/.test(s)&&t.push({category:"pattern",key:`pattern_${Date.now()}`,value:e.userMessage.slice(0,200),confidence:.5}),t}async deleteEpisodicMemory(e,t){await this.getClient().mutation(this.getApiRef("memories.deleteEpisodic"),{memoryId:e,userId:t})}async deleteSemanticMemory(e,t){await this.getClient().mutation(this.getApiRef("memories.deleteSemantic"),{memoryId:e,userId:t})}async getStats(e){return await this.getClient().query(this.getApiRef("memories.getMemoryStats"),{userId:e})}}let r=null;function a(){return r||(r=new s),r}e.s(["MemoryManager",()=>s,"getMemoryManager",()=>a],192650);let n=`You are a memory extraction AI for a personal knowledge system. Your job is to analyze text and extract two types of memories:

## EPISODIC MEMORIES (Events/Interactions)
These are specific events, decisions, conversations, or milestones. Each should have:
- content: A clear, standalone summary of what happened (50-200 chars)
- memoryType: One of "interaction", "decision", "preference", "feedback", "milestone"
- importance: 0.0-1.0 (higher = more significant)

Memory type guidelines:
- "interaction": General conversations or exchanges
- "decision": Choices made, directions taken, options selected
- "preference": Expressed likes, dislikes, preferences for how things should be
- "feedback": Reactions to work, opinions given, reviews
- "milestone": Achievements, completions, launches, significant events

## SEMANTIC MEMORIES (Facts/Knowledge)
These are learned facts, preferences, patterns, and skills. Each should have:
- category: One of "preference", "skill", "pattern", "fact"
- key: A unique snake_case identifier (e.g., "preferred_coding_language", "communication_style")
- value: The actual knowledge/fact (clear, specific)
- confidence: 0.0-1.0 (how certain is this information)

Category guidelines:
- "preference": Likes, dislikes, preferred ways of doing things
- "skill": Abilities, expertise, proficiency levels
- "pattern": Behavioral patterns, habits, tendencies
- "fact": Objective facts about the person (location, job, etc.)

## RULES
1. Extract MEANINGFUL memories only - skip trivial/obvious content
2. Be specific and actionable in your extractions
3. Deduplicate - don't extract the same fact multiple times
4. For semantic memories, use consistent key naming (snake_case, descriptive)
5. Higher importance/confidence for explicitly stated things vs inferred
6. Include context when it adds value

Respond with valid JSON only, no markdown formatting.`;async function i(e,t){let s=process.env.OPENAI_API_KEY;if(!s)throw Error("OPENAI_API_KEY not configured");let r=await fetch("https://api.openai.com/v1/chat/completions",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${s}`},body:JSON.stringify({model:"gpt-4o",max_tokens:4096,response_format:{type:"json_object"},messages:[{role:"system",content:e},{role:"user",content:t}]})});if(!r.ok){let e=await r.text();throw Error(`OpenAI API error: ${r.status} - ${e}`)}let a=await r.json();return a.choices?.[0]?.message?.content||""}async function o(e,t,s={}){let{maxEpisodic:r=50,maxSemantic:a=30}=s,c=e.length>5e4?e.slice(0,5e4)+"\n\n[Content truncated...]":e,l=`Analyze the following content from file "${t}" and extract memories.

<content>
${c}
</content>

Extract up to ${r} episodic memories and ${a} semantic memories.

Respond with this exact JSON structure:
{
  "episodicMemories": [
    {
      "content": "string",
      "memoryType": "interaction|decision|preference|feedback|milestone",
      "importance": 0.0-1.0,
      "context": "optional string"
    }
  ],
  "semanticMemories": [
    {
      "category": "preference|skill|pattern|fact",
      "key": "snake_case_key",
      "value": "string",
      "confidence": 0.0-1.0,
      "source": "optional string"
    }
  ],
  "summary": "Brief summary of what was extracted",
  "processingNotes": ["Any notes about the extraction process"]
}`;try{var u,g;let e,s,r=await i(n,l);if(!r)throw Error("No response from AI");return u=JSON.parse(r),g=t,e=["interaction","decision","preference","feedback","milestone"],s=["preference","skill","pattern","fact"],{episodicMemories:(u.episodicMemories||[]).filter(e=>e&&"string"==typeof e.content&&e.content.length>10).map(t=>({content:t.content.slice(0,500),memoryType:e.includes(t.memoryType)?t.memoryType:"interaction",importance:Math.max(0,Math.min(1,Number(t.importance)||.5)),context:t.context?String(t.context).slice(0,200):void 0})),semanticMemories:(u.semanticMemories||[]).filter(e=>e&&"string"==typeof e.key&&e.key.length>0&&"string"==typeof e.value&&e.value.length>0).map(e=>({category:s.includes(e.category)?e.category:"fact",key:e.key.toLowerCase().replace(/[^a-z0-9_]/g,"_").slice(0,50),value:e.value.slice(0,500),confidence:Math.max(0,Math.min(1,Number(e.confidence)||.5)),source:e.source?String(e.source).slice(0,100):`Extracted from ${g}`})),summary:u.summary||`Processed ${g}`,processingNotes:Array.isArray(u.processingNotes)?u.processingNotes.map(e=>String(e)):[]}}catch(e){return console.error("AI ingestion error:",e),{episodicMemories:[],semanticMemories:[],summary:`Failed to process ${t}`,processingNotes:[`Error: ${e instanceof Error?e.message:"Unknown error"}`]}}}async function c(e,t,s=3e4){if(e.length<=s)return o(e,t);let r=[],a="";for(let t of e.split(/\n\n+/))a.length+t.length>s?(a&&r.push(a),a=t):a+=(a?"\n\n":"")+t;a&&r.push(a);let n=[];for(let e=0;e<r.length;e++){let s=`${t} (part ${e+1}/${r.length})`,a=await o(r[e],s);n.push(a)}return function(e,t){let s=[],r=[],a=[];for(let t of e)s.push(...t.episodicMemories),r.push(...t.semanticMemories),a.push(...t.processingNotes);let n=new Map;for(let e of r){let t=n.get(e.key);(!t||e.confidence>t.confidence)&&n.set(e.key,e)}return{episodicMemories:s,semanticMemories:Array.from(n.values()),summary:`Processed ${t} in ${e.length} chunks`,processingNotes:a}}(n,t)}e.s(["processLargeContent",()=>c],886230),e.s([],771366)}];

//# sourceMappingURL=%5Broot-of-the-server%5D__2f97128c._.js.map