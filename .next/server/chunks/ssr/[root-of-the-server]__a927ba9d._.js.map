{"version":3,"sources":["../../../../src/app/wiki/%5B%5B...slug%5D%5D/WikiPageClient.tsx/__nextjs-internal-proxy.mjs","../../../../src/app/wiki/%5B%5B...slug%5D%5D/page.tsx","../../../../src/lib/docs/index.ts"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/wiki/[[...slug]]/WikiPageClient.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/wiki/[[...slug]]/WikiPageClient.tsx\",\n    \"default\",\n);\n","import { notFound } from 'next/navigation';\nimport { getDocsTree, getDocByPath, getBreadcrumbs, type DocNode } from '@/lib/docs';\nimport WikiPageClient from './WikiPageClient';\n\ninterface WikiPageProps {\n  params: Promise<{ slug?: string[] }>;\n}\n\nexport default async function WikiPage({ params }: WikiPageProps) {\n  const { slug } = await params;\n  // Root wiki page uses 'index' (which maps to README.md)\n  const docPath = slug?.join('/') || 'index';\n\n  // Get docs tree for sidebar\n  const { nodes: tree } = getDocsTree();\n\n  // Get the specific doc\n  let doc = getDocByPath(docPath);\n\n  // If no specific doc found and this is the root, try 'index'\n  if (!doc && (!slug || slug.length === 0)) {\n    doc = getDocByPath('index');\n  }\n\n  if (!doc) {\n    notFound();\n  }\n\n  // Get breadcrumbs\n  const breadcrumbs = getBreadcrumbs(docPath);\n\n  return (\n    <WikiPageClient\n      doc={doc}\n      tree={tree}\n      breadcrumbs={breadcrumbs}\n    />\n  );\n}\n\n// Generate static paths for all docs\nexport async function generateStaticParams() {\n  const { flatList } = getDocsTree();\n\n  return [\n    { slug: [] }, // Root /wiki\n    ...flatList.map(doc => ({\n      slug: doc.path.split('/').filter(Boolean),\n    })),\n  ];\n}\n\nexport const dynamicParams = true;\n","/**\n * Docs Library\n *\n * Parses the /docs folder structure into navigable documentation.\n * Notion-inspired: clean, typography-first, effortlessly navigable.\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport matter from 'gray-matter';\n\nexport interface DocMeta {\n  title: string;\n  description?: string;\n  order?: number;\n  icon?: string;\n}\n\nexport interface DocNode {\n  slug: string;\n  path: string;\n  title: string;\n  description?: string;\n  icon?: string;\n  type: 'file' | 'folder';\n  children?: DocNode[];\n  content?: string;\n  headings?: Array<{ level: number; text: string; slug: string }>;\n}\n\nexport interface DocsTree {\n  nodes: DocNode[];\n  flatList: DocNode[];\n}\n\nconst DOCS_PATH = path.join(process.cwd(), 'docs');\n\n// Icons for folder categories\nconst FOLDER_ICONS: Record<string, string> = {\n  'philosophy': 'compass',\n  'getting-started': 'rocket',\n  'architecture': 'cpu',\n  'features': 'sparkles',\n  'completed': 'check-circle',\n  'roadmap': 'map',\n  'reference': 'book-open',\n  'planning': 'calendar',\n  'personal': 'user',\n  'claw-ai': 'bot',\n  'apps': 'grid-3x3',\n  'design-system': 'palette',\n  'integrations': 'plug',\n};\n\n// Pretty names for folders\nconst FOLDER_NAMES: Record<string, string> = {\n  'philosophy': 'Philosophy',\n  'getting-started': 'Getting Started',\n  'architecture': 'Architecture',\n  'features': 'Features',\n  'completed': 'Completed',\n  'roadmap': 'Roadmap',\n  'reference': 'Reference',\n  'planning': 'Planning',\n  'personal': 'Personal',\n  'claw-ai': '8gent',\n  'apps': 'Apps',\n  'design-system': 'Design System',\n  'integrations': 'Integrations',\n  'images': 'Images',\n};\n\n/**\n * Convert filename to title\n */\nfunction fileNameToTitle(fileName: string): string {\n  return fileName\n    .replace(/\\.md$/, '')\n    .replace(/^README$/i, 'Overview')\n    .replace(/^PRD[-_]/i, '')\n    .replace(/[-_]/g, ' ')\n    .replace(/\\b\\w/g, (c) => c.toUpperCase())\n    .replace(/\\bPrd\\b/g, 'PRD')\n    .replace(/\\bApi\\b/g, 'API')\n    .replace(/\\bAi\\b/g, 'AI')\n    .replace(/\\bRag\\b/g, 'RAG')\n    .replace(/\\bUi\\b/g, 'UI')\n    .replace(/\\bUx\\b/g, 'UX');\n}\n\n/**\n * Extract headings from markdown content\n */\nfunction extractHeadings(content: string): Array<{ level: number; text: string; slug: string }> {\n  const headingRegex = /^(#{1,6})\\s+(.+)$/gm;\n  const headings: Array<{ level: number; text: string; slug: string }> = [];\n  let match;\n\n  while ((match = headingRegex.exec(content)) !== null) {\n    const level = match[1].length;\n    const text = match[2].trim();\n    const slug = text\n      .toLowerCase()\n      .replace(/[^\\w\\s-]/g, '')\n      .replace(/\\s+/g, '-');\n    headings.push({ level, text, slug });\n  }\n\n  return headings;\n}\n\n/**\n * Read a single markdown file\n */\nfunction readMarkdownFile(filePath: string): { content: string; meta: DocMeta; headings: Array<{ level: number; text: string; slug: string }> } | null {\n  try {\n    const fileContent = fs.readFileSync(filePath, 'utf-8');\n    const { data, content } = matter(fileContent);\n    const headings = extractHeadings(content);\n\n    // Extract title from first h1 if not in frontmatter\n    let title = data.title;\n    if (!title) {\n      const h1Match = content.match(/^#\\s+(.+)$/m);\n      title = h1Match ? h1Match[1] : fileNameToTitle(path.basename(filePath));\n    }\n\n    return {\n      content,\n      meta: {\n        title,\n        description: data.description,\n        order: data.order,\n        icon: data.icon,\n      },\n      headings,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Recursively build docs tree from filesystem\n */\nfunction buildDocsTree(dirPath: string, basePath: string = ''): DocNode[] {\n  const nodes: DocNode[] = [];\n\n  try {\n    const entries = fs.readdirSync(dirPath, { withFileTypes: true });\n\n    // Sort: folders first, then files, READMEs first\n    const sortedEntries = entries.sort((a, b) => {\n      if (a.isDirectory() && !b.isDirectory()) return -1;\n      if (!a.isDirectory() && b.isDirectory()) return 1;\n      if (a.name.toLowerCase() === 'readme.md') return -1;\n      if (b.name.toLowerCase() === 'readme.md') return 1;\n      return a.name.localeCompare(b.name);\n    });\n\n    for (const entry of sortedEntries) {\n      const entryPath = path.join(dirPath, entry.name);\n      const relativePath = path.join(basePath, entry.name);\n\n      // Skip non-markdown files (except folders)\n      if (!entry.isDirectory() && !entry.name.endsWith('.md')) continue;\n\n      // Skip hidden files and archive folder\n      if (entry.name.startsWith('.')) continue;\n      if (entry.name === 'archive') continue;\n\n      if (entry.isDirectory()) {\n        const children = buildDocsTree(entryPath, relativePath);\n\n        // Only include folders that have content\n        if (children.length > 0) {\n          const folderName = entry.name.toLowerCase();\n          nodes.push({\n            slug: entry.name,\n            path: relativePath,\n            title: FOLDER_NAMES[folderName] || fileNameToTitle(entry.name),\n            icon: FOLDER_ICONS[folderName],\n            type: 'folder',\n            children,\n          });\n        }\n      } else {\n        const fileData = readMarkdownFile(entryPath);\n        if (fileData) {\n          const slug = entry.name.replace(/\\.md$/, '');\n          const isReadme = slug.toLowerCase() === 'readme';\n\n          nodes.push({\n            slug: isReadme ? 'index' : slug,\n            path: relativePath.replace(/\\.md$/, ''),\n            title: fileData.meta.title,\n            description: fileData.meta.description,\n            icon: fileData.meta.icon,\n            type: 'file',\n            content: fileData.content,\n            headings: fileData.headings,\n          });\n        }\n      }\n    }\n  } catch {\n    // Directory doesn't exist or can't be read\n  }\n\n  return nodes;\n}\n\n/**\n * Flatten the tree for search and navigation\n */\nfunction flattenTree(nodes: DocNode[], parentPath: string = ''): DocNode[] {\n  const flat: DocNode[] = [];\n\n  for (const node of nodes) {\n    if (node.type === 'file') {\n      flat.push({\n        ...node,\n        path: parentPath ? `${parentPath}/${node.slug}` : node.slug,\n      });\n    }\n    if (node.children) {\n      const childPath = parentPath ? `${parentPath}/${node.slug}` : node.slug;\n      flat.push(...flattenTree(node.children, childPath));\n    }\n  }\n\n  return flat;\n}\n\n/**\n * Get the full docs tree\n */\nexport function getDocsTree(): DocsTree {\n  const nodes = buildDocsTree(DOCS_PATH);\n  const flatList = flattenTree(nodes);\n  return { nodes, flatList };\n}\n\n/**\n * Get a single doc by path\n */\nexport function getDocByPath(docPath: string): DocNode | null {\n  const { flatList } = getDocsTree();\n\n  // Normalize path\n  const normalizedPath = docPath\n    .replace(/^\\//, '')\n    .replace(/\\/$/, '')\n    .replace(/\\/index$/, '');\n\n  // Try exact match first\n  let doc = flatList.find(d => d.path === normalizedPath || d.path === `${normalizedPath}/index`);\n\n  // Try with README\n  if (!doc) {\n    doc = flatList.find(d => d.path === `${normalizedPath}/README` || d.slug === normalizedPath);\n  }\n\n  return doc || null;\n}\n\n/**\n * Get all doc paths for static generation\n */\nexport function getAllDocPaths(): string[] {\n  const { flatList } = getDocsTree();\n  return flatList.map(doc => doc.path);\n}\n\n/**\n * Search docs by query\n */\nexport function searchDocs(query: string): DocNode[] {\n  if (!query.trim()) return [];\n\n  const { flatList } = getDocsTree();\n  const lowerQuery = query.toLowerCase();\n\n  return flatList.filter(doc => {\n    const titleMatch = doc.title.toLowerCase().includes(lowerQuery);\n    const contentMatch = doc.content?.toLowerCase().includes(lowerQuery);\n    const descMatch = doc.description?.toLowerCase().includes(lowerQuery);\n    return titleMatch || contentMatch || descMatch;\n  }).slice(0, 10); // Limit results\n}\n\n/**\n * Get breadcrumbs for a doc path\n */\nexport function getBreadcrumbs(docPath: string): Array<{ title: string; path: string }> {\n  const parts = docPath.split('/').filter(Boolean);\n  const breadcrumbs: Array<{ title: string; path: string }> = [\n    { title: 'Docs', path: '/wiki' },\n  ];\n\n  let currentPath = '';\n  for (const part of parts) {\n    currentPath += `/${part}`;\n    const folderName = FOLDER_NAMES[part.toLowerCase()] || fileNameToTitle(part);\n    breadcrumbs.push({\n      title: folderName,\n      path: `/wiki${currentPath}`,\n    });\n  }\n\n  return breadcrumbs;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}