{"version":3,"sources":["../../../../src/lib/scheduling/types.ts","../../../../src/lib/scheduling/utils.ts","../../../../src/hooks/useReducedMotion.ts","../../../../src/hooks/index.ts","../../../../src/hooks/useScheduling.ts","../../../../src/hooks/useHorizontalScroll.ts"],"sourcesContent":["/**\n * Scheduling Types - TypeScript definitions for the Calendly clone\n */\n\nexport type LocationType = \"google_meet\" | \"zoom\" | \"phone\" | \"in_person\" | \"custom\";\n\nexport type BookingStatus =\n  | \"pending\"\n  | \"confirmed\"\n  | \"cancelled\"\n  | \"rescheduled\"\n  | \"completed\"\n  | \"no_show\";\n\nexport interface TimeSlot {\n  start: string; // \"HH:mm\" format\n  end: string;\n}\n\nexport interface DaySchedule {\n  dayOfWeek: number; // 0-6 (Sunday-Saturday)\n  isAvailable: boolean;\n  slots: TimeSlot[];\n}\n\nexport interface Question {\n  id: string;\n  label: string;\n  type: \"text\" | \"textarea\" | \"select\";\n  required: boolean;\n  options?: string[];\n}\n\nexport interface QuestionResponse {\n  questionId: string;\n  questionLabel: string;\n  answer: string;\n}\n\nexport interface EventType {\n  _id: string;\n  ownerId: string;\n  title: string;\n  slug: string;\n  description?: string;\n  duration: number;\n  color: string;\n  isActive: boolean;\n  bufferBefore: number;\n  bufferAfter: number;\n  maxBookingsPerDay?: number;\n  minNotice: number;\n  maxAdvance: number;\n  locationType: LocationType;\n  locationValue?: string;\n  questions: Question[];\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface Availability {\n  _id: string;\n  ownerId: string;\n  name: string;\n  isDefault: boolean;\n  timezone: string;\n  schedule: DaySchedule[];\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface AvailabilityOverride {\n  _id: string;\n  ownerId: string;\n  date: string;\n  isBlocked: boolean;\n  slots?: TimeSlot[];\n  reason?: string;\n}\n\nexport interface Booking {\n  _id: string;\n  eventTypeId: string;\n  hostId: string;\n  guestEmail: string;\n  guestName: string;\n  guestTimezone: string;\n  startTime: number;\n  endTime: number;\n  status: BookingStatus;\n  title: string;\n  location?: string;\n  locationType: string;\n  notes?: string;\n  responses?: QuestionResponse[];\n  googleEventId?: string;\n  cancelledAt?: number;\n  cancelReason?: string;\n  cancelledBy?: \"host\" | \"guest\";\n  rescheduledFrom?: string;\n  rescheduledTo?: string;\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface CalendarIntegration {\n  _id: string;\n  ownerId: string;\n  provider: \"google\";\n  accessToken: string;\n  refreshToken: string;\n  tokenExpiry: number;\n  calendarId: string;\n  calendarEmail: string;\n  syncEnabled: boolean;\n  blockExternalEvents: boolean;\n  lastSyncAt?: number;\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface AvailableSlot {\n  time: string; // \"HH:mm\" format\n  timestamp: number;\n}\n\nexport interface GoogleCalendarEvent {\n  id?: string;\n  summary: string;\n  description?: string;\n  start: {\n    dateTime: string;\n    timeZone: string;\n  };\n  end: {\n    dateTime: string;\n    timeZone: string;\n  };\n  attendees?: Array<{\n    email: string;\n    displayName?: string;\n    responseStatus?: string;\n  }>;\n  conferenceData?: {\n    createRequest?: {\n      requestId: string;\n      conferenceSolutionKey: {\n        type: string;\n      };\n    };\n    entryPoints?: Array<{\n      entryPointType: string;\n      uri: string;\n      label?: string;\n    }>;\n  };\n  reminders?: {\n    useDefault: boolean;\n    overrides?: Array<{\n      method: string;\n      minutes: number;\n    }>;\n  };\n}\n\nexport interface GoogleTokenResponse {\n  access_token: string;\n  refresh_token?: string;\n  expires_in: number;\n  token_type: string;\n  scope: string;\n}\n\nexport interface GoogleCalendarListResponse {\n  items: Array<{\n    id: string;\n    summary: string;\n    primary?: boolean;\n    accessRole: string;\n  }>;\n}\n\nexport interface GoogleFreeBusyResponse {\n  calendars: {\n    [calendarId: string]: {\n      busy: Array<{\n        start: string;\n        end: string;\n      }>;\n    };\n  };\n}\n\n// Form types for UI\nexport interface BookingFormData {\n  guestName: string;\n  guestEmail: string;\n  guestTimezone: string;\n  notes?: string;\n  responses?: QuestionResponse[];\n}\n\nexport interface EventTypeFormData {\n  title: string;\n  description?: string;\n  duration: number;\n  color: string;\n  locationType: LocationType;\n  locationValue?: string;\n  bufferBefore?: number;\n  bufferAfter?: number;\n  minNotice?: number;\n  maxAdvance?: number;\n  questions?: Question[];\n}\n\n// Calendar view types\nexport type CalendarView = \"month\" | \"week\" | \"day\" | \"list\";\n\nexport interface CalendarDay {\n  date: Date;\n  isCurrentMonth: boolean;\n  isToday: boolean;\n  bookings: Booking[];\n}\n\n// Duration options\nexport const DURATION_OPTIONS = [\n  { value: 15, label: \"15 minutes\" },\n  { value: 30, label: \"30 minutes\" },\n  { value: 45, label: \"45 minutes\" },\n  { value: 60, label: \"1 hour\" },\n  { value: 90, label: \"1.5 hours\" },\n  { value: 120, label: \"2 hours\" },\n] as const;\n\n// Color options for event types\nexport const EVENT_COLORS = [\n  { value: \"#3b82f6\", label: \"Blue\" },\n  { value: \"#10b981\", label: \"Green\" },\n  { value: \"#f59e0b\", label: \"Yellow\" },\n  { value: \"#ef4444\", label: \"Red\" },\n  { value: \"#8b5cf6\", label: \"Purple\" },\n  { value: \"#ec4899\", label: \"Pink\" },\n  { value: \"#06b6d4\", label: \"Cyan\" },\n  { value: \"#f97316\", label: \"Orange\" },\n] as const;\n\n// Day names\nexport const DAY_NAMES = [\n  \"Sunday\",\n  \"Monday\",\n  \"Tuesday\",\n  \"Wednesday\",\n  \"Thursday\",\n  \"Friday\",\n  \"Saturday\",\n] as const;\n\nexport const DAY_NAMES_SHORT = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"] as const;\n","/**\n * Scheduling Utilities\n *\n * Helper functions for date/time handling and formatting.\n */\n\nimport { DAY_NAMES, DAY_NAMES_SHORT, type DaySchedule, type TimeSlot } from \"./types\";\n\n// Re-export constants for convenience\nexport { DAY_NAMES, DAY_NAMES_SHORT };\n\n/**\n * Format a date to \"YYYY-MM-DD\" string\n */\nexport function formatDateString(date: Date): string {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const day = String(date.getDate()).padStart(2, \"0\");\n  return `${year}-${month}-${day}`;\n}\n\n/**\n * Parse \"YYYY-MM-DD\" string to Date\n */\nexport function parseDateString(dateString: string): Date {\n  const [year, month, day] = dateString.split(\"-\").map(Number);\n  return new Date(year, month - 1, day);\n}\n\n/**\n * Format time string from minutes\n */\nexport function formatTimeFromMinutes(minutes: number): string {\n  const hours = Math.floor(minutes / 60);\n  const mins = minutes % 60;\n  return `${hours.toString().padStart(2, \"0\")}:${mins.toString().padStart(2, \"0\")}`;\n}\n\n/**\n * Parse \"HH:mm\" string to minutes from midnight\n */\nexport function parseTimeToMinutes(time: string): number {\n  const [hours, minutes] = time.split(\":\").map(Number);\n  return hours * 60 + minutes;\n}\n\n/**\n * Format timestamp to human-readable date\n */\nexport function formatDate(timestamp: number, options?: Intl.DateTimeFormatOptions): string {\n  return new Date(timestamp).toLocaleDateString(\"en-US\", {\n    weekday: \"long\",\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\",\n    ...options,\n  });\n}\n\n/**\n * Format timestamp to human-readable time\n */\nexport function formatTime(timestamp: number, timezone?: string): string {\n  return new Date(timestamp).toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n    ...(timezone && { timeZone: timezone }),\n  });\n}\n\n/**\n * Format timestamp to human-readable date and time\n */\nexport function formatDateTime(timestamp: number, timezone?: string): string {\n  return new Date(timestamp).toLocaleString(\"en-US\", {\n    weekday: \"short\",\n    month: \"short\",\n    day: \"numeric\",\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n    ...(timezone && { timeZone: timezone }),\n  });\n}\n\n/**\n * Format duration in minutes to human-readable string\n */\nexport function formatDuration(minutes: number): string {\n  if (minutes < 60) {\n    return `${minutes} min`;\n  }\n  const hours = Math.floor(minutes / 60);\n  const mins = minutes % 60;\n  if (mins === 0) {\n    return hours === 1 ? \"1 hour\" : `${hours} hours`;\n  }\n  return `${hours}h ${mins}m`;\n}\n\n/**\n * Get relative time string (e.g., \"in 2 hours\", \"tomorrow\")\n */\nexport function getRelativeTime(timestamp: number): string {\n  const now = Date.now();\n  const diff = timestamp - now;\n\n  const minutes = Math.floor(diff / 60000);\n  const hours = Math.floor(diff / 3600000);\n  const days = Math.floor(diff / 86400000);\n\n  if (diff < 0) {\n    return \"Past\";\n  }\n\n  if (minutes < 60) {\n    return `in ${minutes} min`;\n  }\n\n  if (hours < 24) {\n    return `in ${hours} hour${hours === 1 ? \"\" : \"s\"}`;\n  }\n\n  if (days === 1) {\n    return \"Tomorrow\";\n  }\n\n  if (days < 7) {\n    return `in ${days} days`;\n  }\n\n  return formatDate(timestamp, { weekday: undefined, year: undefined });\n}\n\n/**\n * Get user's timezone\n */\nexport function getUserTimezone(): string {\n  return Intl.DateTimeFormat().resolvedOptions().timeZone;\n}\n\n/**\n * Format timezone for display\n */\nexport function formatTimezone(timezone: string): string {\n  try {\n    const now = new Date();\n    const formatter = new Intl.DateTimeFormat(\"en-US\", {\n      timeZone: timezone,\n      timeZoneName: \"short\",\n    });\n    const parts = formatter.formatToParts(now);\n    const tzPart = parts.find((p) => p.type === \"timeZoneName\");\n    return tzPart ? `${timezone} (${tzPart.value})` : timezone;\n  } catch {\n    return timezone;\n  }\n}\n\n/**\n * Get day name from day of week number\n */\nexport function getDayName(dayOfWeek: number, short = false): string {\n  return short ? DAY_NAMES_SHORT[dayOfWeek] : DAY_NAMES[dayOfWeek];\n}\n\n/**\n * Generate dates for a calendar month view\n */\nexport function getCalendarDates(year: number, month: number): Date[] {\n  const firstDay = new Date(year, month, 1);\n  const lastDay = new Date(year, month + 1, 0);\n\n  // Start from the Sunday of the first week\n  const startDate = new Date(firstDay);\n  startDate.setDate(startDate.getDate() - firstDay.getDay());\n\n  // End at the Saturday of the last week\n  const endDate = new Date(lastDay);\n  endDate.setDate(endDate.getDate() + (6 - lastDay.getDay()));\n\n  const dates: Date[] = [];\n  const current = new Date(startDate);\n\n  while (current <= endDate) {\n    dates.push(new Date(current));\n    current.setDate(current.getDate() + 1);\n  }\n\n  return dates;\n}\n\n/**\n * Generate dates for a week view\n */\nexport function getWeekDates(date: Date): Date[] {\n  const startOfWeek = new Date(date);\n  startOfWeek.setDate(date.getDate() - date.getDay());\n\n  const dates: Date[] = [];\n  for (let i = 0; i < 7; i++) {\n    const d = new Date(startOfWeek);\n    d.setDate(startOfWeek.getDate() + i);\n    dates.push(d);\n  }\n\n  return dates;\n}\n\n/**\n * Check if two dates are the same day\n */\nexport function isSameDay(date1: Date, date2: Date): boolean {\n  return (\n    date1.getFullYear() === date2.getFullYear() &&\n    date1.getMonth() === date2.getMonth() &&\n    date1.getDate() === date2.getDate()\n  );\n}\n\n/**\n * Check if a date is today\n */\nexport function isToday(date: Date): boolean {\n  return isSameDay(date, new Date());\n}\n\n/**\n * Check if a date is in the past\n */\nexport function isPast(date: Date): boolean {\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  return date < today;\n}\n\n/**\n * Get start and end of day timestamps\n */\nexport function getDayBounds(date: Date): { start: number; end: number } {\n  const start = new Date(date);\n  start.setHours(0, 0, 0, 0);\n\n  const end = new Date(date);\n  end.setHours(23, 59, 59, 999);\n\n  return { start: start.getTime(), end: end.getTime() };\n}\n\n/**\n * Create default availability schedule (9-5 weekdays)\n */\nexport function createDefaultSchedule(): DaySchedule[] {\n  return [\n    { dayOfWeek: 0, isAvailable: false, slots: [] },\n    { dayOfWeek: 1, isAvailable: true, slots: [{ start: \"09:00\", end: \"17:00\" }] },\n    { dayOfWeek: 2, isAvailable: true, slots: [{ start: \"09:00\", end: \"17:00\" }] },\n    { dayOfWeek: 3, isAvailable: true, slots: [{ start: \"09:00\", end: \"17:00\" }] },\n    { dayOfWeek: 4, isAvailable: true, slots: [{ start: \"09:00\", end: \"17:00\" }] },\n    { dayOfWeek: 5, isAvailable: true, slots: [{ start: \"09:00\", end: \"17:00\" }] },\n    { dayOfWeek: 6, isAvailable: false, slots: [] },\n  ];\n}\n\n/**\n * Merge overlapping time slots\n */\nexport function mergeTimeSlots(slots: TimeSlot[]): TimeSlot[] {\n  if (slots.length === 0) return [];\n\n  // Sort by start time\n  const sorted = [...slots].sort((a, b) =>\n    parseTimeToMinutes(a.start) - parseTimeToMinutes(b.start)\n  );\n\n  const merged: TimeSlot[] = [sorted[0]];\n\n  for (let i = 1; i < sorted.length; i++) {\n    const current = sorted[i];\n    const last = merged[merged.length - 1];\n\n    const lastEnd = parseTimeToMinutes(last.end);\n    const currentStart = parseTimeToMinutes(current.start);\n\n    if (currentStart <= lastEnd) {\n      // Overlapping, merge\n      const currentEnd = parseTimeToMinutes(current.end);\n      if (currentEnd > lastEnd) {\n        last.end = current.end;\n      }\n    } else {\n      // No overlap, add new slot\n      merged.push(current);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * Generate time slot options for select inputs\n */\nexport function generateTimeOptions(\n  startHour = 0,\n  endHour = 24,\n  intervalMinutes = 30\n): Array<{ value: string; label: string }> {\n  const options: Array<{ value: string; label: string }> = [];\n\n  for (let minutes = startHour * 60; minutes < endHour * 60; minutes += intervalMinutes) {\n    const time = formatTimeFromMinutes(minutes);\n    const label = formatTime(new Date().setHours(0, minutes, 0, 0));\n    options.push({ value: time, label });\n  }\n\n  return options;\n}\n\n/**\n * Convert timestamp to timezone-aware Date\n */\nexport function toTimezone(timestamp: number, timezone: string): Date {\n  const date = new Date(timestamp);\n  const options: Intl.DateTimeFormatOptions = {\n    timeZone: timezone,\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: false,\n  };\n\n  const parts = new Intl.DateTimeFormat(\"en-CA\", options).formatToParts(date);\n  const get = (type: string) => parts.find((p) => p.type === type)?.value || \"0\";\n\n  return new Date(\n    parseInt(get(\"year\")),\n    parseInt(get(\"month\")) - 1,\n    parseInt(get(\"day\")),\n    parseInt(get(\"hour\")),\n    parseInt(get(\"minute\")),\n    parseInt(get(\"second\"))\n  );\n}\n\n/**\n * Get booking link URL\n */\nexport function getBookingLink(username: string, eventSlug: string): string {\n  if (typeof window !== \"undefined\") {\n    return `${window.location.origin}/book/${username}/${eventSlug}`;\n  }\n  return `/book/${username}/${eventSlug}`;\n}\n\n/**\n * Copy text to clipboard\n */\nexport async function copyToClipboard(text: string): Promise<boolean> {\n  try {\n    await navigator.clipboard.writeText(text);\n    return true;\n  } catch {\n    // Fallback for older browsers\n    const textarea = document.createElement(\"textarea\");\n    textarea.value = text;\n    textarea.style.position = \"fixed\";\n    textarea.style.opacity = \"0\";\n    document.body.appendChild(textarea);\n    textarea.select();\n    try {\n      document.execCommand(\"copy\");\n      return true;\n    } catch {\n      return false;\n    } finally {\n      document.body.removeChild(textarea);\n    }\n  }\n}\n\n/**\n * Validate email format\n */\nexport function isValidEmail(email: string): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\n/**\n * Generate a unique ID\n */\nexport function generateId(): string {\n  return Math.random().toString(36).substring(2, 11) + Date.now().toString(36);\n}\n","'use client';\n\nimport { useState, useEffect } from 'react';\n\n/**\n * Hook to detect user's prefers-reduced-motion preference\n *\n * @returns boolean - true if user prefers reduced motion\n *\n * @example\n * ```tsx\n * const prefersReducedMotion = useReducedMotion();\n *\n * <motion.div\n *   animate={{ opacity: 1, y: 0 }}\n *   transition={prefersReducedMotion ? { duration: 0 } : { duration: 0.3 }}\n * />\n * ```\n */\nexport function useReducedMotion(): boolean {\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n\n  useEffect(() => {\n    // Check if window is available (SSR safety)\n    if (typeof window === 'undefined') return;\n\n    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n\n    // Set initial value\n    setPrefersReducedMotion(mediaQuery.matches);\n\n    // Listen for changes\n    const handleChange = (event: MediaQueryListEvent) => {\n      setPrefersReducedMotion(event.matches);\n    };\n\n    mediaQuery.addEventListener('change', handleChange);\n\n    return () => {\n      mediaQuery.removeEventListener('change', handleChange);\n    };\n  }, []);\n\n  return prefersReducedMotion;\n}\n\n/**\n * Get motion-safe animation props for Framer Motion\n * Returns empty transition when reduced motion is preferred\n *\n * @example\n * ```tsx\n * const motionProps = useMotionSafe({\n *   initial: { opacity: 0, y: 20 },\n *   animate: { opacity: 1, y: 0 },\n *   transition: { duration: 0.3 }\n * });\n *\n * <motion.div {...motionProps} />\n * ```\n */\nexport function useMotionSafe<T extends Record<string, unknown>>(\n  props: T\n): T {\n  const prefersReducedMotion = useReducedMotion();\n\n  if (prefersReducedMotion) {\n    return {\n      ...props,\n      initial: false,\n      animate: props.animate,\n      exit: undefined,\n      transition: { duration: 0 },\n      whileHover: undefined,\n      whileTap: undefined,\n      whileFocus: undefined,\n      whileDrag: undefined,\n      whileInView: undefined,\n    } as T;\n  }\n\n  return props;\n}\n\n/**\n * Reduced motion safe transition config\n * Use this as the transition prop for Framer Motion\n */\nexport function getReducedMotionTransition(\n  normalTransition: Record<string, unknown>,\n  prefersReducedMotion: boolean\n): Record<string, unknown> {\n  if (prefersReducedMotion) {\n    return { duration: 0 };\n  }\n  return normalTransition;\n}\n\nexport default useReducedMotion;\n","// Voice hooks\nexport {\n  useSpeechRecognition,\n  type SpeechRecognitionStatus,\n  type SpeechRecognitionError,\n  type UseSpeechRecognitionReturn,\n  type UseSpeechRecognitionOptions,\n} from './useSpeechRecognition';\n\nexport {\n  useTextToSpeech,\n  type TTSStatus,\n  type TTSError,\n  type TTSVoice,\n  type UseTextToSpeechReturn,\n  type UseTextToSpeechOptions,\n} from './useTextToSpeech';\n\nexport {\n  useVoiceChat,\n  type VoiceChatMode,\n  type VoiceChatError,\n  type UseVoiceChatReturn,\n  type UseVoiceChatOptions,\n} from './useVoiceChat';\n\n// Scheduling hooks\nexport { useScheduling } from './useScheduling';\n\n// Accessibility hooks\nexport {\n  useReducedMotion,\n  useMotionSafe,\n  getReducedMotionTransition,\n} from './useReducedMotion';\n\n// UI hooks\nexport { useHorizontalScroll } from './useHorizontalScroll';\n","/**\n * useScheduling - Hook for managing scheduling operations\n *\n * Provides access to event types, availability, bookings, and calendar sync.\n */\n\n\"use client\";\n\nimport { useCallback, useEffect, useState } from \"react\";\nimport { useQuery, useMutation } from \"@/lib/openclaw/hooks\";\nimport { getUserTimezone } from \"@/lib/scheduling/utils\";\nimport type {\n  EventType,\n  Availability,\n  Booking,\n  CalendarIntegration,\n  CalendarView,\n} from \"@/lib/scheduling/types\";\n\n// Dynamically import the API to handle cases where schema isn't deployed\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet api: any = null;\ntry {\n  api = require('@/lib/convex-shim').api;\n} catch {\n  // Schema not deployed yet\n}\n\ninterface UseSchedulingOptions {\n  autoInitializeAvailability?: boolean;\n}\n\nexport function useScheduling(options: UseSchedulingOptions = {}) {\n  const { autoInitializeAvailability = true } = options;\n\n  // Local state\n  const [calendarView, setCalendarView] = useState<CalendarView>(\"month\");\n  const [selectedDate, setSelectedDate] = useState<Date>(new Date());\n  const [isConnectingGoogle, setIsConnectingGoogle] = useState(false);\n\n  // Schema is ready if api.scheduling exists (always true with static import)\n  const schemaReady = Boolean(api?.scheduling);\n\n  // Convex queries - use skip pattern for conditional queries\n  const userProfileQuery = useQuery(\n    api.scheduling.getUserProfile,\n    schemaReady ? {} : \"skip\"\n  );\n  const eventTypesQuery = useQuery(\n    api.scheduling.getEventTypes,\n    schemaReady ? {} : \"skip\"\n  );\n  const availabilityQuery = useQuery(\n    api.scheduling.getAvailability,\n    schemaReady ? {} : \"skip\"\n  );\n  const defaultAvailabilityQuery = useQuery(\n    api.scheduling.getDefaultAvailability,\n    schemaReady ? {} : \"skip\"\n  );\n  const calendarIntegrationQuery = useQuery(\n    api.scheduling.getCalendarIntegration,\n    schemaReady ? {} : \"skip\"\n  );\n  const upcomingBookingsQuery = useQuery(\n    api.scheduling.getUpcomingBookings,\n    schemaReady ? { limit: 10 } : \"skip\"\n  );\n\n  // Cast results\n  const userProfile = userProfileQuery as { _id: string; username: string; displayName?: string; email?: string } | null | undefined;\n  const eventTypes = eventTypesQuery as EventType[] | undefined;\n  const availability = availabilityQuery as Availability[] | undefined;\n  const defaultAvailability = defaultAvailabilityQuery as Availability | null | undefined;\n  const calendarIntegration = calendarIntegrationQuery as CalendarIntegration | null | undefined;\n  const upcomingBookings = upcomingBookingsQuery as Booking[] | undefined;\n\n  // Convex mutations - use direct API references\n  const createEventTypeMutation = useMutation(api.scheduling.createEventType);\n  const updateEventTypeMutation = useMutation(api.scheduling.updateEventType);\n  const deleteEventTypeMutation = useMutation(api.scheduling.deleteEventType);\n  const createAvailabilityMutation = useMutation(api.scheduling.createAvailability);\n  const updateAvailabilityMutation = useMutation(api.scheduling.updateAvailability);\n  const deleteAvailabilityMutation = useMutation(api.scheduling.deleteAvailability);\n  const initializeDefaultAvailabilityMutation = useMutation(api.scheduling.initializeDefaultAvailability);\n  const setOverrideMutation = useMutation(api.scheduling.setOverride);\n  const deleteOverrideMutation = useMutation(api.scheduling.deleteOverride);\n  const updateBookingStatusMutation = useMutation(api.scheduling.updateBookingStatus);\n  const rescheduleBookingMutation = useMutation(api.scheduling.rescheduleBooking);\n  const saveCalendarIntegrationMutation = useMutation(api.scheduling.saveCalendarIntegration);\n  const updateCalendarIntegrationMutation = useMutation(api.scheduling.updateCalendarIntegration);\n  const deleteCalendarIntegrationMutation = useMutation(api.scheduling.deleteCalendarIntegration);\n  const updateBookingGoogleEventIdMutation = useMutation(api.scheduling.updateBookingGoogleEventId);\n  const createOrUpdateUserProfileMutation = useMutation(api.scheduling.createOrUpdateUserProfile);\n\n  // Auto-initialize default availability\n  useEffect(() => {\n    if (\n      schemaReady &&\n      autoInitializeAvailability &&\n      availability !== undefined &&\n      availability.length === 0 &&\n      defaultAvailability === null\n    ) {\n      const timezone = getUserTimezone();\n      initializeDefaultAvailabilityMutation({ timezone }).catch(console.error);\n    }\n  }, [\n    schemaReady,\n    autoInitializeAvailability,\n    availability,\n    defaultAvailability,\n    initializeDefaultAvailabilityMutation,\n  ]);\n\n  // User Profile actions\n  const createOrUpdateUserProfile = useCallback(\n    async (data: { username: string; displayName?: string }) => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      return await createOrUpdateUserProfileMutation(data);\n    },\n    [schemaReady, createOrUpdateUserProfileMutation]\n  );\n\n  // Event Type actions\n  const createEventType = useCallback(\n    async (data: {\n      title: string;\n      description?: string;\n      duration: number;\n      color: string;\n      locationType: \"google_meet\" | \"zoom\" | \"phone\" | \"in_person\" | \"custom\";\n      locationValue?: string;\n      bufferBefore?: number;\n      bufferAfter?: number;\n      minNotice?: number;\n      maxAdvance?: number;\n    }) => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      return await createEventTypeMutation(data);\n    },\n    [schemaReady, createEventTypeMutation]\n  );\n\n  const updateEventType = useCallback(\n    async (id: string, data: Partial<EventType>) => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      const { _id, ownerId, createdAt, ...updateData } = data as Record<string, unknown>;\n      await updateEventTypeMutation({ id, ...updateData } as any);\n    },\n    [schemaReady, updateEventTypeMutation]\n  );\n\n  const deleteEventType = useCallback(\n    async (id: string) => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      await deleteEventTypeMutation({ id } as any);\n    },\n    [schemaReady, deleteEventTypeMutation]\n  );\n\n  // Availability actions\n  const createAvailability = useCallback(\n    async (data: {\n      name: string;\n      timezone: string;\n      isDefault?: boolean;\n      schedule: Array<{\n        dayOfWeek: number;\n        isAvailable: boolean;\n        slots: Array<{ start: string; end: string }>;\n      }>;\n    }) => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      return await createAvailabilityMutation(data);\n    },\n    [schemaReady, createAvailabilityMutation]\n  );\n\n  const updateAvailability = useCallback(\n    async (id: string, data: Partial<Availability>) => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      const { _id, ownerId, createdAt, ...updateData } = data as Record<string, unknown>;\n      await updateAvailabilityMutation({ id, ...updateData } as any);\n    },\n    [schemaReady, updateAvailabilityMutation]\n  );\n\n  const deleteAvailability = useCallback(\n    async (id: string) => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      await deleteAvailabilityMutation({ id } as any);\n    },\n    [schemaReady, deleteAvailabilityMutation]\n  );\n\n  // Override actions\n  const setOverride = useCallback(\n    async (data: {\n      date: string;\n      isBlocked: boolean;\n      slots?: Array<{ start: string; end: string }>;\n      reason?: string;\n    }) => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      return await setOverrideMutation(data);\n    },\n    [schemaReady, setOverrideMutation]\n  );\n\n  const deleteOverride = useCallback(\n    async (date: string) => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      await deleteOverrideMutation({ date });\n    },\n    [schemaReady, deleteOverrideMutation]\n  );\n\n  // Booking actions\n  const confirmBooking = useCallback(\n    async (id: string) => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      await updateBookingStatusMutation({ id, status: \"confirmed\" } as any);\n    },\n    [schemaReady, updateBookingStatusMutation]\n  );\n\n  const cancelBooking = useCallback(\n    async (id: string, reason?: string, cancelledBy?: \"host\" | \"guest\") => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      await updateBookingStatusMutation({\n        id,\n        status: \"cancelled\",\n        cancelReason: reason,\n        cancelledBy,\n      } as any);\n    },\n    [schemaReady, updateBookingStatusMutation]\n  );\n\n  const markNoShow = useCallback(\n    async (id: string) => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      await updateBookingStatusMutation({ id, status: \"no_show\" } as any);\n    },\n    [schemaReady, updateBookingStatusMutation]\n  );\n\n  const markCompleted = useCallback(\n    async (id: string) => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      await updateBookingStatusMutation({ id, status: \"completed\" } as any);\n    },\n    [schemaReady, updateBookingStatusMutation]\n  );\n\n  const rescheduleBooking = useCallback(\n    async (id: string, newStartTime: number) => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      return await rescheduleBookingMutation({ id, newStartTime } as any);\n    },\n    [schemaReady, rescheduleBookingMutation]\n  );\n\n  // Google Calendar actions\n  const connectGoogleCalendar = useCallback(async () => {\n    setIsConnectingGoogle(true);\n    try {\n      const response = await fetch(\"/api/calendar/google/auth?returnUrl=/calendar\");\n      const data = await response.json();\n\n      if (data.authUrl) {\n        window.location.href = data.authUrl;\n      } else {\n        throw new Error(data.error || \"Failed to get auth URL\");\n      }\n    } catch (error) {\n      console.error(\"Failed to connect Google Calendar:\", error);\n      setIsConnectingGoogle(false);\n      throw error;\n    }\n  }, []);\n\n  const saveGoogleTokens = useCallback(\n    async (tokenData: {\n      accessToken: string;\n      refreshToken: string;\n      tokenExpiry: number;\n      calendarId: string;\n      calendarEmail: string;\n    }) => {\n      if (!schemaReady) throw new Error(\"Schema not deployed\");\n      await saveCalendarIntegrationMutation(tokenData);\n    },\n    [schemaReady, saveCalendarIntegrationMutation]\n  );\n\n  const disconnectGoogleCalendar = useCallback(async () => {\n    if (!schemaReady) throw new Error(\"Schema not deployed\");\n    await deleteCalendarIntegrationMutation();\n  }, [schemaReady, deleteCalendarIntegrationMutation]);\n\n  const syncBookingToCalendar = useCallback(\n    async (booking: Booking, action: \"create\" | \"update\" | \"delete\" = \"create\") => {\n      if (!calendarIntegration) {\n        throw new Error(\"No calendar integration configured\");\n      }\n\n      const response = await fetch(\"/api/calendar/sync\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          action,\n          booking,\n          integration: calendarIntegration,\n          timezone: defaultAvailability?.timezone || getUserTimezone(),\n        }),\n      });\n\n      const data = await response.json();\n\n      if (data.needsTokenUpdate) {\n        await saveCalendarIntegrationMutation({\n          accessToken: data.newTokens.accessToken,\n          refreshToken: data.newTokens.refreshToken,\n          tokenExpiry: data.newTokens.tokenExpiry,\n          calendarId: calendarIntegration.calendarId,\n          calendarEmail: calendarIntegration.calendarEmail,\n        });\n        return syncBookingToCalendar(booking, action);\n      }\n\n      if (!data.success) {\n        throw new Error(data.error || \"Sync failed\");\n      }\n\n      if (action === \"create\" && data.googleEventId) {\n        await updateBookingGoogleEventIdMutation({\n          bookingId: booking._id,\n          googleEventId: data.googleEventId,\n          location: data.meetLink,\n        } as any);\n      }\n\n      return data;\n    },\n    [\n      calendarIntegration,\n      defaultAvailability?.timezone,\n      saveCalendarIntegrationMutation,\n      updateBookingGoogleEventIdMutation,\n    ]\n  );\n\n  // Loading states\n  const isLoading = !schemaReady ||\n    eventTypes === undefined ||\n    availability === undefined ||\n    calendarIntegration === undefined;\n\n  return {\n    // Schema status\n    schemaReady,\n\n    // Data\n    userProfile: userProfile ?? null,\n    eventTypes: eventTypes || [],\n    availability: availability || [],\n    defaultAvailability: defaultAvailability ?? null,\n    calendarIntegration: calendarIntegration ?? null,\n    upcomingBookings: upcomingBookings || [],\n\n    // Calendar view state\n    calendarView,\n    setCalendarView,\n    selectedDate,\n    setSelectedDate,\n\n    // User Profile actions\n    createOrUpdateUserProfile,\n\n    // Event Type actions\n    createEventType,\n    updateEventType,\n    deleteEventType,\n\n    // Availability actions\n    createAvailability,\n    updateAvailability,\n    deleteAvailability,\n    setOverride,\n    deleteOverride,\n\n    // Booking actions\n    confirmBooking,\n    cancelBooking,\n    markNoShow,\n    markCompleted,\n    rescheduleBooking,\n\n    // Google Calendar actions\n    connectGoogleCalendar,\n    saveGoogleTokens,\n    disconnectGoogleCalendar,\n    syncBookingToCalendar,\n    isConnectingGoogle,\n\n    // Loading state\n    isLoading,\n  };\n}\n","'use client';\n\nimport { useRef, useEffect, useCallback } from 'react';\n\n/**\n * Hook to enable mouse wheel scrolling on horizontal scroll containers.\n *\n * Converts vertical wheel movement (deltaY) to horizontal scroll,\n * allowing users to scroll horizontal lists with their mouse wheel.\n *\n * @param options.speed - Multiplier for scroll speed (default: 1)\n * @param options.smooth - Enable smooth scrolling behavior (default: false)\n * @returns A ref to attach to the scrollable container\n *\n * @example\n * ```tsx\n * function HorizontalList() {\n *   const scrollRef = useHorizontalScroll<HTMLDivElement>();\n *   return (\n *     <div ref={scrollRef} className=\"flex overflow-x-auto\">\n *       {items.map(item => <Card key={item.id} />)}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useHorizontalScroll<T extends HTMLElement>(\n  options: { speed?: number; smooth?: boolean } = {}\n) {\n  const { speed = 1, smooth = false } = options;\n  const ref = useRef<T>(null);\n\n  const handleWheel = useCallback(\n    (e: WheelEvent) => {\n      const el = ref.current;\n      if (!el) return;\n\n      // Don't hijack if user is scrolling horizontally naturally (trackpad)\n      if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) return;\n\n      // Don't hijack if container can't scroll horizontally\n      const canScrollHorizontally = el.scrollWidth > el.clientWidth;\n      if (!canScrollHorizontally) return;\n\n      // Check if we're at the scroll boundaries\n      const isAtStart = el.scrollLeft <= 0;\n      const isAtEnd = el.scrollLeft >= el.scrollWidth - el.clientWidth - 1;\n\n      // Allow natural page scroll if at boundaries and trying to scroll past\n      if ((isAtStart && e.deltaY < 0) || (isAtEnd && e.deltaY > 0)) {\n        return;\n      }\n\n      // Prevent default vertical scroll and convert to horizontal\n      e.preventDefault();\n\n      if (smooth) {\n        el.scrollBy({\n          left: e.deltaY * speed,\n          behavior: 'smooth',\n        });\n      } else {\n        el.scrollLeft += e.deltaY * speed;\n      }\n    },\n    [speed, smooth]\n  );\n\n  useEffect(() => {\n    const el = ref.current;\n    if (!el) return;\n\n    // Must use { passive: false } to enable preventDefault()\n    el.addEventListener('wheel', handleWheel, { passive: false });\n\n    return () => {\n      el.removeEventListener('wheel', handleWheel);\n    };\n  }, [handleWheel]);\n\n  return ref;\n}\n\nexport default useHorizontalScroll;\n"],"names":[],"mappings":"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"}