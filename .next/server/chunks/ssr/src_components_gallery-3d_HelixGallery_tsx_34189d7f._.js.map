{"version":3,"sources":["../../../../src/components/gallery-3d/HelixGallery.tsx","../../../../node_modules/.pnpm/maath%400.10.8_%40types%2Bthree%400.170.0_three%400.170.0/node_modules/maath/dist/objectSpread2-284232a6.esm.js","../../../../node_modules/.pnpm/maath%400.10.8_%40types%2Bthree%400.170.0_three%400.170.0/node_modules/maath/dist/isNativeReflectConstruct-5594d075.esm.js","../../../../node_modules/.pnpm/maath%400.10.8_%40types%2Bthree%400.170.0_three%400.170.0/node_modules/maath/dist/vector2-d2bf51f1.esm.js","../../../../node_modules/.pnpm/maath%400.10.8_%40types%2Bthree%400.170.0_three%400.170.0/node_modules/maath/dist/vector3-0a088b7f.esm.js","../../../../node_modules/.pnpm/maath%400.10.8_%40types%2Bthree%400.170.0_three%400.170.0/node_modules/maath/dist/classCallCheck-9098b006.esm.js","../../../../node_modules/.pnpm/%40react-three%2Bdrei%4010.7.7_%40react-three%2Bfiber%409.5.0_%40types%2Breact%4019.2.8_react-dom%4019.2.3_react%40_otfyaga7ti6f5mvznauek6nyga/node_modules/%40react-three/drei/web/ScrollControls.js","../../../../node_modules/.pnpm/maath%400.10.8_%40types%2Bthree%400.170.0_three%400.170.0/node_modules/maath/dist/triangle-b62b9067.esm.js","../../../../node_modules/.pnpm/three-stdlib%402.36.1_three%400.170.0/node_modules/src/lines/LineGeometry.js","../../../../node_modules/.pnpm/three-stdlib%402.36.1_three%400.170.0/node_modules/src/_polyfill/uv1.ts","../../../../node_modules/.pnpm/three-stdlib%402.36.1_three%400.170.0/node_modules/src/lines/LineSegmentsGeometry.js","../../../../node_modules/.pnpm/maath%400.10.8_%40types%2Bthree%400.170.0_three%400.170.0/node_modules/maath/dist/three-eb2ad8c0.esm.js","../../../../node_modules/.pnpm/maath%400.10.8_%40types%2Bthree%400.170.0_three%400.170.0/node_modules/maath/dist/matrix-baa530bf.esm.js","../../../../node_modules/.pnpm/three-stdlib%402.36.1_three%400.170.0/node_modules/src/lines/LineMaterial.js","../../../../node_modules/.pnpm/three-stdlib%402.36.1_three%400.170.0/node_modules/src/lines/Line2.js","../../../../node_modules/.pnpm/maath%400.10.8_%40types%2Bthree%400.170.0_three%400.170.0/node_modules/maath/dist/misc-19a3ec46.esm.js","../../../../node_modules/.pnpm/maath%400.10.8_%40types%2Bthree%400.170.0_three%400.170.0/node_modules/maath/dist/index-0332b2ed.esm.js","../../../../node_modules/.pnpm/maath%400.10.8_%40types%2Bthree%400.170.0_three%400.170.0/node_modules/maath/dist/easing-0f4db1c0.esm.js","../../../../node_modules/.pnpm/maath%400.10.8_%40types%2Bthree%400.170.0_three%400.170.0/node_modules/maath/dist/geometry-0fb11825.esm.js","../../../../node_modules/.pnpm/three-stdlib%402.36.1_three%400.170.0/node_modules/src/lines/LineSegments2.js","../../../../node_modules/.pnpm/%40react-three%2Bdrei%4010.7.7_%40react-three%2Bfiber%409.5.0_%40types%2Breact%4019.2.8_react-dom%4019.2.3_react%40_otfyaga7ti6f5mvznauek6nyga/node_modules/%40react-three/drei/core/Line.js","../../../../node_modules/.pnpm/maath%400.10.8_%40types%2Bthree%400.170.0_three%400.170.0/node_modules/maath/dist/buffer-59a95d05.esm.js"],"sourcesContent":["'use client';\n\nimport { useRef, useMemo, useState, useEffect } from 'react';\nimport { Canvas, useFrame, useThree } from '@react-three/fiber';\nimport { useTexture, Html, ScrollControls, useScroll, Line } from '@react-three/drei';\nimport * as THREE from 'three';\nimport type { GalleryImage, AudioReactiveData } from './types';\nimport { helixPoint, lerp, damp } from './utils';\n\ninterface HelixGalleryProps {\n  images: GalleryImage[];\n  className?: string;\n  radius?: number;\n  height?: number;\n  turns?: number;\n  itemSize?: number;\n  scrollPages?: number;\n  onImageClick?: (image: GalleryImage, index: number) => void;\n  audioData?: AudioReactiveData;\n}\n\ninterface HelixItemProps {\n  image: GalleryImage;\n  position: THREE.Vector3;\n  index: number;\n  totalItems: number;\n  scrollProgress: number;\n  itemSize: number;\n  onHover: (index: number | null) => void;\n  onClick: () => void;\n  isHovered: boolean;\n  audioData?: AudioReactiveData;\n}\n\nfunction HelixItem({\n  image,\n  position,\n  index,\n  totalItems,\n  scrollProgress,\n  itemSize,\n  onHover,\n  onClick,\n  isHovered,\n  audioData,\n}: HelixItemProps) {\n  const meshRef = useRef<THREE.Mesh>(null);\n  const glowRef = useRef<THREE.Mesh>(null);\n  const texture = useTexture(image.src);\n  const [scale, setScale] = useState(1);\n\n  // Calculate distance from \"active\" position based on scroll\n  const activePosition = scrollProgress * totalItems;\n  const distance = Math.abs(index - activePosition);\n  const isActive = distance < 1;\n\n  // Face outward from helix center\n  const rotation = useMemo(() => {\n    return new THREE.Euler(0, Math.atan2(position.x, position.z) + Math.PI, 0);\n  }, [position]);\n\n  useFrame((state, delta) => {\n    let targetScale = isHovered ? 1.3 : isActive ? 1.15 : 1 - distance * 0.05;\n\n    // Audio reactive scaling\n    if (audioData?.enabled) {\n      const freqIndex = index % 5;\n      const freqValues = [audioData.bass, audioData.lowMid, audioData.mid, audioData.highMid, audioData.treble];\n      const freqResponse = freqValues[freqIndex] || 0;\n\n      targetScale *= 1 + freqResponse * 0.25;\n\n      if (audioData.isBeat && isActive) {\n        targetScale *= 1 + audioData.beatIntensity * 0.3;\n      }\n    }\n\n    setScale((prev) => damp(prev, Math.max(0.5, targetScale), 6, delta));\n\n    if (meshRef.current) {\n      meshRef.current.scale.setScalar(scale);\n      // Audio reactive float\n      const floatOffset = audioData?.enabled\n        ? Math.sin(state.clock.elapsedTime * 2 + index) * 0.1 * (1 + audioData.energy)\n        : Math.sin(Date.now() * 0.001 + index) * 0.05;\n      meshRef.current.position.y = position.y + floatOffset;\n\n      // Audio reactive emissive\n      if (audioData?.enabled && meshRef.current.material instanceof THREE.MeshStandardMaterial) {\n        const intensity = isActive ? audioData.energy * 0.5 : audioData.energy * 0.2;\n        meshRef.current.material.emissiveIntensity = intensity;\n      }\n    }\n\n    // Glow ring pulse\n    if (glowRef.current && audioData?.enabled) {\n      const glowScale = 1.1 + audioData.beatIntensity * 0.3;\n      glowRef.current.scale.setScalar(glowScale);\n      if (glowRef.current.material instanceof THREE.MeshBasicMaterial) {\n        glowRef.current.material.opacity = 0.4 + audioData.beatIntensity * 0.4;\n      }\n    }\n  });\n\n  const aspect = texture.image ? texture.image.width / texture.image.height : 1;\n  const width = aspect > 1 ? itemSize : itemSize * aspect;\n  const height = aspect > 1 ? itemSize / aspect : itemSize;\n\n  // Calculate opacity based on distance\n  const opacity = Math.max(0.3, 1 - distance * 0.15);\n\n  return (\n    <group position={position} rotation={rotation}>\n      <mesh\n        ref={meshRef}\n        onPointerEnter={() => onHover(index)}\n        onPointerLeave={() => onHover(null)}\n        onClick={onClick}\n      >\n        <planeGeometry args={[width, height]} />\n        <meshStandardMaterial\n          map={texture}\n          transparent\n          opacity={opacity}\n          emissive={isActive ? '#4f46e5' : '#000000'}\n          emissiveIntensity={isActive ? 0.2 : 0}\n        />\n      </mesh>\n\n      {/* Glow ring for active item or audio reactive */}\n      {(isActive || audioData?.enabled) && (\n        <mesh ref={glowRef} position={[0, 0, -0.02]} scale={1.1}>\n          <ringGeometry args={[Math.max(width, height) * 0.55, Math.max(width, height) * 0.6, 32]} />\n          <meshBasicMaterial\n            color={audioData?.enabled ? `hsl(${260 + (audioData.mid || 0) * 60}, 80%, 50%)` : '#4f46e5'}\n            transparent\n            opacity={isActive ? 0.6 : 0.3}\n          />\n        </mesh>\n      )}\n\n      {/* Label on hover */}\n      {isHovered && image.alt && (\n        <Html center position={[0, -height / 2 - 0.3, 0.1]}>\n          <div className=\"bg-indigo-600/90 text-white px-3 py-1.5 rounded-lg text-sm whitespace-nowrap shadow-lg\">\n            {image.alt}\n          </div>\n        </Html>\n      )}\n    </group>\n  );\n}\n\ninterface HelixSceneProps {\n  images: GalleryImage[];\n  radius: number;\n  height: number;\n  turns: number;\n  itemSize: number;\n  onImageClick?: (image: GalleryImage, index: number) => void;\n  audioData?: AudioReactiveData;\n}\n\nfunction HelixSceneInner({\n  images,\n  radius,\n  height,\n  turns,\n  itemSize,\n  onImageClick,\n  audioData,\n}: HelixSceneProps) {\n  const scroll = useScroll();\n  const groupRef = useRef<THREE.Group>(null);\n  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);\n  const [scrollProgress, setScrollProgress] = useState(0);\n  const { camera } = useThree();\n\n  // Calculate helix positions\n  const positions = useMemo(() => {\n    return images.map((_, index) => {\n      const angle = (index / images.length) * Math.PI * 2 * turns;\n      return helixPoint(radius, height, angle, turns);\n    });\n  }, [images.length, radius, height, turns]);\n\n  useFrame((state) => {\n    const progress = scroll.offset;\n    setScrollProgress(progress);\n\n    // Move camera along with scroll\n    const cameraY = (progress - 0.5) * height;\n    camera.position.y = damp(camera.position.y, cameraY, 4, 0.016);\n\n    // Rotate group slightly based on scroll + audio\n    if (groupRef.current) {\n      let rotationY = progress * Math.PI * 0.5;\n\n      if (audioData?.enabled) {\n        rotationY += Math.sin(state.clock.elapsedTime * 2) * audioData.energy * 0.2;\n        // Wobble on beat\n        if (audioData.isBeat) {\n          groupRef.current.rotation.x = Math.sin(state.clock.elapsedTime * 10) * 0.03 * audioData.beatIntensity;\n        } else {\n          groupRef.current.rotation.x = lerp(groupRef.current.rotation.x, 0, 0.1);\n        }\n      }\n\n      groupRef.current.rotation.y = rotationY;\n    }\n  });\n\n  return (\n    <>\n      {/* Lighting with audio reactivity */}\n      <ambientLight intensity={audioData?.enabled ? 0.4 + audioData.energy * 0.3 : 0.5} />\n      <pointLight\n        position={[10, 10, 10]}\n        intensity={audioData?.enabled ? 0.8 + audioData.treble * 0.5 : 1}\n        color=\"#ffffff\"\n      />\n      <pointLight\n        position={[-10, -10, -10]}\n        intensity={audioData?.enabled ? 0.4 + audioData.bass * 0.4 : 0.5}\n        color=\"#4f46e5\"\n      />\n      <pointLight\n        position={[0, height / 2, 0]}\n        intensity={audioData?.enabled ? 0.4 + audioData.mid * 0.4 : 0.5}\n        color=\"#06b6d4\"\n      />\n      <pointLight\n        position={[0, -height / 2, 0]}\n        intensity={audioData?.enabled ? 0.4 + audioData.highMid * 0.4 : 0.5}\n        color=\"#8b5cf6\"\n      />\n\n      {/* Central helix spine */}\n      <group ref={groupRef}>\n        {/* DNA-like connecting lines with audio reactivity */}\n        {positions.map((pos, i) => {\n          if (i === positions.length - 1) return null;\n          const nextPos = positions[i + 1];\n          const points: [number, number, number][] = [\n            [pos.x, pos.y, pos.z],\n            [nextPos.x, nextPos.y, nextPos.z],\n          ];\n\n          const lineOpacity = audioData?.enabled ? 0.3 + audioData.energy * 0.4 : 0.3;\n\n          return (\n            <Line\n              key={`line-${i}`}\n              points={points}\n              color={audioData?.enabled ? `hsl(${260 + (audioData.mid || 0) * 40}, 70%, 50%)` : '#4f46e5'}\n              transparent\n              opacity={lineOpacity}\n              lineWidth={audioData?.enabled ? 1 + audioData.bass * 2 : 1}\n            />\n          );\n        })}\n\n        {/* Gallery items */}\n        {images.map((image, index) => (\n          <HelixItem\n            key={`${image.src}-${index}`}\n            image={image}\n            position={positions[index]}\n            index={index}\n            totalItems={images.length}\n            scrollProgress={scrollProgress}\n            itemSize={itemSize}\n            onHover={setHoveredIndex}\n            onClick={() => onImageClick?.(image, index)}\n            isHovered={hoveredIndex === index}\n            audioData={audioData}\n          />\n        ))}\n      </group>\n\n      {/* Background particles */}\n      <Points count={500} radius={radius * 3} audioData={audioData} />\n\n      {/* Fog for depth */}\n      <fog attach=\"fog\" args={['#0f172a', radius * 2, radius * 8]} />\n    </>\n  );\n}\n\n// Floating particles for ambiance with audio reactivity\nfunction Points({ count, radius, audioData }: { count: number; radius: number; audioData?: AudioReactiveData }) {\n  const pointsRef = useRef<THREE.Points>(null);\n\n  const [positions, colors] = useMemo(() => {\n    const positions = new Float32Array(count * 3);\n    const colors = new Float32Array(count * 3);\n\n    for (let i = 0; i < count; i++) {\n      const theta = Math.random() * Math.PI * 2;\n      const phi = Math.acos(2 * Math.random() - 1);\n      const r = radius * (0.5 + Math.random() * 0.5);\n\n      positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);\n      positions[i * 3 + 1] = r * Math.cos(phi);\n      positions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);\n\n      // Purple/cyan gradient colors\n      const t = Math.random();\n      colors[i * 3] = lerp(0.31, 0.02, t);\n      colors[i * 3 + 1] = lerp(0.27, 0.71, t);\n      colors[i * 3 + 2] = lerp(0.9, 0.83, t);\n    }\n\n    return [positions, colors];\n  }, [count, radius]);\n\n  useFrame((state) => {\n    if (pointsRef.current) {\n      let rotSpeed = state.clock.elapsedTime * 0.02;\n      let xTilt = Math.sin(state.clock.elapsedTime * 0.01) * 0.1;\n\n      if (audioData?.enabled) {\n        rotSpeed *= 1 + audioData.energy * 2;\n        xTilt *= 1 + audioData.bass * 2;\n      }\n\n      pointsRef.current.rotation.y = rotSpeed;\n      pointsRef.current.rotation.x = xTilt;\n\n      // Audio reactive particle size\n      if (pointsRef.current.material instanceof THREE.PointsMaterial && audioData?.enabled) {\n        pointsRef.current.material.size = 0.05 + audioData.beatIntensity * 0.05;\n        pointsRef.current.material.opacity = 0.6 + audioData.energy * 0.3;\n      }\n    }\n  });\n\n  return (\n    <points ref={pointsRef}>\n      <bufferGeometry>\n        <bufferAttribute\n          attach=\"attributes-position\"\n          args={[positions, 3]}\n        />\n        <bufferAttribute\n          attach=\"attributes-color\"\n          args={[colors, 3]}\n        />\n      </bufferGeometry>\n      <pointsMaterial\n        size={0.05}\n        transparent\n        opacity={0.6}\n        vertexColors\n        sizeAttenuation\n      />\n    </points>\n  );\n}\n\nfunction FallbackGallery({ images }: { images: GalleryImage[] }) {\n  return (\n    <div className=\"w-full h-full overflow-y-auto bg-gradient-to-b from-slate-900 via-indigo-950 to-slate-900 p-8\">\n      <div className=\"max-w-md mx-auto space-y-6\">\n        {images.map((img, i) => (\n          <div\n            key={i}\n            className=\"transform hover:scale-105 transition-transform\"\n            style={{ transform: `translateX(${Math.sin(i * 0.5) * 20}px)` }}\n          >\n            <img\n              src={img.src}\n              alt={img.alt || ''}\n              className=\"w-full h-48 object-cover rounded-xl shadow-xl\"\n            />\n            {img.alt && <p className=\"text-white/70 text-sm mt-2 text-center\">{img.alt}</p>}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default function HelixGallery({\n  images,\n  className = 'w-full h-[700px]',\n  radius = 3,\n  height = 15,\n  turns = 2,\n  itemSize = 1.5,\n  scrollPages = 3,\n  onImageClick,\n  audioData,\n}: HelixGalleryProps) {\n  const [webglSupported, setWebglSupported] = useState(true);\n\n  useEffect(() => {\n    try {\n      const canvas = document.createElement('canvas');\n      if (!canvas.getContext('webgl') && !canvas.getContext('experimental-webgl')) {\n        setWebglSupported(false);\n      }\n    } catch {\n      setWebglSupported(false);\n    }\n  }, []);\n\n  if (!webglSupported) {\n    return (\n      <div className={className}>\n        <FallbackGallery images={images} />\n      </div>\n    );\n  }\n\n  return (\n    <div className={className}>\n      <Canvas\n        camera={{ position: [0, 0, radius * 3], fov: 60 }}\n        gl={{ antialias: true, alpha: true }}\n        style={{ background: 'linear-gradient(180deg, #0f172a 0%, #1e1b4b 50%, #0f172a 100%)' }}\n      >\n        <ScrollControls pages={scrollPages} damping={0.25}>\n          <HelixSceneInner\n            images={images}\n            radius={radius}\n            height={height}\n            turns={turns}\n            itemSize={itemSize}\n            onImageClick={onImageClick}\n            audioData={audioData}\n          />\n        </ScrollControls>\n      </Canvas>\n    </div>\n  );\n}\n","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nexport { _objectSpread2 as _, _defineProperty as a };\n","function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport { _setPrototypeOf as _, _isNativeReflectConstruct as a };\n","/**\n *\n */\nfunction zero() {\n  return [0, 0];\n}\nfunction one() {\n  return [1, 1];\n}\nfunction add(a, b) {\n  return [a[0] + b[0], a[1] + b[1]];\n}\nfunction addValue(a, n) {\n  return [a[0] + n, a[1] + n];\n}\nfunction sub(a, b) {\n  return [a[0] - b[0], a[1] - b[1]];\n}\nfunction subValue(a, n) {\n  return [a[0] - n, a[1] - n];\n}\nfunction scale(a, n) {\n  return [a[0] * n, a[1] * n];\n}\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Calculate the squared length of a vector.\n * Use this when comparing two vectors instead of length, as it's more efficient (no sqrt)\n */\n\nfunction lengthSqr(a) {\n  return a[0] * a[0] + a[1] * a[1];\n}\n/**\n * Calculate the length of a vector.\n * If you only need to compare lenghts, consider using the more efficient lengthSqr\n */\n\nfunction length(a) {\n  return Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n}\nfunction distance(a, b) {\n  return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));\n}\n\nvar vector2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  zero: zero,\n  one: one,\n  add: add,\n  addValue: addValue,\n  sub: sub,\n  subValue: subValue,\n  scale: scale,\n  dot: dot,\n  lengthSqr: lengthSqr,\n  length: length,\n  distance: distance\n});\n\nexport { add as a, addValue as b, subValue as c, scale as d, dot as e, length as f, distance as g, lengthSqr as l, one as o, sub as s, vector2 as v, zero as z };\n","/**\n *\n */\nfunction zero() {\n  return [0, 0, 0];\n}\nfunction one() {\n  return [1, 1, 1];\n}\nfunction add(a, b) {\n  return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];\n}\nfunction addValue(a, n) {\n  return [a[0] + n, a[1] + n, a[2] + n];\n}\nfunction sub(a, b) {\n  return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];\n}\nfunction subValue(a, n) {\n  return [a[0] - n, a[1] - n, a[2] - n];\n}\nfunction scale(a, n) {\n  return [a[0] * n, a[1] * n, a[2] * n];\n}\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\nfunction cross(a, b) {\n  var x = a[1] * b[2] - a[2] * b[1];\n  var y = a[2] * b[0] - a[0] * b[2];\n  var z = a[0] * b[1] - a[1] * b[0];\n  return [x, y, z];\n}\n/**\n * Calculate the squared length of a vector.\n * Use this when comparing two vectors instead of length, as it's more efficient (no sqrt)\n */\n\nfunction lengthSqr(a) {\n  return a[0] * a[0] + a[1] * a[1] + a[2] * a[2];\n}\n/**\n * Calculate the length of a vector.\n * If you only need to compare lenghts, consider using the more efficient lengthSqr\n */\n\nfunction length(a) {\n  return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);\n}\nfunction distance(a, b) {\n  return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]) + (a[2] - b[2]) * (a[2] - b[2]));\n}\n\nvar vector3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  zero: zero,\n  one: one,\n  add: add,\n  addValue: addValue,\n  sub: sub,\n  subValue: subValue,\n  scale: scale,\n  dot: dot,\n  cross: cross,\n  lengthSqr: lengthSqr,\n  length: length,\n  distance: distance\n});\n\nexport { add as a, addValue as b, subValue as c, scale as d, dot as e, cross as f, length as g, distance as h, lengthSqr as l, one as o, sub as s, vector3 as v, zero as z };\n","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nexport { _classCallCheck as _ };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom/client';\nimport { useThree, useFrame, context as context$1 } from '@react-three/fiber';\nimport { easing } from 'maath';\n\nconst context = /* @__PURE__ */React.createContext(null);\nfunction useScroll() {\n  return React.useContext(context);\n}\nfunction ScrollControls({\n  eps = 0.00001,\n  enabled = true,\n  infinite,\n  horizontal,\n  pages = 1,\n  distance = 1,\n  damping = 0.25,\n  maxSpeed = Infinity,\n  prepend = false,\n  style = {},\n  children\n}) {\n  const {\n    get,\n    setEvents,\n    gl,\n    size,\n    invalidate,\n    events\n  } = useThree();\n  const [el] = React.useState(() => document.createElement('div'));\n  const [fill] = React.useState(() => document.createElement('div'));\n  const [fixed] = React.useState(() => document.createElement('div'));\n  const target = gl.domElement.parentNode;\n  const scroll = React.useRef(0);\n  const state = React.useMemo(() => {\n    const state = {\n      el,\n      eps,\n      fill,\n      fixed,\n      horizontal,\n      damping,\n      offset: 0,\n      delta: 0,\n      scroll,\n      pages,\n      // 0-1 for a range between from -> from + distance\n      range(from, distance, margin = 0) {\n        const start = from - margin;\n        const end = start + distance + margin * 2;\n        return this.offset < start ? 0 : this.offset > end ? 1 : (this.offset - start) / (end - start);\n      },\n      // 0-1-0 for a range between from -> from + distance\n      curve(from, distance, margin = 0) {\n        return Math.sin(this.range(from, distance, margin) * Math.PI);\n      },\n      // true/false for a range between from -> from + distance\n      visible(from, distance, margin = 0) {\n        const start = from - margin;\n        const end = start + distance + margin * 2;\n        return this.offset >= start && this.offset <= end;\n      }\n    };\n    return state;\n  }, [eps, damping, horizontal, pages]);\n  React.useEffect(() => {\n    el.style.position = 'absolute';\n    el.style.width = '100%';\n    el.style.height = '100%';\n    el.style[horizontal ? 'overflowX' : 'overflowY'] = 'auto';\n    el.style[horizontal ? 'overflowY' : 'overflowX'] = 'hidden';\n    el.style.top = '0px';\n    el.style.left = '0px';\n    for (const key in style) {\n      el.style[key] = style[key];\n    }\n    fixed.style.position = 'sticky';\n    fixed.style.top = '0px';\n    fixed.style.left = '0px';\n    fixed.style.width = '100%';\n    fixed.style.height = '100%';\n    fixed.style.overflow = 'hidden';\n    el.appendChild(fixed);\n    fill.style.height = horizontal ? '100%' : `${pages * distance * 100}%`;\n    fill.style.width = horizontal ? `${pages * distance * 100}%` : '100%';\n    fill.style.pointerEvents = 'none';\n    el.appendChild(fill);\n    if (prepend) target.prepend(el);else target.appendChild(el);\n\n    // Init scroll one pixel in to allow upward/leftward scroll\n    el[horizontal ? 'scrollLeft' : 'scrollTop'] = 1;\n    const oldTarget = events.connected || gl.domElement;\n    requestAnimationFrame(() => events.connect == null ? void 0 : events.connect(el));\n    const oldCompute = get().events.compute;\n    setEvents({\n      compute(event, state) {\n        // we are using boundingClientRect because we could not rely on target.offsetTop as canvas could be positioned anywhere in dom\n        const {\n          left,\n          top\n        } = target.getBoundingClientRect();\n        const offsetX = event.clientX - left;\n        const offsetY = event.clientY - top;\n        state.pointer.set(offsetX / state.size.width * 2 - 1, -(offsetY / state.size.height) * 2 + 1);\n        state.raycaster.setFromCamera(state.pointer, state.camera);\n      }\n    });\n    return () => {\n      target.removeChild(el);\n      setEvents({\n        compute: oldCompute\n      });\n      events.connect == null || events.connect(oldTarget);\n    };\n  }, [pages, distance, horizontal, el, fill, fixed, target]);\n  React.useEffect(() => {\n    if (events.connected === el) {\n      const containerLength = size[horizontal ? 'width' : 'height'];\n      const scrollLength = el[horizontal ? 'scrollWidth' : 'scrollHeight'];\n      const scrollThreshold = scrollLength - containerLength;\n      let current = 0;\n      let disableScroll = true;\n      let firstRun = true;\n      const onScroll = () => {\n        // Prevent first scroll because it is indirectly caused by the one pixel offset\n        if (!enabled || firstRun) return;\n        invalidate();\n        current = el[horizontal ? 'scrollLeft' : 'scrollTop'];\n        scroll.current = current / scrollThreshold;\n        if (infinite) {\n          if (!disableScroll) {\n            if (current >= scrollThreshold) {\n              const damp = 1 - state.offset;\n              el[horizontal ? 'scrollLeft' : 'scrollTop'] = 1;\n              scroll.current = state.offset = -damp;\n              disableScroll = true;\n            } else if (current <= 0) {\n              const damp = 1 + state.offset;\n              el[horizontal ? 'scrollLeft' : 'scrollTop'] = scrollLength;\n              scroll.current = state.offset = damp;\n              disableScroll = true;\n            }\n          }\n          if (disableScroll) setTimeout(() => disableScroll = false, 40);\n        }\n      };\n      el.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n      requestAnimationFrame(() => firstRun = false);\n      const onWheel = e => el.scrollLeft += e.deltaY / 2;\n      if (horizontal) el.addEventListener('wheel', onWheel, {\n        passive: true\n      });\n      return () => {\n        el.removeEventListener('scroll', onScroll);\n        if (horizontal) el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [el, events, size, infinite, state, invalidate, horizontal, enabled]);\n  let last = 0;\n  useFrame((_, delta) => {\n    last = state.offset;\n    easing.damp(state, 'offset', scroll.current, damping, delta, maxSpeed, undefined, eps);\n    easing.damp(state, 'delta', Math.abs(last - state.offset), damping, delta, maxSpeed, undefined, eps);\n    if (state.delta > eps) invalidate();\n  });\n  return /*#__PURE__*/React.createElement(context.Provider, {\n    value: state\n  }, children);\n}\nconst ScrollCanvas = /* @__PURE__ */React.forwardRef(({\n  children\n}, ref) => {\n  const group = React.useRef(null);\n  React.useImperativeHandle(ref, () => group.current, []);\n  const state = useScroll();\n  const {\n    width,\n    height\n  } = useThree(state => state.viewport);\n  useFrame(() => {\n    group.current.position.x = state.horizontal ? -width * (state.pages - 1) * state.offset : 0;\n    group.current.position.y = state.horizontal ? 0 : height * (state.pages - 1) * state.offset;\n  });\n  return /*#__PURE__*/React.createElement(\"group\", {\n    ref: group\n  }, children);\n});\nconst ScrollHtml = /*#__PURE__*/React.forwardRef(({\n  children,\n  style,\n  ...props\n}, ref) => {\n  const state = useScroll();\n  const group = React.useRef(null);\n  React.useImperativeHandle(ref, () => group.current, []);\n  const {\n    width,\n    height\n  } = useThree(state => state.size);\n  const fiberState = React.useContext(context$1);\n  const root = React.useMemo(() => ReactDOM.createRoot(state.fixed), [state.fixed]);\n  useFrame(() => {\n    if (state.delta > state.eps) {\n      group.current.style.transform = `translate3d(${state.horizontal ? -width * (state.pages - 1) * state.offset : 0}px,${state.horizontal ? 0 : height * (state.pages - 1) * -state.offset}px,0)`;\n    }\n  });\n  root.render(/*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: group,\n    style: {\n      ...style,\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      willChange: 'transform'\n    }\n  }, props), /*#__PURE__*/React.createElement(context.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(context$1.Provider, {\n    value: fiberState\n  }, children))));\n  return null;\n});\nconst Scroll = /* @__PURE__ */React.forwardRef(({\n  html,\n  ...props\n}, ref) => {\n  const El = html ? ScrollHtml : ScrollCanvas;\n  return /*#__PURE__*/React.createElement(El, _extends({\n    ref: ref\n  }, props));\n});\n\nexport { Scroll, ScrollControls, useScroll };\n","import { a as _isNativeReflectConstruct, _ as _setPrototypeOf } from './isNativeReflectConstruct-5594d075.esm.js';\nimport { Vector2, Matrix4 } from 'three';\nimport { d as determinant3, g as getMinor } from './matrix-baa530bf.esm.js';\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\n/**\n *\n * @param point\n *\n * @param triangle\n *\n * @returns {boolean} true if the point is in the triangle\n *\n * TODO: Find explainer\n */\nfunction isPointInTriangle(point, triangle) {\n  var _triangle$ = _slicedToArray(triangle[0], 2),\n      ax = _triangle$[0],\n      ay = _triangle$[1];\n\n  var _triangle$2 = _slicedToArray(triangle[1], 2),\n      bx = _triangle$2[0],\n      by = _triangle$2[1];\n\n  var _triangle$3 = _slicedToArray(triangle[2], 2),\n      cx = _triangle$3[0],\n      cy = _triangle$3[1];\n\n  var _point = _slicedToArray(point, 2),\n      px = _point[0],\n      py = _point[1]; // TODO Sub with static calc\n\n\n  var matrix = new Matrix4(); // prettier-ignore\n\n  matrix.set(ax, ay, ax * ax + ay * ay, 1, bx, by, bx * bx + by * by, 1, cx, cy, cx * cx + cy * cy, 1, px, py, px * px + py * py, 1);\n  return matrix.determinant() <= 0;\n}\nfunction triangleDeterminant(triangle) {\n  var _triangle$4 = _slicedToArray(triangle[0], 2),\n      x1 = _triangle$4[0],\n      y1 = _triangle$4[1];\n\n  var _triangle$5 = _slicedToArray(triangle[1], 2),\n      x2 = _triangle$5[0],\n      y2 = _triangle$5[1];\n\n  var _triangle$6 = _slicedToArray(triangle[2], 2),\n      x3 = _triangle$6[0],\n      y3 = _triangle$6[1]; // prettier-ignore\n\n\n  return determinant3(x1, y1, 1, x2, y2, 1, x3, y3, 1);\n}\n/**\n * Uses triangle area determinant to check if 3 points are collinear.\n * If they are, they can't make a triangle, so the determinant will be 0!\n *\n *      0     1     2\n * ─────■─────■─────■\n *\n *\n * Fun fact, you can use this same determinant to check the order of the points in the triangle\n *\n * NOTE: Should this use a buffer instead? NOTE: Should this use a buffer instead? [x0, y0, x1, y1, x2, y2]?\n *\n */\n\nfunction arePointsCollinear(points) {\n  return triangleDeterminant(points) === 0;\n} // TODO This is the same principle as the prev function, find a way to make it have sense\n\nfunction isTriangleClockwise(triangle) {\n  return triangleDeterminant(triangle) < 0;\n}\n/**\n \nThe circumcircle is a circle touching all the vertices of a triangle or polygon.\n\n             ┌───┐             \n             │ B │             \n             └───┘             \n           .───●───.           \n        ,─'   ╱ ╲   '─.        \n      ,'     ╱   ╲     `.      \n     ╱      ╱     ╲      ╲     \n    ;      ╱       ╲      :    \n    │     ╱         ╲     │    \n    │    ╱           ╲    │    \n    :   ╱             ╲   ;    \n     ╲ ╱               ╲ ╱     \n┌───┐ ●─────────────────● ┌───┐\n│ A │  `.             ,'  │ C │\n└───┘    '─.       ,─'    └───┘\n            `─────'                         \n */\n\n/**\n *\n * @param triangle\n *\n * @returns {number} circumcircle\n */\n// https://math.stackexchange.com/a/1460096\n\nfunction getCircumcircle(triangle) {\n  // TS-TODO the next few lines are ignored because the types aren't current to the change in vectors (that can now be iterated)\n  // @ts-ignore\n  var _triangle$7 = _slicedToArray(triangle[0], 2),\n      ax = _triangle$7[0],\n      ay = _triangle$7[1]; // @ts-ignore\n\n\n  var _triangle$8 = _slicedToArray(triangle[1], 2),\n      bx = _triangle$8[0],\n      by = _triangle$8[1]; // @ts-ignore\n\n\n  var _triangle$9 = _slicedToArray(triangle[2], 2),\n      cx = _triangle$9[0],\n      cy = _triangle$9[1];\n\n  if (arePointsCollinear(triangle)) return null; // points are collinear\n\n  var m = new Matrix4(); // prettier-ignore\n\n  m.set(1, 1, 1, 1, ax * ax + ay * ay, ax, ay, 1, bx * bx + by * by, bx, by, 1, cx * cx + cy * cy, cx, cy, 1);\n  var m11 = getMinor(m, 1, 1);\n  var m13 = getMinor(m, 1, 3);\n  var m12 = getMinor(m, 1, 2);\n  var m14 = getMinor(m, 1, 4);\n  var x0 = 0.5 * (m12 / m11);\n  var y0 = 0.5 * (m13 / m11);\n  var r2 = x0 * x0 + y0 * y0 + m14 / m11;\n  return {\n    x: Math.abs(x0) === 0 ? 0 : x0,\n    y: Math.abs(y0) === 0 ? 0 : -y0,\n    r: Math.sqrt(r2)\n  };\n} // https://stackoverflow.com/questions/39984709/how-can-i-check-wether-a-point-is-inside-the-circumcircle-of-3-points\n\nfunction isPointInCircumcircle(point, triangle) {\n  var _ref = Array.isArray(triangle[0]) ? triangle[0] : triangle[0].toArray(),\n      _ref2 = _slicedToArray(_ref, 2),\n      ax = _ref2[0],\n      ay = _ref2[1];\n\n  var _ref3 = Array.isArray(triangle[1]) ? triangle[1] : triangle[1].toArray(),\n      _ref4 = _slicedToArray(_ref3, 2),\n      bx = _ref4[0],\n      by = _ref4[1];\n\n  var _ref5 = Array.isArray(triangle[2]) ? triangle[2] : triangle[2].toArray(),\n      _ref6 = _slicedToArray(_ref5, 2),\n      cx = _ref6[0],\n      cy = _ref6[1];\n\n  var _point2 = _slicedToArray(point, 2),\n      px = _point2[0],\n      py = _point2[1];\n\n  if (arePointsCollinear(triangle)) throw new Error(\"Collinear points don't form a triangle\");\n  /**\n          | ax-px, ay-py, (ax-px)² + (ay-py)² |\n    det = | bx-px, by-py, (bx-px)² + (by-py)² |\n          | cx-px, cy-py, (cx-px)² + (cy-py)² |\n  */\n\n  var x1mpx = ax - px;\n  var aympy = ay - py;\n  var bxmpx = bx - px;\n  var bympy = by - py;\n  var cxmpx = cx - px;\n  var cympy = cy - py; // prettier-ignore\n\n  var d = determinant3(x1mpx, aympy, x1mpx * x1mpx + aympy * aympy, bxmpx, bympy, bxmpx * bxmpx + bympy * bympy, cxmpx, cympy, cxmpx * cxmpx + cympy * cympy); // if d is 0, the point is on C\n\n  if (d === 0) {\n    return true;\n  }\n\n  return !isTriangleClockwise(triangle) ? d > 0 : d < 0;\n} // From https://algorithmtutor.com/Computational-Geometry/Determining-if-two-consecutive-segments-turn-left-or-right/\n\nvar mv1 = new Vector2();\nvar mv2 = new Vector2();\n/**\n \n     ╱      ╲     \n    ╱        ╲    \n   ▕          ▏   \n                  \n right      left  \n\n * NOTE: Should this use a buffer instead? [x0, y0, x1, y1]?\n */\n\nfunction doThreePointsMakeARight(points) {\n  var _points$map = points.map(function (p) {\n    if (Array.isArray(p)) {\n      return _construct(Vector2, _toConsumableArray(p));\n    }\n\n    return p;\n  }),\n      _points$map2 = _slicedToArray(_points$map, 3),\n      p1 = _points$map2[0],\n      p2 = _points$map2[1],\n      p3 = _points$map2[2];\n\n  if (arePointsCollinear(points)) return false; // @ts-ignore\n\n  var p2p1 = mv1.subVectors(p2, p1); // @ts-ignore\n\n  var p3p1 = mv2.subVectors(p3, p1);\n  var cross = p3p1.cross(p2p1);\n  return cross > 0;\n}\n\nvar triangle = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  isPointInTriangle: isPointInTriangle,\n  triangleDeterminant: triangleDeterminant,\n  arePointsCollinear: arePointsCollinear,\n  isTriangleClockwise: isTriangleClockwise,\n  getCircumcircle: getCircumcircle,\n  isPointInCircumcircle: isPointInCircumcircle,\n  doThreePointsMakeARight: doThreePointsMakeARight\n});\n\nexport { _slicedToArray as _, _toConsumableArray as a, triangleDeterminant as b, arePointsCollinear as c, doThreePointsMakeARight as d, isTriangleClockwise as e, isPointInCircumcircle as f, getCircumcircle as g, isPointInTriangle as i, triangle as t };\n","import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry'\n\nclass LineGeometry extends LineSegmentsGeometry {\n  constructor() {\n    super()\n\n    this.isLineGeometry = true\n\n    this.type = 'LineGeometry'\n  }\n\n  setPositions(array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n\n    const length = array.length - 3\n    const points = new Float32Array(2 * length)\n\n    for (let i = 0; i < length; i += 3) {\n      points[2 * i] = array[i]\n      points[2 * i + 1] = array[i + 1]\n      points[2 * i + 2] = array[i + 2]\n\n      points[2 * i + 3] = array[i + 3]\n      points[2 * i + 4] = array[i + 4]\n      points[2 * i + 5] = array[i + 5]\n    }\n\n    super.setPositions(points)\n\n    return this\n  }\n\n  setColors(array, itemSize = 3) {\n    // converts [ r1, g1, b1, (a1),  r2, g2, b2, (a2), ... ] to pairs format\n\n    const length = array.length - itemSize\n    const colors = new Float32Array(2 * length)\n\n    if (itemSize === 3) {\n      for (let i = 0; i < length; i += itemSize) {\n        colors[2 * i] = array[i]\n        colors[2 * i + 1] = array[i + 1]\n        colors[2 * i + 2] = array[i + 2]\n\n        colors[2 * i + 3] = array[i + 3]\n        colors[2 * i + 4] = array[i + 4]\n        colors[2 * i + 5] = array[i + 5]\n      }\n    } else {\n      for (let i = 0; i < length; i += itemSize) {\n        colors[2 * i] = array[i]\n        colors[2 * i + 1] = array[i + 1]\n        colors[2 * i + 2] = array[i + 2]\n        colors[2 * i + 3] = array[i + 3]\n\n        colors[2 * i + 4] = array[i + 4]\n        colors[2 * i + 5] = array[i + 5]\n        colors[2 * i + 6] = array[i + 6]\n        colors[2 * i + 7] = array[i + 7]\n      }\n    }\n\n    super.setColors(colors, itemSize)\n\n    return this\n  }\n\n  fromLine(line) {\n    const geometry = line.geometry\n\n    this.setPositions(geometry.attributes.position.array) // assumes non-indexed\n\n    // set colors, maybe\n\n    return this\n  }\n}\n\nexport { LineGeometry }\n","import { version } from \"./constants\";\n\n/** uv2 renamed to uv1 in r125\n * \n * https://github.com/mrdoob/three.js/pull/25943\n*/\nexport const UV1 = version >= 125 ? 'uv1' : 'uv2'","import {\n  Box3,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry,\n} from 'three'\n\nconst _box = /* @__PURE__ */ new Box3()\nconst _vector = /* @__PURE__ */ new Vector3()\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n  constructor() {\n    super()\n\n    this.isLineSegmentsGeometry = true\n\n    this.type = 'LineSegmentsGeometry'\n\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0]\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2]\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]\n\n    this.setIndex(index)\n    this.setAttribute('position', new Float32BufferAttribute(positions, 3))\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n  }\n\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix)\n\n      end.applyMatrix4(matrix)\n\n      start.needsUpdate = true\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox()\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere()\n    }\n\n    return this\n  }\n\n  setPositions(array) {\n    let lineSegments\n\n    if (array instanceof Float32Array) {\n      lineSegments = array\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array)\n    }\n\n    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1) // xyz, xyz\n\n    this.setAttribute('instanceStart', new InterleavedBufferAttribute(instanceBuffer, 3, 0)) // xyz\n    this.setAttribute('instanceEnd', new InterleavedBufferAttribute(instanceBuffer, 3, 3)) // xyz\n\n    //\n\n    this.computeBoundingBox()\n    this.computeBoundingSphere()\n\n    return this\n  }\n\n  setColors(array, itemSize = 3) {\n    let colors\n\n    if (array instanceof Float32Array) {\n      colors = array\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array)\n    }\n\n    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, itemSize * 2, 1) // rgb(a), rgb(a)\n\n    this.setAttribute('instanceColorStart', new InterleavedBufferAttribute(instanceColorBuffer, itemSize, 0)) // rgb(a)\n    this.setAttribute('instanceColorEnd', new InterleavedBufferAttribute(instanceColorBuffer, itemSize, itemSize)) // rgb(a)\n\n    return this\n  }\n\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array)\n\n    return this\n  }\n\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array)\n\n    return this\n  }\n\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry))\n\n    // set colors, maybe\n\n    return this\n  }\n\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry\n\n    this.setPositions(geometry.attributes.position.array) // assumes non-indexed\n\n    // set colors, maybe\n\n    return this\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3()\n    }\n\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start)\n\n      _box.setFromBufferAttribute(end)\n\n      this.boundingBox.union(_box)\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere()\n    }\n\n    if (this.boundingBox === null) {\n      this.computeBoundingBox()\n    }\n\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center\n\n      this.boundingBox.getCenter(center)\n\n      let maxRadiusSq = 0\n\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i)\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector))\n\n        _vector.fromBufferAttribute(end, i)\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector))\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq)\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error(\n          'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.',\n          this,\n        )\n      }\n    }\n  }\n\n  toJSON() {\n    // todo\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().')\n\n    return this.applyMatrix4(matrix)\n  }\n}\n\nexport { LineSegmentsGeometry }\n","import { Vector3, Vector2 } from 'three';\n\n/**\n * Helpers for converting buffers to and from Three.js objects\n */\n\n/**\n * Convents passed buffer of passed stride to an array of vectors with the correct length.\n *\n * @param buffer\n * @param stride\n * @returns\n */\nfunction bufferToVectors(buffer) {\n  var stride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  var p = [];\n\n  for (var i = 0, j = 0; i < buffer.length; i += stride, j++) {\n    if (stride === 3) {\n      p[j] = new Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);\n    } else {\n      p[j] = new Vector2(buffer[i], buffer[i + 1]);\n    }\n  }\n\n  return p;\n}\n/**\n * Transforms a passed Vector2 or Vector3 array to a points buffer\n *\n * @param vectorArray\n * @returns\n */\n\nfunction vectorsToBuffer(vectorArray) {\n  var l = vectorArray.length;\n  var stride = vectorArray[0].hasOwnProperty(\"z\") ? 3 : 2;\n  var buffer = new Float32Array(l * stride);\n\n  for (var i = 0; i < l; i++) {\n    var j = i * stride;\n    buffer[j] = vectorArray[i].x;\n    buffer[j + 1] = vectorArray[i].y;\n\n    if (stride === 3) {\n      buffer[j + 2] = vectorArray[i].z;\n    }\n  }\n\n  return buffer;\n}\n\nvar three = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  bufferToVectors: bufferToVectors,\n  vectorsToBuffer: vectorsToBuffer\n});\n\nexport { bufferToVectors as b, three as t, vectorsToBuffer as v };\n","import { Matrix3 } from 'three';\n\n/**\n *\n * @param terms\n *\n * | a b |\n * | c d |\n *\n * @returns {number} determinant\n */\n\nfunction determinant2() {\n  for (var _len = arguments.length, terms = new Array(_len), _key = 0; _key < _len; _key++) {\n    terms[_key] = arguments[_key];\n  }\n\n  var a = terms[0],\n      b = terms[1],\n      c = terms[2],\n      d = terms[3];\n  return a * d - b * c;\n}\n/**\n *\n * @param terms\n *\n * | a b c |\n * | d e f |\n * | g h i |\n *\n * @returns {number} determinant\n */\n\nfunction determinant3() {\n  for (var _len2 = arguments.length, terms = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    terms[_key2] = arguments[_key2];\n  }\n\n  var a = terms[0],\n      b = terms[1],\n      c = terms[2],\n      d = terms[3],\n      e = terms[4],\n      f = terms[5],\n      g = terms[6],\n      h = terms[7],\n      i = terms[8];\n  return a * e * i + b * f * g + c * d * h - c * e * g - b * d * i - a * f * h;\n}\n/**\n *\n * @param terms\n *\n * | a b c g |\n * | h i j k |\n * | l m n o |\n *\n * @returns {number} determinant\n */\n\nfunction determinant4() {\n  for (var _len3 = arguments.length, terms = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    terms[_key3] = arguments[_key3];\n  }\n\n  terms[0];\n      terms[1];\n      terms[2];\n      terms[3];\n      terms[4];\n      terms[5];\n      terms[6];\n      terms[7];\n      terms[8];\n      terms[9];\n      terms[10];\n      terms[11];\n      terms[12];\n      terms[13];\n      terms[14]; // TODO\n}\n/**\n *\n * Get the determinant of matrix m without row r and col c\n *\n * @param {matrix} m Starter matrix\n * @param r row to remove\n * @param c col to remove\n *\n *     | a b c |\n * m = | d e f |\n *     | g h i |\n *\n * getMinor(m, 1, 1) would result in this determinant\n *\n * | a c |\n * | g i |\n *\n * @returns {number} determinant\n */\n\nfunction getMinor(matrix, r, c) {\n  var _matrixTranspose = matrix.clone().transpose();\n\n  var x = [];\n  var l = _matrixTranspose.elements.length;\n  var n = Math.sqrt(l);\n\n  for (var i = 0; i < l; i++) {\n    var element = _matrixTranspose.elements[i];\n    var row = Math.floor(i / n);\n    var col = i % n;\n\n    if (row !== r - 1 && col !== c - 1) {\n      x.push(element);\n    }\n  }\n\n  return determinant3.apply(void 0, x);\n}\n/**\n *\n */\n\nfunction matrixSum3(m1, m2) {\n  var sum = [];\n  var m1Array = m1.toArray();\n  var m2Array = m2.toArray();\n\n  for (var i = 0; i < m1Array.length; i++) {\n    sum[i] = m1Array[i] + m2Array[i];\n  }\n\n  return new Matrix3().fromArray(sum);\n}\n\nvar matrix = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  determinant2: determinant2,\n  determinant3: determinant3,\n  determinant4: determinant4,\n  getMinor: getMinor,\n  matrixSum3: matrixSum3\n});\n\nexport { matrixSum3 as a, determinant2 as b, determinant4 as c, determinant3 as d, getMinor as g, matrix as m };\n","/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n * }\n */\n\nimport { ShaderMaterial, UniformsLib, UniformsUtils, Vector2 } from 'three'\nimport { version } from '../_polyfill/constants'\n\nclass LineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: 'LineMaterial',\n\n      uniforms: UniformsUtils.clone(\n        UniformsUtils.merge([\n          UniformsLib.common,\n          UniformsLib.fog,\n          {\n            worldUnits: { value: 1 },\n            linewidth: { value: 1 },\n            resolution: { value: new Vector2(1, 1) },\n            dashOffset: { value: 0 },\n            dashScale: { value: 1 },\n            dashSize: { value: 1 },\n            gapSize: { value: 1 }, // todo FIX - maybe change to totalSize\n          },\n        ]),\n      ),\n\n      vertexShader: /* glsl */ `\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\n\t\t\t\tuniform float linewidth;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tattribute vec3 instanceStart;\n\t\t\t\tattribute vec3 instanceEnd;\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t\tattribute vec4 instanceColorStart;\n\t\t\t\t\t\tattribute vec4 instanceColorEnd;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t\tattribute vec3 instanceColorStart;\n\t\t\t\t\t\tattribute vec3 instanceColorEnd;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashScale;\n\t\t\t\t\tattribute float instanceDistanceStart;\n\t\t\t\t\tattribute float instanceDistanceEnd;\n\t\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#endif\n\n\t\t\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t\t\t// conservative estimate of the near plane\n\t\t\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#ifdef USE_COLOR\n\n\t\t\t\t\t\tvLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t\t\t// camera space\n\t\t\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\tworldStart = start.xyz;\n\t\t\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\t\t\tif ( perspective ) {\n\n\t\t\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// clip space\n\t\t\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t\t\t// ndc space\n\t\t\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t\t\t// direction\n\t\t\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t\t\t// account for clip-space aspect ratio\n\t\t\t\t\tdir.x *= aspect;\n\t\t\t\t\tdir = normalize( dir );\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\t\t\tvec3 offset;\n\t\t\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t\t\t// set the world position\n\t\t\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t\t\t// project the worldpos\n\t\t\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t\t\t// segments overlap neatly\n\t\t\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\t\t\tdir.x /= aspect;\n\t\t\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t\t\t// sign flip\n\t\t\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t\t\t// endcaps\n\t\t\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\t\t\toffset += - dir;\n\n\t\t\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\t\t\toffset += dir;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// adjust for linewidth\n\t\t\t\t\t\toffset *= linewidth;\n\n\t\t\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t\t\t// select end\n\t\t\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t\t\t// back to clip space\n\t\t\t\t\t\toffset *= clip.w;\n\n\t\t\t\t\t\tclip.xy += offset;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_Position = clip;\n\n\t\t\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n      fragmentShader: /* glsl */ `\n\t\t\t\tuniform vec3 diffuse;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform float linewidth;\n\n\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\tuniform float dashOffset;\n\t\t\t\t\tuniform float dashSize;\n\t\t\t\t\tuniform float gapSize;\n\n\t\t\t\t#endif\n\n\t\t\t\tvarying float vLineDistance;\n\n\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\tvarying vec4 worldPos;\n\t\t\t\t\tvarying vec3 worldStart;\n\t\t\t\t\tvarying vec3 worldEnd;\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#else\n\n\t\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#endif\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <clipping_planes_pars_fragment>\n\n\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\tvarying vec4 vLineColor;\n\t\t\t\t\t#else\n\t\t\t\t\t\tvarying vec3 vLineColor;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\t\t\tfloat mua;\n\t\t\t\t\tfloat mub;\n\n\t\t\t\t\tvec3 p13 = p1 - p3;\n\t\t\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\t\t\tmua = numer / denom;\n\t\t\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\t\t\treturn vec2( mua, mub );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t\t\t#ifdef USE_DASH\n\n\t\t\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat alpha = opacity;\n\n\t\t\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\t\t\tfloat len = length( delta );\n\t\t\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\t\t\t\t\t#ifdef USE_COLOR\n\t\t\t\t\t\t#ifdef USE_LINE_COLOR_ALPHA\n\t\t\t\t\t\t\tdiffuseColor *= vLineColor;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tdiffuseColor.rgb *= vLineColor;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\t\t\tgl_FragColor = diffuseColor;\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t`,\n      clipping: true, // required for clipping support\n    })\n\n    this.isLineMaterial = true\n\n    this.onBeforeCompile = function () {\n      if (this.transparent) {\n        this.defines.USE_LINE_COLOR_ALPHA = '1'\n      } else {\n        delete this.defines.USE_LINE_COLOR_ALPHA\n      }\n    }\n\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.diffuse.value\n        },\n\n        set: function (value) {\n          this.uniforms.diffuse.value = value\n        },\n      },\n\n      worldUnits: {\n        enumerable: true,\n\n        get: function () {\n          return 'WORLD_UNITS' in this.defines\n        },\n\n        set: function (value) {\n          if (value === true) {\n            this.defines.WORLD_UNITS = ''\n          } else {\n            delete this.defines.WORLD_UNITS\n          }\n        },\n      },\n\n      linewidth: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.linewidth.value\n        },\n\n        set: function (value) {\n          this.uniforms.linewidth.value = value\n        },\n      },\n\n      dashed: {\n        enumerable: true,\n\n        get: function () {\n          return Boolean('USE_DASH' in this.defines)\n        },\n\n        set(value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true\n          }\n\n          if (value === true) {\n            this.defines.USE_DASH = ''\n          } else {\n            delete this.defines.USE_DASH\n          }\n        },\n      },\n\n      dashScale: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.dashScale.value\n        },\n\n        set: function (value) {\n          this.uniforms.dashScale.value = value\n        },\n      },\n\n      dashSize: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.dashSize.value\n        },\n\n        set: function (value) {\n          this.uniforms.dashSize.value = value\n        },\n      },\n\n      dashOffset: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.dashOffset.value\n        },\n\n        set: function (value) {\n          this.uniforms.dashOffset.value = value\n        },\n      },\n\n      gapSize: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.gapSize.value\n        },\n\n        set: function (value) {\n          this.uniforms.gapSize.value = value\n        },\n      },\n\n      opacity: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.opacity.value\n        },\n\n        set: function (value) {\n          this.uniforms.opacity.value = value\n        },\n      },\n\n      resolution: {\n        enumerable: true,\n\n        get: function () {\n          return this.uniforms.resolution.value\n        },\n\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value)\n        },\n      },\n\n      alphaToCoverage: {\n        enumerable: true,\n\n        get: function () {\n          return Boolean('USE_ALPHA_TO_COVERAGE' in this.defines)\n        },\n\n        set: function (value) {\n          if (Boolean(value) !== Boolean('USE_ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true\n          }\n\n          if (value === true) {\n            this.defines.USE_ALPHA_TO_COVERAGE = ''\n            this.extensions.derivatives = true\n          } else {\n            delete this.defines.USE_ALPHA_TO_COVERAGE\n            this.extensions.derivatives = false\n          }\n        },\n      },\n    })\n\n    this.setValues(parameters)\n  }\n}\n\nexport { LineMaterial }\n","import { LineSegments2 } from '../lines/LineSegments2'\nimport { LineGeometry } from '../lines/LineGeometry'\nimport { LineMaterial } from '../lines/LineMaterial'\n\nclass Line2 extends LineSegments2 {\n  constructor(geometry = new LineGeometry(), material = new LineMaterial({ color: Math.random() * 0xffffff })) {\n    super(geometry, material)\n\n    this.isLine2 = true\n\n    this.type = 'Line2'\n  }\n}\n\nexport { Line2 }\n","import { d as doThreePointsMakeARight, a as _toConsumableArray, _ as _slicedToArray } from './triangle-b62b9067.esm.js';\nimport { Vector3, Matrix3 } from 'three';\nimport { a as matrixSum3 } from './matrix-baa530bf.esm.js';\n\n/**\n * Clamps a value between a range.\n */\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n} // Loops the value t, so that it is never larger than length and never smaller than 0.\n\nfunction repeat(t, length) {\n  return clamp(t - Math.floor(t / length) * length, 0, length);\n} // Calculates the shortest difference between two given angles.\n\nfunction deltaAngle(current, target) {\n  var delta = repeat(target - current, Math.PI * 2);\n  if (delta > Math.PI) delta -= Math.PI * 2;\n  return delta;\n}\n/**\n * Converts degrees to radians.\n */\n\nfunction degToRad(degrees) {\n  return degrees / 180 * Math.PI;\n}\n/**\n * Converts radians to degrees.\n */\n\nfunction radToDeg(radians) {\n  return radians * 180 / Math.PI;\n} // adapted from https://gist.github.com/stephanbogner/a5f50548a06bec723dcb0991dcbb0856 by https://twitter.com/st_phan\n\nfunction fibonacciOnSphere(buffer, _ref) {\n  var _ref$radius = _ref.radius,\n      radius = _ref$radius === void 0 ? 1 : _ref$radius;\n  var samples = buffer.length / 3;\n  var offset = 2 / samples;\n  var increment = Math.PI * (3 - 2.2360679775);\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    var y = i * offset - 1 + offset / 2;\n    var distance = Math.sqrt(1 - Math.pow(y, 2));\n    var phi = i % samples * increment;\n    var x = Math.cos(phi) * distance;\n    var z = Math.sin(phi) * distance;\n    buffer[i] = x * radius;\n    buffer[i + 1] = y * radius;\n    buffer[i + 2] = z * radius;\n  }\n} // @ts-ignore\n\nfunction vectorEquals(a, b) {\n  var eps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.EPSILON;\n  return Math.abs(a.x - b.x) < eps && Math.abs(a.y - b.y) < eps && Math.abs(a.z - b.z) < eps;\n}\n/**\n * Sorts vectors in lexicographic order, works with both v2 and v3\n *\n *  Use as:\n *  const sorted = arrayOfVectors.sort(lexicographicOrder)\n */\n// https://en.wikipedia.org/wiki/Lexicographic_order\n\nfunction lexicographic(a, b) {\n  if (a.x === b.x) {\n    // do a check to see if points is 3D,\n    // in which case add y eq check and sort by z\n    if (typeof a.z !== \"undefined\") {\n      if (a.y === b.y) {\n        return a.z - b.z;\n      }\n    }\n\n    return a.y - b.y;\n  }\n\n  return a.x - b.x;\n}\n/**\n * Convex Hull\n *\n * Returns an array of 2D Vectors representing the convex hull of a set of 2D Vectors\n */\n\n/**\n * Calculate the convex hull of a set of points\n */\n\nfunction convexHull(_points) {\n  var points = _points.sort(lexicographic); // put p1 and p2 in a list lUpper with p1 as the first point\n\n\n  var lUpper = [points[0], points[1]]; // for i <- 3 to n\n\n  for (var i = 2; i < points.length; i++) {\n    lUpper.push(points[i]); // while lUpper contains more than 2 points and the last three points in lUpper do not make a right turn\n\n    while (lUpper.length > 2 && doThreePointsMakeARight(_toConsumableArray(lUpper.slice(-3)))) {\n      // delete the middle of the last three points from lUpper\n      lUpper.splice(lUpper.length - 2, 1);\n    }\n  } // put pn and pn-1 in a list lLower with pn as the first point\n\n\n  var lLower = [points[points.length - 1], points[points.length - 2]]; // for (i <- n - 2 downto 1)\n\n  for (var _i = points.length - 3; _i >= 0; _i--) {\n    // append pi to lLower\n    lLower.push(points[_i]); // while lLower contains more than 2 points and the last three points in lLower do not make a right turn\n\n    while (lLower.length > 2 && doThreePointsMakeARight(_toConsumableArray(lLower.slice(-3)))) {\n      // delete the middle of the last three points from lLower\n      lLower.splice(lLower.length - 2, 1);\n    }\n  } // remove the first and last point from lLower to avoid duplication of the points where the upper and lower hull meet\n\n\n  lLower.splice(0, 1);\n  lLower.splice(lLower.length - 1, 1); // prettier-ignore\n\n  var c = [].concat(lUpper, lLower);\n  return c;\n}\nfunction remap(x, _ref2, _ref3) {\n  var _ref4 = _slicedToArray(_ref2, 2),\n      low1 = _ref4[0],\n      high1 = _ref4[1];\n\n  var _ref5 = _slicedToArray(_ref3, 2),\n      low2 = _ref5[0],\n      high2 = _ref5[1];\n\n  return low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n/**\n *\n * https://www.desmos.com/calculator/vsnmlaljdu\n *\n * Ease-in-out, goes to -Infinite before 0 and Infinite after 1\n *\n * @param t\n * @returns\n */\n\nfunction fade(t) {\n  return t * t * t * (t * (t * 6 - 15) + 10);\n}\n/**\n *\n * Returns the result of linearly interpolating between input A and input B by input T.\n *\n * @param v0\n * @param v1\n * @param t\n * @returns\n */\n\nfunction lerp(v0, v1, t) {\n  return v0 * (1 - t) + v1 * t;\n}\n/**\n *\n * Returns the linear parameter that produces the interpolant specified by input T within the range of input A to input B.\n *\n * @param v0\n * @param v1\n * @param t\n * @returns\n */\n\nfunction inverseLerp(v0, v1, t) {\n  return (t - v0) / (v1 - v0);\n}\n/**\n *\n */\n\nfunction normalize(x, y, z) {\n  var m = Math.sqrt(x * x + y * y + z * z);\n  return [x / m, y / m, z / m];\n}\n/**\n *\n */\n\nfunction pointOnCubeToPointOnSphere(x, y, z) {\n  var x2 = x * x;\n  var y2 = y * y;\n  var z2 = z * z;\n  var nx = x * Math.sqrt(1 - (y2 + z2) / 2 + y2 * z2 / 3);\n  var ny = y * Math.sqrt(1 - (z2 + x2) / 2 + z2 * x2 / 3);\n  var nz = z * Math.sqrt(1 - (x2 + y2) / 2 + x2 * y2 / 3);\n  return [nx, ny, nz];\n} // https://math.stackexchange.com/questions/180418/calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d\n\n/**\n * Give two unit vectors a and b, returns the transformation matrix that rotates a onto b.\n *\n * */\n\nfunction rotateVectorOnVector(a, b) {\n  var v = new Vector3().crossVectors(a, b);\n  var c = a.dot(b);\n  var i = new Matrix3().identity(); //  skew-symmetric cross-product matrix of 𝑣 https://en.wikipedia.org/wiki/Skew-symmetric_matrix\n  // prettier-ignore\n\n  var vx = new Matrix3().set(0, -v.z, v.y, v.z, 0, -v.x, -v.y, v.x, 0);\n  var vxsquared = new Matrix3().multiplyMatrices(vx, vx).multiplyScalar(1 / (1 + c));\n\n  var _final = matrixSum3(matrixSum3(i, vx), vxsquared);\n\n  return _final;\n} // calculate latitude and longitude (in radians) from point on unit sphere\n\nfunction pointToCoordinate(x, y, z) {\n  var lat = Math.asin(y);\n  var lon = Math.atan2(x, -z);\n  return [lat, lon];\n} // calculate point on unit sphere given latitude and logitude in radians\n\nfunction coordinateToPoint(lat, lon) {\n  var y = Math.sin(lat);\n  var r = Math.cos(lat);\n  var x = Math.sin(lon) * r;\n  var z = -Math.cos(lon) * r;\n  return [x, y, z];\n}\n/**\n * Given a plane and a segment, return the intersection point if it exists or null it doesn't.\n */\n\nfunction planeSegmentIntersection(plane, segment) {\n  var _segment = _slicedToArray(segment, 2),\n      a = _segment[0],\n      b = _segment[1];\n\n  var matrix = rotateVectorOnVector(plane.normal, new Vector3(0, 1, 0));\n  var t = inverseLerp(a.clone().applyMatrix3(matrix).y, b.clone().applyMatrix3(matrix).y, 0);\n  return new Vector3().lerpVectors(a, b, t);\n}\n/**\n * Given a plane and a point, return the distance.\n */\n\nfunction pointToPlaneDistance(p, plane) {\n  var d = plane.normal.dot(p); // TODO\n\n  return d;\n}\nfunction getIndexFrom3D(coords, sides) {\n  var _coords = _slicedToArray(coords, 3),\n      ix = _coords[0],\n      iy = _coords[1],\n      iz = _coords[2];\n\n  var _sides = _slicedToArray(sides, 2),\n      rx = _sides[0],\n      ry = _sides[1];\n\n  return iz * rx * ry + iy * rx + ix;\n}\nfunction get3DFromIndex(index, size) {\n  var _size = _slicedToArray(size, 2),\n      rx = _size[0],\n      ry = _size[1];\n\n  var a = rx * ry;\n  var z = index / a;\n  var b = index - a * z;\n  var y = b / rx;\n  var x = b % rx;\n  return [x, y, z];\n}\nfunction getIndexFrom2D(coords, size) {\n  return coords[0] + size[0] * coords[1];\n}\nfunction get2DFromIndex(index, columns) {\n  var x = index % columns;\n  var y = Math.floor(index / columns);\n  return [x, y];\n}\n\nvar misc = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  clamp: clamp,\n  repeat: repeat,\n  deltaAngle: deltaAngle,\n  degToRad: degToRad,\n  radToDeg: radToDeg,\n  fibonacciOnSphere: fibonacciOnSphere,\n  vectorEquals: vectorEquals,\n  lexicographic: lexicographic,\n  convexHull: convexHull,\n  remap: remap,\n  fade: fade,\n  lerp: lerp,\n  inverseLerp: inverseLerp,\n  normalize: normalize,\n  pointOnCubeToPointOnSphere: pointOnCubeToPointOnSphere,\n  rotateVectorOnVector: rotateVectorOnVector,\n  pointToCoordinate: pointToCoordinate,\n  coordinateToPoint: coordinateToPoint,\n  planeSegmentIntersection: planeSegmentIntersection,\n  pointToPlaneDistance: pointToPlaneDistance,\n  getIndexFrom3D: getIndexFrom3D,\n  get3DFromIndex: get3DFromIndex,\n  getIndexFrom2D: getIndexFrom2D,\n  get2DFromIndex: get2DFromIndex\n});\n\nexport { degToRad as a, radToDeg as b, clamp as c, deltaAngle as d, fibonacciOnSphere as e, fade as f, lexicographic as g, convexHull as h, remap as i, inverseLerp as j, rotateVectorOnVector as k, lerp as l, misc as m, normalize as n, pointToCoordinate as o, pointOnCubeToPointOnSphere as p, coordinateToPoint as q, repeat as r, planeSegmentIntersection as s, pointToPlaneDistance as t, getIndexFrom3D as u, vectorEquals as v, get3DFromIndex as w, getIndexFrom2D as x, get2DFromIndex as y };\n","import { a as _defineProperty, _ as _objectSpread2 } from './objectSpread2-284232a6.esm.js';\nimport { _ as _classCallCheck } from './classCallCheck-9098b006.esm.js';\nimport { l as lerp, f as fade } from './misc-19a3ec46.esm.js';\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/*\n * A speed-improved perlin and simplex noise algorithms for 2D.\n *\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n * Converted to Javascript by Joseph Gentle.\n *\n * Version 2012-03-09\n *\n * This code was placed in the public domain by its original author,\n * Stefan Gustavson. You may use it as you see fit, but\n * attribution is appreciated.\n *\n */\n\nvar Grad = function Grad(x, y, z) {\n  var _this = this;\n\n  _classCallCheck(this, Grad);\n\n  _defineProperty(this, \"dot2\", function (x, y) {\n    return _this.x * x + _this.y * y;\n  });\n\n  _defineProperty(this, \"dot3\", function (x, y, z) {\n    return _this.x * x + _this.y * y + _this.z * z;\n  });\n\n  this.x = x;\n  this.y = y;\n  this.z = z;\n};\n\nvar grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0), new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1), new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];\nvar p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]; // To remove the need for index wrapping, double the permutation table length\n\nvar perm = new Array(512);\nvar gradP = new Array(512); // This isn't a very good seeding function, but it works ok. It supports 2^16\n// different seed values. Write something better if you need more seeds.\n\nvar seed = function seed(_seed) {\n  if (_seed > 0 && _seed < 1) {\n    // Scale the seed out\n    _seed *= 65536;\n  }\n\n  _seed = Math.floor(_seed);\n\n  if (_seed < 256) {\n    _seed |= _seed << 8;\n  }\n\n  for (var i = 0; i < 256; i++) {\n    var v;\n\n    if (i & 1) {\n      v = p[i] ^ _seed & 255;\n    } else {\n      v = p[i] ^ _seed >> 8 & 255;\n    }\n\n    perm[i] = perm[i + 256] = v;\n    gradP[i] = gradP[i + 256] = grad3[v % 12];\n  }\n};\nseed(0);\n/*\n  for(var i=0; i<256; i++) {\n    perm[i] = perm[i + 256] = p[i];\n    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\n  }*/\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\n\nvar F2 = 0.5 * (Math.sqrt(3) - 1);\nvar G2 = (3 - Math.sqrt(3)) / 6;\nvar F3 = 1 / 3;\nvar G3 = 1 / 6; // 2D simplex noise\n\nvar simplex2 = function simplex2(xin, yin) {\n  var n0, n1, n2; // Noise contributions from the three corners\n  // Skew the input space to determine which simplex cell we're in\n\n  var s = (xin + yin) * F2; // Hairy factor for 2D\n\n  var i = Math.floor(xin + s);\n  var j = Math.floor(yin + s);\n  var t = (i + j) * G2;\n  var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n\n  var y0 = yin - j + t; // For the 2D case, the simplex shape is an equilateral triangle.\n  // Determine which simplex we are in.\n\n  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\n  if (x0 > y0) {\n    // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n    i1 = 1;\n    j1 = 0;\n  } else {\n    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n    i1 = 0;\n    j1 = 1;\n  } // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n  // c = (3-sqrt(3))/6\n\n\n  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\n  var y1 = y0 - j1 + G2;\n  var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n\n  var y2 = y0 - 1 + 2 * G2; // Work out the hashed gradient indices of the three simplex corners\n\n  i &= 255;\n  j &= 255;\n  var gi0 = gradP[i + perm[j]];\n  var gi1 = gradP[i + i1 + perm[j + j1]];\n  var gi2 = gradP[i + 1 + perm[j + 1]]; // Calculate the contribution from the three corners\n\n  var t0 = 0.5 - x0 * x0 - y0 * y0;\n\n  if (t0 < 0) {\n    n0 = 0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient\n  }\n\n  var t1 = 0.5 - x1 * x1 - y1 * y1;\n\n  if (t1 < 0) {\n    n1 = 0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot2(x1, y1);\n  }\n\n  var t2 = 0.5 - x2 * x2 - y2 * y2;\n\n  if (t2 < 0) {\n    n2 = 0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot2(x2, y2);\n  } // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n\n\n  return 70 * (n0 + n1 + n2);\n}; // 3D simplex noise\n\nvar simplex3 = function simplex3(xin, yin, zin) {\n  var n0, n1, n2, n3; // Noise contributions from the four corners\n  // Skew the input space to determine which simplex cell we're in\n\n  var s = (xin + yin + zin) * F3; // Hairy factor for 2D\n\n  var i = Math.floor(xin + s);\n  var j = Math.floor(yin + s);\n  var k = Math.floor(zin + s);\n  var t = (i + j + k) * G3;\n  var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n\n  var y0 = yin - j + t;\n  var z0 = zin - k + t; // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n  // Determine which simplex we are in.\n\n  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n\n  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\n  if (x0 >= y0) {\n    if (y0 >= z0) {\n      i1 = 1;\n      j1 = 0;\n      k1 = 0;\n      i2 = 1;\n      j2 = 1;\n      k2 = 0;\n    } else if (x0 >= z0) {\n      i1 = 1;\n      j1 = 0;\n      k1 = 0;\n      i2 = 1;\n      j2 = 0;\n      k2 = 1;\n    } else {\n      i1 = 0;\n      j1 = 0;\n      k1 = 1;\n      i2 = 1;\n      j2 = 0;\n      k2 = 1;\n    }\n  } else {\n    if (y0 < z0) {\n      i1 = 0;\n      j1 = 0;\n      k1 = 1;\n      i2 = 0;\n      j2 = 1;\n      k2 = 1;\n    } else if (x0 < z0) {\n      i1 = 0;\n      j1 = 1;\n      k1 = 0;\n      i2 = 0;\n      j2 = 1;\n      k2 = 1;\n    } else {\n      i1 = 0;\n      j1 = 1;\n      k1 = 0;\n      i2 = 1;\n      j2 = 1;\n      k2 = 0;\n    }\n  } // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n  // c = 1/6.\n\n\n  var x1 = x0 - i1 + G3; // Offsets for second corner\n\n  var y1 = y0 - j1 + G3;\n  var z1 = z0 - k1 + G3;\n  var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\n\n  var y2 = y0 - j2 + 2 * G3;\n  var z2 = z0 - k2 + 2 * G3;\n  var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\n\n  var y3 = y0 - 1 + 3 * G3;\n  var z3 = z0 - 1 + 3 * G3; // Work out the hashed gradient indices of the four simplex corners\n\n  i &= 255;\n  j &= 255;\n  k &= 255;\n  var gi0 = gradP[i + perm[j + perm[k]]];\n  var gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]];\n  var gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]];\n  var gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]]; // Calculate the contribution from the four corners\n\n  var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n\n  if (t0 < 0) {\n    n0 = 0;\n  } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot3(x0, y0, z0); // (x,y) of grad3 used for 2D gradient\n  }\n\n  var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n\n  if (t1 < 0) {\n    n1 = 0;\n  } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\n  }\n\n  var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n\n  if (t2 < 0) {\n    n2 = 0;\n  } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\n  }\n\n  var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n\n  if (t3 < 0) {\n    n3 = 0;\n  } else {\n    t3 *= t3;\n    n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\n  } // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n\n\n  return 32 * (n0 + n1 + n2 + n3);\n}; // ##### Perlin noise stuff\n// 2D Perlin Noise\n\nvar perlin2 = function perlin2(x, y) {\n  // Find unit grid cell containing point\n  var X = Math.floor(x),\n      Y = Math.floor(y); // Get relative xy coordinates of point within that cell\n\n  x = x - X;\n  y = y - Y; // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n\n  X = X & 255;\n  Y = Y & 255; // Calculate noise contributions from each of the four corners\n\n  var n00 = gradP[X + perm[Y]].dot2(x, y);\n  var n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);\n  var n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);\n  var n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1); // Compute the fade curve value for x\n\n  var u = fade(x); // Interpolate the four results\n\n  return lerp(lerp(n00, n10, u), lerp(n01, n11, u), fade(y));\n}; // 3D Perlin Noise\n\nvar perlin3 = function perlin3(x, y, z) {\n  // Find unit grid cell containing point\n  var X = Math.floor(x),\n      Y = Math.floor(y),\n      Z = Math.floor(z); // Get relative xyz coordinates of point within that cell\n\n  x = x - X;\n  y = y - Y;\n  z = z - Z; // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n\n  X = X & 255;\n  Y = Y & 255;\n  Z = Z & 255; // Calculate noise contributions from each of the eight corners\n\n  var n000 = gradP[X + perm[Y + perm[Z]]].dot3(x, y, z);\n  var n001 = gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1);\n  var n010 = gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z);\n  var n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1);\n  var n100 = gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z);\n  var n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1);\n  var n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z);\n  var n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(x - 1, y - 1, z - 1); // Compute the fade curve value for x, y, z\n\n  var u = fade(x);\n  var v = fade(y);\n  var w = fade(z); // Interpolate\n\n  return lerp(lerp(lerp(n000, n100, u), lerp(n001, n101, u), w), lerp(lerp(n010, n110, u), lerp(n011, n111, u), w), v);\n};\n\nvar noise = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  seed: seed,\n  simplex2: simplex2,\n  simplex3: simplex3,\n  perlin2: perlin2,\n  perlin3: perlin3\n});\n\nvar TAU = Math.PI * 2;\nvar FlashGen = /*#__PURE__*/function () {\n  function FlashGen(props) {\n    _classCallCheck(this, FlashGen);\n\n    _defineProperty(this, \"nextBurstTime\", 0);\n\n    _defineProperty(this, \"nextFlashEndTime\", 0);\n\n    _defineProperty(this, \"flashesDone\", 0);\n\n    _defineProperty(this, \"isFlashing\", false);\n\n    _defineProperty(this, \"currentCount\", 0);\n\n    _defineProperty(this, \"flashIntensity\", 0);\n\n    _defineProperty(this, \"isDecaying\", false);\n\n    _defineProperty(this, \"autoBurst\", true);\n\n    _defineProperty(this, \"decaySpeed\", 40);\n\n    _defineProperty(this, \"minInterval\", 5000);\n\n    _defineProperty(this, \"maxInterval\", 10000);\n\n    _defineProperty(this, \"minDuration\", 50);\n\n    _defineProperty(this, \"maxDuration\", 300);\n\n    _defineProperty(this, \"count\", 5);\n\n    Object.assign(this, props);\n  }\n\n  _createClass(FlashGen, [{\n    key: \"scheduleNextBurst\",\n    value: function scheduleNextBurst(currentTime) {\n      var burstInterval = Math.random() * (this.maxInterval - this.minInterval) + this.minInterval;\n      this.nextBurstTime = currentTime + burstInterval / 1000;\n      this.flashesDone = 0;\n      this.isFlashing = false;\n    }\n  }, {\n    key: \"burst\",\n    value: function burst() {\n      this.nextBurstTime = 0;\n      this.flashesDone = 0;\n      this.isFlashing = false;\n    }\n  }, {\n    key: \"update\",\n    value: function update(currentTime, delta) {\n      if (currentTime > this.nextBurstTime && this.currentCount === 0) {\n        this.currentCount = Math.floor(Math.random() * this.count) + 1;\n      }\n\n      if (this.flashesDone < this.currentCount && currentTime > this.nextBurstTime) {\n        if (!this.isFlashing) {\n          this.isFlashing = true;\n          this.flashIntensity = 1;\n          var flashDuration = Math.random() * (this.maxDuration - this.minDuration) + this.minDuration;\n          this.nextFlashEndTime = currentTime + flashDuration / 1000;\n        } else if (this.isFlashing && currentTime > this.nextFlashEndTime) {\n          this.isFlashing = false;\n          this.isDecaying = true;\n          this.flashesDone++;\n\n          if (this.flashesDone >= this.currentCount) {\n            this.currentCount = 0;\n            if (this.autoBurst) this.scheduleNextBurst(currentTime);\n          }\n        }\n      }\n\n      if (this.isDecaying) {\n        this.flashIntensity -= delta * this.decaySpeed;\n        this.flashIntensity = Math.max(0, Math.min(1, this.flashIntensity));\n\n        if (this.flashIntensity <= 0) {\n          this.isDecaying = false;\n          this.flashIntensity = 0;\n        }\n      }\n\n      return this.flashIntensity;\n    }\n  }]);\n\n  return FlashGen;\n}(); // Credits @kchapelier https://github.com/kchapelier/wavefunctioncollapse/blob/master/example/lcg.js#L22-L30\n\nfunction normalizeSeed(seed) {\n  if (typeof seed === \"number\") {\n    seed = Math.abs(seed);\n  } else if (typeof seed === \"string\") {\n    var string = seed;\n    seed = 0;\n\n    for (var i = 0; i < string.length; i++) {\n      seed = (seed + (i + 1) * (string.charCodeAt(i) % 96)) % 2147483647;\n    }\n  }\n\n  if (seed === 0) {\n    seed = 311;\n  }\n\n  return seed;\n}\n\nfunction lcgRandom(seed) {\n  var state = normalizeSeed(seed);\n  return function () {\n    var result = state * 48271 % 2147483647;\n    state = result;\n    return result / 2147483647;\n  };\n}\n\nvar Generator = function Generator(_seed) {\n  var _this = this;\n\n  _classCallCheck(this, Generator);\n\n  _defineProperty(this, \"seed\", 0);\n\n  _defineProperty(this, \"init\", function (seed) {\n    _this.seed = seed;\n    _this.value = lcgRandom(seed);\n  });\n\n  _defineProperty(this, \"value\", lcgRandom(this.seed));\n\n  this.init(_seed);\n};\nvar defaultGen = new Generator(Math.random());\n/***\n * [3D] Sphere\n */\n\nvar defaultSphere = {\n  radius: 1,\n  center: [0, 0, 0]\n}; // random on surface of sphere\n// - https://twitter.com/fermatslibrary/status/1430932503578226688\n// - https://mathworld.wolfram.com/SpherePointPicking.html\n\nfunction onSphere(buffer, sphere) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultSphere$sphere = _objectSpread2(_objectSpread2({}, defaultSphere), sphere),\n      radius = _defaultSphere$sphere.radius,\n      center = _defaultSphere$sphere.center;\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    var u = rng.value();\n    var v = rng.value();\n    var theta = Math.acos(2 * v - 1);\n    var phi = TAU * u;\n    buffer[i] = Math.sin(theta) * Math.cos(phi) * radius + center[0];\n    buffer[i + 1] = Math.sin(theta) * Math.sin(phi) * radius + center[1];\n    buffer[i + 2] = Math.cos(theta) * radius + center[2];\n  }\n\n  return buffer;\n} // from \"Another Method\" https://datagenetics.com/blog/january32020/index.html\n\nfunction inSphere(buffer, sphere) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultSphere$sphere2 = _objectSpread2(_objectSpread2({}, defaultSphere), sphere),\n      radius = _defaultSphere$sphere2.radius,\n      center = _defaultSphere$sphere2.center;\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    var u = Math.pow(rng.value(), 1 / 3);\n    var x = rng.value() * 2 - 1;\n    var y = rng.value() * 2 - 1;\n    var z = rng.value() * 2 - 1;\n    var mag = Math.sqrt(x * x + y * y + z * z);\n    x = u * x / mag;\n    y = u * y / mag;\n    z = u * z / mag;\n    buffer[i] = x * radius + center[0];\n    buffer[i + 1] = y * radius + center[1];\n    buffer[i + 2] = z * radius + center[2];\n  }\n\n  return buffer;\n}\n/***\n * [2D] Circle\n */\n\nvar defaultCircle = {\n  radius: 1,\n  center: [0, 0]\n}; // random circle https://stackoverflow.com/a/50746409\n\nfunction inCircle(buffer, circle) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultCircle$circle = _objectSpread2(_objectSpread2({}, defaultCircle), circle),\n      radius = _defaultCircle$circle.radius,\n      center = _defaultCircle$circle.center;\n\n  for (var i = 0; i < buffer.length; i += 2) {\n    var r = radius * Math.sqrt(rng.value());\n    var theta = rng.value() * TAU;\n    buffer[i] = Math.sin(theta) * r + center[0];\n    buffer[i + 1] = Math.cos(theta) * r + center[1];\n  }\n\n  return buffer;\n}\nfunction onCircle(buffer, circle) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultCircle$circle2 = _objectSpread2(_objectSpread2({}, defaultCircle), circle),\n      radius = _defaultCircle$circle2.radius,\n      center = _defaultCircle$circle2.center;\n\n  for (var i = 0; i < buffer.length; i += 2) {\n    var theta = rng.value() * TAU;\n    buffer[i] = Math.sin(theta) * radius + center[0];\n    buffer[i + 1] = Math.cos(theta) * radius + center[1];\n  }\n\n  return buffer;\n}\n/**\n * [2D] Plane\n */\n\nvar defaultRect = {\n  sides: 1,\n  center: [0, 0]\n};\nfunction inRect(buffer, rect) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultRect$rect = _objectSpread2(_objectSpread2({}, defaultRect), rect),\n      sides = _defaultRect$rect.sides,\n      center = _defaultRect$rect.center;\n\n  var sideX = typeof sides === \"number\" ? sides : sides[0];\n  var sideY = typeof sides === \"number\" ? sides : sides[1];\n\n  for (var i = 0; i < buffer.length; i += 2) {\n    buffer[i] = (rng.value() - 0.5) * sideX + center[0];\n    buffer[i + 1] = (rng.value() - 0.5) * sideY + center[1];\n  }\n\n  return buffer;\n}\nfunction onRect(buffer, rect) {\n  return buffer;\n}\n/***\n * [3D] Box\n */\n\nfunction inBox(buffer, box) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultBox$box = _objectSpread2(_objectSpread2({}, defaultBox), box),\n      sides = _defaultBox$box.sides,\n      center = _defaultBox$box.center;\n\n  var sideX = typeof sides === \"number\" ? sides : sides[0];\n  var sideY = typeof sides === \"number\" ? sides : sides[1];\n  var sideZ = typeof sides === \"number\" ? sides : sides[2];\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    buffer[i] = (rng.value() - 0.5) * sideX + center[0];\n    buffer[i + 1] = (rng.value() - 0.5) * sideY + center[1];\n    buffer[i + 2] = (rng.value() - 0.5) * sideZ + center[2];\n  }\n\n  return buffer;\n}\nvar defaultBox = {\n  sides: 1,\n  center: [0, 0, 0]\n};\nfunction onBox(buffer, box) {\n  var rng = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGen;\n\n  var _defaultBox$box2 = _objectSpread2(_objectSpread2({}, defaultBox), box),\n      sides = _defaultBox$box2.sides,\n      center = _defaultBox$box2.center;\n\n  var sideX = typeof sides === \"number\" ? sides : sides[0];\n  var sideY = typeof sides === \"number\" ? sides : sides[1];\n  var sideZ = typeof sides === \"number\" ? sides : sides[2];\n\n  for (var i = 0; i < buffer.length; i += 3) {\n    buffer[i] = (rng.value() - 0.5) * sideX + center[0];\n    buffer[i + 1] = (rng.value() - 0.5) * sideY + center[1];\n    buffer[i + 2] = (rng.value() - 0.5) * sideZ + center[2];\n  }\n\n  return buffer;\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  FlashGen: FlashGen,\n  Generator: Generator,\n  onSphere: onSphere,\n  inSphere: inSphere,\n  inCircle: inCircle,\n  onCircle: onCircle,\n  inRect: inRect,\n  onRect: onRect,\n  inBox: inBox,\n  onBox: onBox,\n  noise: noise\n});\n\nexport { FlashGen as F, Generator as G, inSphere as a, inCircle as b, onCircle as c, inRect as d, onRect as e, inBox as f, onBox as g, index as i, noise as n, onSphere as o };\n","import { a as _toConsumableArray } from './triangle-b62b9067.esm.js';\nimport { Color, Vector3, Quaternion, Matrix4, Vector2, Vector4, Euler, Spherical } from 'three';\nimport { d as deltaAngle } from './misc-19a3ec46.esm.js';\n\nvar rsqw = function rsqw(t) {\n  var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.01;\n  var a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var f = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1 / (2 * Math.PI);\n  return a / Math.atan(1 / delta) * Math.atan(Math.sin(2 * Math.PI * t * f) / delta);\n};\nvar exp = function exp(t) {\n  return 1 / (1 + t + 0.48 * t * t + 0.235 * t * t * t);\n};\nvar linear = function linear(t) {\n  return t;\n};\nvar sine = {\n  \"in\": function _in(x) {\n    return 1 - Math.cos(x * Math.PI / 2);\n  },\n  out: function out(x) {\n    return Math.sin(x * Math.PI / 2);\n  },\n  inOut: function inOut(x) {\n    return -(Math.cos(Math.PI * x) - 1) / 2;\n  }\n};\nvar cubic = {\n  \"in\": function _in(x) {\n    return x * x * x;\n  },\n  out: function out(x) {\n    return 1 - Math.pow(1 - x, 3);\n  },\n  inOut: function inOut(x) {\n    return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;\n  }\n};\nvar quint = {\n  \"in\": function _in(x) {\n    return x * x * x * x * x;\n  },\n  out: function out(x) {\n    return 1 - Math.pow(1 - x, 5);\n  },\n  inOut: function inOut(x) {\n    return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;\n  }\n};\nvar circ = {\n  \"in\": function _in(x) {\n    return 1 - Math.sqrt(1 - Math.pow(x, 2));\n  },\n  out: function out(x) {\n    return Math.sqrt(1 - Math.pow(x - 1, 2));\n  },\n  inOut: function inOut(x) {\n    return x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2;\n  }\n};\nvar quart = {\n  \"in\": function _in(t) {\n    return t * t * t * t;\n  },\n  out: function out(t) {\n    return 1 - --t * t * t * t;\n  },\n  inOut: function inOut(t) {\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n  }\n};\nvar expo = {\n  \"in\": function _in(x) {\n    return x === 0 ? 0 : Math.pow(2, 10 * x - 10);\n  },\n  out: function out(x) {\n    return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);\n  },\n  inOut: function inOut(x) {\n    return x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2;\n  }\n};\n/**\n * Damp, based on Game Programming Gems 4 Chapter 1.10\n *   Return value indicates whether the animation is still running.\n */\n\nfunction damp(\n/** The object */\ncurrent,\n/** The key to animate */\nprop,\n/** To goal value */\ntarget) {\n  var smoothTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.25;\n  var delta = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.01;\n  var maxSpeed = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n  var easing = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : exp;\n  var eps = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0.001;\n  var vel = \"velocity_\" + prop;\n  if (current.__damp === undefined) current.__damp = {};\n  if (current.__damp[vel] === undefined) current.__damp[vel] = 0;\n\n  if (Math.abs(current[prop] - target) <= eps) {\n    current[prop] = target;\n    return false;\n  }\n\n  smoothTime = Math.max(0.0001, smoothTime);\n  var omega = 2 / smoothTime;\n  var t = easing(omega * delta);\n  var change = current[prop] - target;\n  var originalTo = target; // Clamp maximum maxSpeed\n\n  var maxChange = maxSpeed * smoothTime;\n  change = Math.min(Math.max(change, -maxChange), maxChange);\n  target = current[prop] - change;\n  var temp = (current.__damp[vel] + omega * change) * delta;\n  current.__damp[vel] = (current.__damp[vel] - omega * temp) * t;\n  var output = target + (change + temp) * t; // Prevent overshooting\n\n  if (originalTo - current[prop] > 0.0 === output > originalTo) {\n    output = originalTo;\n    current.__damp[vel] = (output - originalTo) / delta;\n  }\n\n  current[prop] = output;\n  return true;\n}\n/**\n * DampLookAt\n */\n\nvar isCamera = function isCamera(v) {\n  return v && v.isCamera;\n};\n\nvar isLight = function isLight(v) {\n  return v && v.isLight;\n};\n\nvar vl3d = /*@__PURE__*/new Vector3();\n\nvar _q1 = /*@__PURE__*/new Quaternion();\n\nvar _q2 = /*@__PURE__*/new Quaternion();\n\nvar _m1 = /*@__PURE__*/new Matrix4();\n\nvar _position = /*@__PURE__*/new Vector3();\n\nfunction dampLookAt(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  // This method does not support objects having non-uniformly-scaled parent(s)\n  if (typeof target === \"number\") vl3d.setScalar(target);else if (Array.isArray(target)) vl3d.set(target[0], target[1], target[2]);else vl3d.copy(target);\n  var parent = current.parent;\n  current.updateWorldMatrix(true, false);\n\n  _position.setFromMatrixPosition(current.matrixWorld);\n\n  if (isCamera(current) || isLight(current)) _m1.lookAt(_position, vl3d, current.up);else _m1.lookAt(vl3d, _position, current.up);\n  dampQ(current.quaternion, _q2.setFromRotationMatrix(_m1), smoothTime, delta, maxSpeed, easing, eps);\n\n  if (parent) {\n    _m1.extractRotation(parent.matrixWorld);\n\n    _q1.setFromRotationMatrix(_m1);\n\n    dampQ(current.quaternion, _q2.copy(current.quaternion).premultiply(_q1.invert()), smoothTime, delta, maxSpeed, easing, eps);\n  }\n}\n/**\n * DampAngle, with a shortest-path\n */\n\nfunction dampAngle(current, prop, target, smoothTime, delta, maxSpeed, easing, eps) {\n  return damp(current, prop, current[prop] + deltaAngle(current[prop], target), smoothTime, delta, maxSpeed, easing, eps);\n}\n/**\n * Vector2D Damp\n */\n\nvar v2d = /*@__PURE__*/new Vector2();\nvar a2, b2;\nfunction damp2(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (typeof target === \"number\") v2d.setScalar(target);else if (Array.isArray(target)) v2d.set(target[0], target[1]);else v2d.copy(target);\n  a2 = damp(current, \"x\", v2d.x, smoothTime, delta, maxSpeed, easing, eps);\n  b2 = damp(current, \"y\", v2d.y, smoothTime, delta, maxSpeed, easing, eps);\n  return a2 || b2;\n}\n/**\n * Vector3D Damp\n */\n\nvar v3d = /*@__PURE__*/new Vector3();\nvar a3, b3, c3;\nfunction damp3(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (typeof target === \"number\") v3d.setScalar(target);else if (Array.isArray(target)) v3d.set(target[0], target[1], target[2]);else v3d.copy(target);\n  a3 = damp(current, \"x\", v3d.x, smoothTime, delta, maxSpeed, easing, eps);\n  b3 = damp(current, \"y\", v3d.y, smoothTime, delta, maxSpeed, easing, eps);\n  c3 = damp(current, \"z\", v3d.z, smoothTime, delta, maxSpeed, easing, eps);\n  return a3 || b3 || c3;\n}\n/**\n * Vector4D Damp\n */\n\nvar v4d = /*@__PURE__*/new Vector4();\nvar a4, b4, c4, d4;\nfunction damp4(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (typeof target === \"number\") v4d.setScalar(target);else if (Array.isArray(target)) v4d.set(target[0], target[1], target[2], target[3]);else v4d.copy(target);\n  a4 = damp(current, \"x\", v4d.x, smoothTime, delta, maxSpeed, easing, eps);\n  b4 = damp(current, \"y\", v4d.y, smoothTime, delta, maxSpeed, easing, eps);\n  c4 = damp(current, \"z\", v4d.z, smoothTime, delta, maxSpeed, easing, eps);\n  d4 = damp(current, \"w\", v4d.w, smoothTime, delta, maxSpeed, easing, eps);\n  return a4 || b4 || c4 || d4;\n}\n\n/**\n * Euler Damp\n */\nvar rot = /*@__PURE__*/new Euler();\nvar aE, bE, cE;\nfunction dampE(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (Array.isArray(target)) rot.set(target[0], target[1], target[2], target[3]);else rot.copy(target);\n  aE = dampAngle(current, \"x\", rot.x, smoothTime, delta, maxSpeed, easing, eps);\n  bE = dampAngle(current, \"y\", rot.y, smoothTime, delta, maxSpeed, easing, eps);\n  cE = dampAngle(current, \"z\", rot.z, smoothTime, delta, maxSpeed, easing, eps);\n  return aE || bE || cE;\n}\n/**\n * Color Damp\n */\n\nvar col = /*@__PURE__*/new Color();\nvar aC, bC, cC;\nfunction dampC(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (target instanceof Color) col.copy(target);else if (Array.isArray(target)) col.setRGB(target[0], target[1], target[2]);else col.set(target);\n  aC = damp(current, \"r\", col.r, smoothTime, delta, maxSpeed, easing, eps);\n  bC = damp(current, \"g\", col.g, smoothTime, delta, maxSpeed, easing, eps);\n  cC = damp(current, \"b\", col.b, smoothTime, delta, maxSpeed, easing, eps);\n  return aC || bC || cC;\n}\n/**\n * Quaternion Damp\n * https://gist.github.com/maxattack/4c7b4de00f5c1b95a33b\n * Copyright 2016 Max Kaufmann (max.kaufmann@gmail.com)\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nvar qt = /*@__PURE__*/new Quaternion();\nvar v4result = /*@__PURE__*/new Vector4();\nvar v4velocity = /*@__PURE__*/new Vector4();\nvar v4error = /*@__PURE__*/new Vector4();\nvar aQ, bQ, cQ, dQ;\nfunction dampQ(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  var cur = current;\n  if (Array.isArray(target)) qt.set(target[0], target[1], target[2], target[3]);else qt.copy(target);\n  var multi = current.dot(qt) > 0 ? 1 : -1;\n  qt.x *= multi;\n  qt.y *= multi;\n  qt.z *= multi;\n  qt.w *= multi;\n  aQ = damp(current, \"x\", qt.x, smoothTime, delta, maxSpeed, easing, eps);\n  bQ = damp(current, \"y\", qt.y, smoothTime, delta, maxSpeed, easing, eps);\n  cQ = damp(current, \"z\", qt.z, smoothTime, delta, maxSpeed, easing, eps);\n  dQ = damp(current, \"w\", qt.w, smoothTime, delta, maxSpeed, easing, eps); // smooth damp (nlerp approx)\n\n  v4result.set(current.x, current.y, current.z, current.w).normalize();\n  v4velocity.set(cur.__damp.velocity_x, cur.__damp.velocity_y, cur.__damp.velocity_z, cur.__damp.velocity_w); // ensure deriv is tangent\n\n  v4error.copy(v4result).multiplyScalar(v4velocity.dot(v4result) / v4result.dot(v4result));\n  cur.__damp.velocity_x -= v4error.x;\n  cur.__damp.velocity_y -= v4error.y;\n  cur.__damp.velocity_z -= v4error.z;\n  cur.__damp.velocity_w -= v4error.w;\n  current.set(v4result.x, v4result.y, v4result.z, v4result.w);\n  return aQ || bQ || cQ || dQ;\n}\n/**\n * Spherical Damp\n */\n\nvar spherical = /*@__PURE__*/new Spherical();\nvar aS, bS, cS;\nfunction dampS(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  if (Array.isArray(target)) spherical.set(target[0], target[1], target[2]);else spherical.copy(target);\n  aS = damp(current, \"radius\", spherical.radius, smoothTime, delta, maxSpeed, easing, eps);\n  bS = dampAngle(current, \"phi\", spherical.phi, smoothTime, delta, maxSpeed, easing, eps);\n  cS = dampAngle(current, \"theta\", spherical.theta, smoothTime, delta, maxSpeed, easing, eps);\n  return aS || bS || cS;\n}\n/**\n * Matrix4 Damp\n */\n\nvar mat = /*@__PURE__*/new Matrix4();\nvar mPos = /*@__PURE__*/new Vector3();\nvar mRot = /*@__PURE__*/new Quaternion();\nvar mSca = /*@__PURE__*/new Vector3();\nvar aM, bM, cM;\nfunction dampM(current, target, smoothTime, delta, maxSpeed, easing, eps) {\n  var cur = current;\n\n  if (cur.__damp === undefined) {\n    cur.__damp = {\n      position: new Vector3(),\n      rotation: new Quaternion(),\n      scale: new Vector3()\n    };\n    current.decompose(cur.__damp.position, cur.__damp.rotation, cur.__damp.scale);\n  }\n\n  if (Array.isArray(target)) mat.set.apply(mat, _toConsumableArray(target));else mat.copy(target);\n  mat.decompose(mPos, mRot, mSca);\n  aM = damp3(cur.__damp.position, mPos, smoothTime, delta, maxSpeed, easing, eps);\n  bM = dampQ(cur.__damp.rotation, mRot, smoothTime, delta, maxSpeed, easing, eps);\n  cM = damp3(cur.__damp.scale, mSca, smoothTime, delta, maxSpeed, easing, eps);\n  current.compose(cur.__damp.position, cur.__damp.rotation, cur.__damp.scale);\n  return aM || bM || cM;\n}\n\nvar easing = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  rsqw: rsqw,\n  exp: exp,\n  linear: linear,\n  sine: sine,\n  cubic: cubic,\n  quint: quint,\n  circ: circ,\n  quart: quart,\n  expo: expo,\n  damp: damp,\n  dampLookAt: dampLookAt,\n  dampAngle: dampAngle,\n  damp2: damp2,\n  damp3: damp3,\n  damp4: damp4,\n  dampE: dampE,\n  dampC: dampC,\n  dampQ: dampQ,\n  dampS: dampS,\n  dampM: dampM\n});\n\nexport { exp as a, circ as b, cubic as c, quart as d, easing as e, expo as f, damp as g, dampLookAt as h, dampAngle as i, damp2 as j, damp3 as k, linear as l, damp4 as m, dampE as n, dampC as o, dampQ as p, quint as q, rsqw as r, sine as s, dampS as t, dampM as u };\n","import { _ as _classCallCheck } from './classCallCheck-9098b006.esm.js';\nimport { _ as _setPrototypeOf, a as _isNativeReflectConstruct } from './isNativeReflectConstruct-5594d075.esm.js';\nimport * as THREE from 'three';\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar RoundedPlaneGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  _inherits(RoundedPlaneGeometry, _THREE$BufferGeometry);\n\n  var _super = _createSuper(RoundedPlaneGeometry);\n\n  function RoundedPlaneGeometry() {\n    var _this;\n\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.2;\n    var segments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 16;\n\n    _classCallCheck(this, RoundedPlaneGeometry);\n\n    _this = _super.call(this);\n    _this.parameters = {\n      width: width,\n      height: height,\n      radius: radius,\n      segments: segments\n    }; // helper const's\n\n    var wi = width / 2 - radius; // inner width\n\n    var hi = height / 2 - radius; // inner height\n\n    var ul = radius / width; // u left\n\n    var ur = (width - radius) / width; // u right\n\n    var vl = radius / height; // v low\n\n    var vh = (height - radius) / height; // v high\n\n    var positions = [wi, hi, 0, -wi, hi, 0, -wi, -hi, 0, wi, -hi, 0];\n    var uvs = [ur, vh, ul, vh, ul, vl, ur, vl];\n    var n = [3 * (segments + 1) + 3, 3 * (segments + 1) + 4, segments + 4, segments + 5, 2 * (segments + 1) + 4, 2, 1, 2 * (segments + 1) + 3, 3, 4 * (segments + 1) + 3, 4, 0];\n    var indices = [n[0], n[1], n[2], n[0], n[2], n[3], n[4], n[5], n[6], n[4], n[6], n[7], n[8], n[9], n[10], n[8], n[10], n[11]];\n    var phi, cos, sin, xc, yc, uc, vc, idx;\n\n    for (var i = 0; i < 4; i++) {\n      xc = i < 1 || i > 2 ? wi : -wi;\n      yc = i < 2 ? hi : -hi;\n      uc = i < 1 || i > 2 ? ur : ul;\n      vc = i < 2 ? vh : vl;\n\n      for (var j = 0; j <= segments; j++) {\n        phi = Math.PI / 2 * (i + j / segments);\n        cos = Math.cos(phi);\n        sin = Math.sin(phi);\n        positions.push(xc + radius * cos, yc + radius * sin, 0);\n        uvs.push(uc + ul * cos, vc + vl * sin);\n\n        if (j < segments) {\n          idx = (segments + 1) * i + j + 4;\n          indices.push(i, idx, idx + 1);\n        }\n      }\n    }\n\n    _this.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n\n    _this.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(positions), 3));\n\n    _this.setAttribute(\"uv\", new THREE.BufferAttribute(new Float32Array(uvs), 2));\n\n    return _this;\n  }\n\n  return RoundedPlaneGeometry;\n}(THREE.BufferGeometry); // Author: https://stackoverflow.com/users/128511/gman\n// https://stackoverflow.com/questions/34958072/programmatically-generate-simple-uv-mapping-for-models\n\nfunction applyCylindricalUV(bufferGeometry) {\n  var uvs = [];\n\n  for (var i = 0; i < bufferGeometry.attributes.position.array.length / 3; i++) {\n    var x = bufferGeometry.attributes.position.array[i * 3 + 0];\n    var y = bufferGeometry.attributes.position.array[i * 3 + 1];\n    var z = bufferGeometry.attributes.position.array[i * 3 + 2];\n    uvs.push(Math.atan2(x, z) / Math.PI * 0.5 + 0.5, y / Math.PI * 0.5 + 0.5);\n  }\n\n  if (bufferGeometry.attributes.uv) delete bufferGeometry.attributes.uv;\n  bufferGeometry.setAttribute(\"uv\", new THREE.Float32BufferAttribute(uvs, 2));\n  bufferGeometry.attributes.uv.needsUpdate = true;\n  return bufferGeometry;\n} // Author: https://stackoverflow.com/users/268905/knee-cola\n// https://stackoverflow.com/questions/20774648/three-js-generate-uv-coordinate\n\nfunction applySphereUV(bufferGeometry) {\n  var uvs = [];\n  var vertices = [];\n\n  for (var i = 0; i < bufferGeometry.attributes.position.array.length / 3; i++) {\n    var x = bufferGeometry.attributes.position.array[i * 3 + 0];\n    var y = bufferGeometry.attributes.position.array[i * 3 + 1];\n    var z = bufferGeometry.attributes.position.array[i * 3 + 2];\n    vertices.push(new THREE.Vector3(x, y, z));\n  }\n\n  var polarVertices = vertices.map(cartesian2polar);\n\n  for (var _i = 0; _i < polarVertices.length / 3; _i++) {\n    var tri = new THREE.Triangle(vertices[_i * 3 + 0], vertices[_i * 3 + 1], vertices[_i * 3 + 2]);\n    var normal = tri.getNormal(new THREE.Vector3());\n\n    for (var f = 0; f < 3; f++) {\n      var vertex = polarVertices[_i * 3 + f];\n\n      if (vertex.theta === 0 && (vertex.phi === 0 || vertex.phi === Math.PI)) {\n        var alignedVertice = vertex.phi === 0 ? _i * 3 + 1 : _i * 3 + 0;\n        vertex = {\n          r: vertex.r,\n          phi: vertex.phi,\n          theta: polarVertices[alignedVertice].theta\n        };\n      }\n\n      if (vertex.theta === Math.PI && cartesian2polar(normal).theta < Math.PI / 2) {\n        vertex.theta = -Math.PI;\n      }\n\n      var canvasPoint = polar2canvas(vertex);\n      uvs.push(1 - canvasPoint.x, 1 - canvasPoint.y);\n    }\n  }\n\n  if (bufferGeometry.attributes.uv) delete bufferGeometry.attributes.uv;\n  bufferGeometry.setAttribute(\"uv\", new THREE.Float32BufferAttribute(uvs, 2));\n  bufferGeometry.attributes.uv.needsUpdate = true;\n  return bufferGeometry;\n}\n\nfunction cartesian2polar(position) {\n  var r = Math.sqrt(position.x * position.x + position.z * position.z + position.y * position.y);\n  return {\n    r: r,\n    phi: Math.acos(position.y / r),\n    theta: Math.atan2(position.z, position.x)\n  };\n}\n\nfunction polar2canvas(polarPoint) {\n  return {\n    y: polarPoint.phi / Math.PI,\n    x: (polarPoint.theta + Math.PI) / (2 * Math.PI)\n  };\n} // Author: Alex Khoroshylov (https://stackoverflow.com/users/8742287/alex-khoroshylov)\n// https://stackoverflow.com/questions/20774648/three-js-generate-uv-coordinate\n\n\nfunction applyBoxUV(bufferGeometry) {\n  bufferGeometry.computeBoundingBox();\n  var bboxSize = bufferGeometry.boundingBox.getSize(new THREE.Vector3());\n  var boxSize = Math.min(bboxSize.x, bboxSize.y, bboxSize.z);\n  var boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);\n  var cube = new THREE.Mesh(boxGeometry);\n  cube.rotation.set(0, 0, 0);\n  cube.updateWorldMatrix(true, false);\n  var transformMatrix = cube.matrix.clone().invert();\n  var uvBbox = new THREE.Box3(new THREE.Vector3(-boxSize / 2, -boxSize / 2, -boxSize / 2), new THREE.Vector3(boxSize / 2, boxSize / 2, boxSize / 2));\n\n  _applyBoxUV(bufferGeometry, transformMatrix, uvBbox, boxSize);\n\n  bufferGeometry.attributes.uv.needsUpdate = true;\n  return bufferGeometry;\n}\n\nfunction _applyBoxUV(geom, transformMatrix, bbox, bbox_max_size) {\n  var coords = [];\n  coords.length = 2 * geom.attributes.position.array.length / 3; //maps 3 verts of 1 face on the better side of the cube\n  //side of the cube can be XY, XZ or YZ\n\n  var makeUVs = function makeUVs(v0, v1, v2) {\n    //pre-rotate the model so that cube sides match world axis\n    v0.applyMatrix4(transformMatrix);\n    v1.applyMatrix4(transformMatrix);\n    v2.applyMatrix4(transformMatrix); //get normal of the face, to know into which cube side it maps better\n\n    var n = new THREE.Vector3();\n    n.crossVectors(v1.clone().sub(v0), v1.clone().sub(v2)).normalize();\n    n.x = Math.abs(n.x);\n    n.y = Math.abs(n.y);\n    n.z = Math.abs(n.z);\n    var uv0 = new THREE.Vector2();\n    var uv1 = new THREE.Vector2();\n    var uv2 = new THREE.Vector2(); // xz mapping\n\n    if (n.y > n.x && n.y > n.z) {\n      uv0.x = (v0.x - bbox.min.x) / bbox_max_size;\n      uv0.y = (bbox.max.z - v0.z) / bbox_max_size;\n      uv1.x = (v1.x - bbox.min.x) / bbox_max_size;\n      uv1.y = (bbox.max.z - v1.z) / bbox_max_size;\n      uv2.x = (v2.x - bbox.min.x) / bbox_max_size;\n      uv2.y = (bbox.max.z - v2.z) / bbox_max_size;\n    } else if (n.x > n.y && n.x > n.z) {\n      uv0.x = (v0.z - bbox.min.z) / bbox_max_size;\n      uv0.y = (v0.y - bbox.min.y) / bbox_max_size;\n      uv1.x = (v1.z - bbox.min.z) / bbox_max_size;\n      uv1.y = (v1.y - bbox.min.y) / bbox_max_size;\n      uv2.x = (v2.z - bbox.min.z) / bbox_max_size;\n      uv2.y = (v2.y - bbox.min.y) / bbox_max_size;\n    } else if (n.z > n.y && n.z > n.x) {\n      uv0.x = (v0.x - bbox.min.x) / bbox_max_size;\n      uv0.y = (v0.y - bbox.min.y) / bbox_max_size;\n      uv1.x = (v1.x - bbox.min.x) / bbox_max_size;\n      uv1.y = (v1.y - bbox.min.y) / bbox_max_size;\n      uv2.x = (v2.x - bbox.min.x) / bbox_max_size;\n      uv2.y = (v2.y - bbox.min.y) / bbox_max_size;\n    }\n\n    return {\n      uv0: uv0,\n      uv1: uv1,\n      uv2: uv2\n    };\n  };\n\n  if (geom.index) {\n    // is it indexed buffer geometry?\n    for (var vi = 0; vi < geom.index.array.length; vi += 3) {\n      var idx0 = geom.index.array[vi];\n      var idx1 = geom.index.array[vi + 1];\n      var idx2 = geom.index.array[vi + 2];\n      var vx0 = geom.attributes.position.array[3 * idx0];\n      var vy0 = geom.attributes.position.array[3 * idx0 + 1];\n      var vz0 = geom.attributes.position.array[3 * idx0 + 2];\n      var vx1 = geom.attributes.position.array[3 * idx1];\n      var vy1 = geom.attributes.position.array[3 * idx1 + 1];\n      var vz1 = geom.attributes.position.array[3 * idx1 + 2];\n      var vx2 = geom.attributes.position.array[3 * idx2];\n      var vy2 = geom.attributes.position.array[3 * idx2 + 1];\n      var vz2 = geom.attributes.position.array[3 * idx2 + 2];\n      var v0 = new THREE.Vector3(vx0, vy0, vz0);\n      var v1 = new THREE.Vector3(vx1, vy1, vz1);\n      var v2 = new THREE.Vector3(vx2, vy2, vz2);\n      var uvs = makeUVs(v0, v1, v2);\n      coords[2 * idx0] = uvs.uv0.x;\n      coords[2 * idx0 + 1] = uvs.uv0.y;\n      coords[2 * idx1] = uvs.uv1.x;\n      coords[2 * idx1 + 1] = uvs.uv1.y;\n      coords[2 * idx2] = uvs.uv2.x;\n      coords[2 * idx2 + 1] = uvs.uv2.y;\n    }\n  } else {\n    for (var _vi = 0; _vi < geom.attributes.position.array.length; _vi += 9) {\n      var _vx = geom.attributes.position.array[_vi];\n      var _vy = geom.attributes.position.array[_vi + 1];\n      var _vz = geom.attributes.position.array[_vi + 2];\n      var _vx2 = geom.attributes.position.array[_vi + 3];\n      var _vy2 = geom.attributes.position.array[_vi + 4];\n      var _vz2 = geom.attributes.position.array[_vi + 5];\n      var _vx3 = geom.attributes.position.array[_vi + 6];\n      var _vy3 = geom.attributes.position.array[_vi + 7];\n      var _vz3 = geom.attributes.position.array[_vi + 8];\n\n      var _v = new THREE.Vector3(_vx, _vy, _vz);\n\n      var _v2 = new THREE.Vector3(_vx2, _vy2, _vz2);\n\n      var _v3 = new THREE.Vector3(_vx3, _vy3, _vz3);\n\n      var _uvs = makeUVs(_v, _v2, _v3);\n\n      var _idx = _vi / 3;\n\n      var _idx2 = _idx + 1;\n\n      var _idx3 = _idx + 2;\n\n      coords[2 * _idx] = _uvs.uv0.x;\n      coords[2 * _idx + 1] = _uvs.uv0.y;\n      coords[2 * _idx2] = _uvs.uv1.x;\n      coords[2 * _idx2 + 1] = _uvs.uv1.y;\n      coords[2 * _idx3] = _uvs.uv2.x;\n      coords[2 * _idx3 + 1] = _uvs.uv2.y;\n    }\n  }\n\n  if (geom.attributes.uv) delete geom.attributes.uv;\n  geom.setAttribute(\"uv\", new THREE.Float32BufferAttribute(coords, 2));\n}\n\nvar geometry = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  RoundedPlaneGeometry: RoundedPlaneGeometry,\n  applyCylindricalUV: applyCylindricalUV,\n  applySphereUV: applySphereUV,\n  applyBoxUV: applyBoxUV\n});\n\nexport { RoundedPlaneGeometry as R, applyCylindricalUV as a, applySphereUV as b, applyBoxUV as c, geometry as g };\n","import {\n  Box3,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4,\n} from 'three'\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry'\nimport { LineMaterial } from '../lines/LineMaterial'\nimport { UV1 } from '../_polyfill/uv1'\n\nconst _viewport = /* @__PURE__ */ new Vector4()\n\nconst _start = /* @__PURE__ */ new Vector3()\nconst _end = /* @__PURE__ */ new Vector3()\n\nconst _start4 = /* @__PURE__ */ new Vector4()\nconst _end4 = /* @__PURE__ */ new Vector4()\n\nconst _ssOrigin = /* @__PURE__ */ new Vector4()\nconst _ssOrigin3 = /* @__PURE__ */ new Vector3()\nconst _mvMatrix = /* @__PURE__ */ new Matrix4()\nconst _line = /* @__PURE__ */ new Line3()\nconst _closestPoint = /* @__PURE__ */ new Vector3()\n\nconst _box = /* @__PURE__ */ new Box3()\nconst _sphere = /* @__PURE__ */ new Sphere()\nconst _clipToWorldVector = /* @__PURE__ */ new Vector4()\n\nlet _ray, _lineWidth\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix)\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w)\n  _clipToWorldVector.x = _lineWidth / resolution.width\n  _clipToWorldVector.y = _lineWidth / resolution.height\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse)\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w)\n\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y))\n}\n\nfunction raycastWorldUnits(lineSegments, intersects) {\n  const matrixWorld = lineSegments.matrixWorld\n  const geometry = lineSegments.geometry\n  const instanceStart = geometry.attributes.instanceStart\n  const instanceEnd = geometry.attributes.instanceEnd\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count)\n\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _line.start.fromBufferAttribute(instanceStart, i)\n    _line.end.fromBufferAttribute(instanceEnd, i)\n\n    _line.applyMatrix4(matrixWorld)\n\n    const pointOnLine = new Vector3()\n    const point = new Vector3()\n\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine)\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5\n\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null,\n      })\n    }\n  }\n}\n\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix\n  const material = lineSegments.material\n  const resolution = material.resolution\n  const matrixWorld = lineSegments.matrixWorld\n\n  const geometry = lineSegments.geometry\n  const instanceStart = geometry.attributes.instanceStart\n  const instanceEnd = geometry.attributes.instanceEnd\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count)\n\n  const near = -camera.near\n\n  //\n\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n  _ray.at(1, _ssOrigin)\n\n  // ndc space [ - 1.0, 1.0 ]\n  _ssOrigin.w = 1\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse)\n  _ssOrigin.applyMatrix4(projectionMatrix)\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w)\n\n  // screen space\n  _ssOrigin.x *= resolution.x / 2\n  _ssOrigin.y *= resolution.y / 2\n  _ssOrigin.z = 0\n\n  _ssOrigin3.copy(_ssOrigin)\n\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld)\n\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i)\n    _end4.fromBufferAttribute(instanceEnd, i)\n\n    _start4.w = 1\n    _end4.w = 1\n\n    // camera space\n    _start4.applyMatrix4(_mvMatrix)\n    _end4.applyMatrix4(_mvMatrix)\n\n    // skip the segment if it's entirely behind the camera\n    const isBehindCameraNear = _start4.z > near && _end4.z > near\n    if (isBehindCameraNear) {\n      continue\n    }\n\n    // trim the segment if it extends behind camera near\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z\n      const t = (_start4.z - near) / deltaDist\n      _start4.lerp(_end4, t)\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z\n      const t = (_end4.z - near) / deltaDist\n      _end4.lerp(_start4, t)\n    }\n\n    // clip space\n    _start4.applyMatrix4(projectionMatrix)\n    _end4.applyMatrix4(projectionMatrix)\n\n    // ndc space [ - 1.0, 1.0 ]\n    _start4.multiplyScalar(1 / _start4.w)\n    _end4.multiplyScalar(1 / _end4.w)\n\n    // screen space\n    _start4.x *= resolution.x / 2\n    _start4.y *= resolution.y / 2\n\n    _end4.x *= resolution.x / 2\n    _end4.y *= resolution.y / 2\n\n    // create 2d segment\n    _line.start.copy(_start4)\n    _line.start.z = 0\n\n    _line.end.copy(_end4)\n    _line.end.z = 0\n\n    // get closest point on ray to segment\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true)\n    _line.at(param, _closestPoint)\n\n    // check if the intersection point is within clip space\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param)\n    const isInClipSpace = zPos >= -1 && zPos <= 1\n\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5\n\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i)\n      _line.end.fromBufferAttribute(instanceEnd, i)\n\n      _line.start.applyMatrix4(matrixWorld)\n      _line.end.applyMatrix4(matrixWorld)\n\n      const pointOnLine = new Vector3()\n      const point = new Vector3()\n\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine)\n\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null,\n      })\n    }\n  }\n}\n\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 0xffffff })) {\n    super(geometry, material)\n\n    this.isLineSegments2 = true\n\n    this.type = 'LineSegments2'\n  }\n\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n  computeLineDistances() {\n    const geometry = this.geometry\n\n    const instanceStart = geometry.attributes.instanceStart\n    const instanceEnd = geometry.attributes.instanceEnd\n    const lineDistances = new Float32Array(2 * instanceStart.count)\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i)\n      _end.fromBufferAttribute(instanceEnd, i)\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1]\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end)\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1) // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)) // d0\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)) // d1\n\n    return this\n  }\n\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits\n    const camera = raycaster.camera\n\n    if (camera === null && !worldUnits) {\n      console.error(\n        'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.',\n      )\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0\n\n    _ray = raycaster.ray\n\n    const matrixWorld = this.matrixWorld\n    const geometry = this.geometry\n    const material = this.material\n\n    _lineWidth = material.linewidth + threshold\n\n    // check if we intersect the sphere bounds\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere()\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld)\n\n    // increase the sphere bounds by the worst case line screen space width\n    let sphereMargin\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin))\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution)\n    }\n\n    _sphere.radius += sphereMargin\n\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return\n    }\n\n    // check if we intersect the box bounds\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox()\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld)\n\n    // increase the box bounds by the worst case line width\n    let boxMargin\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin))\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution)\n    }\n\n    _box.expandByScalar(boxMargin)\n\n    if (_ray.intersectsBox(_box) === false) {\n      return\n    }\n\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects)\n    } else {\n      raycastScreenSpace(this, camera, intersects)\n    }\n  }\n\n  onBeforeRender(renderer) {\n    const uniforms = this.material.uniforms\n\n    if (uniforms && uniforms.resolution) {\n      renderer.getViewport(_viewport)\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w)\n    }\n  }\n}\n\nexport { LineSegments2 }\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { Vector3, Vector4, Vector2, Color } from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { LineSegments2, Line2, LineMaterial, LineSegmentsGeometry, LineGeometry } from 'three-stdlib';\n\nconst Line = /* @__PURE__ */React.forwardRef(function Line({\n  points,\n  color = 0xffffff,\n  vertexColors,\n  linewidth,\n  lineWidth,\n  segments,\n  dashed,\n  ...rest\n}, ref) {\n  var _vertexColors$, _ref;\n  const size = useThree(state => state.size);\n  const line2 = React.useMemo(() => segments ? new LineSegments2() : new Line2(), [segments]);\n  const [lineMaterial] = React.useState(() => new LineMaterial());\n  const itemSize = (vertexColors == null || (_vertexColors$ = vertexColors[0]) == null ? void 0 : _vertexColors$.length) === 4 ? 4 : 3;\n  const lineGeom = React.useMemo(() => {\n    const geom = segments ? new LineSegmentsGeometry() : new LineGeometry();\n    const pValues = points.map(p => {\n      const isArray = Array.isArray(p);\n      return p instanceof Vector3 || p instanceof Vector4 ? [p.x, p.y, p.z] : p instanceof Vector2 ? [p.x, p.y, 0] : isArray && p.length === 3 ? [p[0], p[1], p[2]] : isArray && p.length === 2 ? [p[0], p[1], 0] : p;\n    });\n    geom.setPositions(pValues.flat());\n    if (vertexColors) {\n      // using vertexColors requires the color value to be white see #1813\n      color = 0xffffff;\n      const cValues = vertexColors.map(c => c instanceof Color ? c.toArray() : c);\n      geom.setColors(cValues.flat(), itemSize);\n    }\n    return geom;\n  }, [points, segments, vertexColors, itemSize]);\n  React.useLayoutEffect(() => {\n    line2.computeLineDistances();\n  }, [points, line2]);\n  React.useLayoutEffect(() => {\n    if (dashed) {\n      lineMaterial.defines.USE_DASH = '';\n    } else {\n      // Setting lineMaterial.defines.USE_DASH to undefined is apparently not sufficient.\n      delete lineMaterial.defines.USE_DASH;\n    }\n    lineMaterial.needsUpdate = true;\n  }, [dashed, lineMaterial]);\n  React.useEffect(() => {\n    return () => {\n      lineGeom.dispose();\n      lineMaterial.dispose();\n    };\n  }, [lineGeom]);\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: line2,\n    ref: ref\n  }, rest), /*#__PURE__*/React.createElement(\"primitive\", {\n    object: lineGeom,\n    attach: \"geometry\"\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: lineMaterial,\n    attach: \"material\",\n    color: color,\n    vertexColors: Boolean(vertexColors),\n    resolution: [size.width, size.height],\n    linewidth: (_ref = linewidth !== null && linewidth !== void 0 ? linewidth : lineWidth) !== null && _ref !== void 0 ? _ref : 1,\n    dashed: dashed,\n    transparent: itemSize === 4\n  }, rest)));\n});\n\nexport { Line };\n","import { _ as _objectSpread2 } from './objectSpread2-284232a6.esm.js';\nimport { _ as _slicedToArray } from './triangle-b62b9067.esm.js';\nimport { Quaternion, Vector3 } from 'three';\nimport { l as lerp$1 } from './misc-19a3ec46.esm.js';\nimport { z as zero, a as add$1 } from './vector2-d2bf51f1.esm.js';\nimport { a as add } from './vector3-0a088b7f.esm.js';\n\nfunction swizzle(buffer) {\n  var stride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  var swizzle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"xyz\";\n  var o = {\n    x: 0,\n    y: 0,\n    z: 0\n  };\n\n  for (var _i = 0; _i < buffer.length; _i += stride) {\n    o.x = buffer[_i];\n    o.y = buffer[_i + 1];\n    o.z = buffer[_i + 2];\n\n    var _swizzle$split = swizzle.split(\"\"),\n        _swizzle$split2 = _slicedToArray(_swizzle$split, 3),\n        x = _swizzle$split2[0],\n        y = _swizzle$split2[1],\n        z = _swizzle$split2[2]; // TODO Fix this ugly type\n\n\n    buffer[_i] = o[x];\n    buffer[_i + 1] = o[y];\n\n    if (stride === 3) {\n      buffer[_i + 2] = o[z];\n    }\n  }\n\n  return buffer;\n}\n/**\n * @param buffer A stride 2 points buffer\n * @param valueGenerator A function that returns the value of the z axis at index i\n * @returns\n */\n\nfunction addAxis(buffer, size) {\n  var valueGenerator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n    return Math.random();\n  };\n  var newSize = size + 1;\n  var newBuffer = new Float32Array(buffer.length / size * newSize);\n\n  for (var _i2 = 0; _i2 < buffer.length; _i2 += size) {\n    var _j = _i2 / size * newSize;\n\n    newBuffer[_j] = buffer[_i2];\n    newBuffer[_j + 1] = buffer[_i2 + 1];\n\n    if (size === 2) {\n      newBuffer[_j + 2] = valueGenerator(_j);\n    }\n\n    if (size === 3) {\n      newBuffer[_j + 2] = buffer[_i2 + 2];\n      newBuffer[_j + 3] = valueGenerator(_j);\n    }\n  }\n\n  return newBuffer;\n}\n/**\n * Lerps bufferA and bufferB into final\n *\n * @param bufferA\n * @param bufferB\n * @param final\n * @param t\n */\n\nfunction lerp(bufferA, bufferB, _final, t) {\n  for (var _i3 = 0; _i3 < bufferA.length; _i3++) {\n    _final[_i3] = lerp$1(bufferA[_i3], bufferB[_i3], t);\n  }\n} // TODO add stride\n// TODO Fix types & vectors\n\n/**\n *\n * Translate all points in the passed buffer by the passed translactionVector.\n *\n * @param buffer\n * @param translationVector\n * @returns\n */\n\nfunction translate(buffer, translationVector) {\n  var stride = translationVector.length;\n\n  for (var _i4 = 0; _i4 < buffer.length; _i4 += stride) {\n    buffer[_i4] += translationVector[0];\n    buffer[_i4 + 1] += translationVector[1];\n    buffer[_i4 + 2] += translationVector[2];\n  }\n\n  return buffer;\n} // TODO add stride\n// TODO remove quaternion & vector3 dependencies\n\nfunction rotate(buffer, rotation) {\n  var defaultRotation = {\n    center: [0, 0, 0],\n    q: new Quaternion().identity()\n  };\n  var v = new Vector3();\n\n  var _defaultRotation$rota = _objectSpread2(_objectSpread2({}, defaultRotation), rotation),\n      q = _defaultRotation$rota.q,\n      center = _defaultRotation$rota.center;\n\n  for (var _i5 = 0; _i5 < buffer.length; _i5 += 3) {\n    v.set(buffer[_i5] - center[0], buffer[_i5 + 1] - center[1], buffer[_i5 + 2] - center[2]);\n    v.applyQuaternion(q);\n    buffer[_i5] = v.x + center[0];\n    buffer[_i5 + 1] = v.y + center[1];\n    buffer[_i5 + 2] = v.z + center[1];\n  }\n\n  return buffer;\n}\nfunction map(buffer, stride, callback) {\n  for (var _i6 = 0, _j2 = 0; _i6 < buffer.length; _i6 += stride, _j2++) {\n    if (stride === 3) {\n      var res = callback([buffer[_i6], buffer[_i6 + 1], buffer[_i6 + 2]], _j2);\n      buffer.set(res, _i6);\n    } else {\n      buffer.set(callback([buffer[_i6], buffer[_i6 + 1]], _j2), _i6);\n    }\n  }\n\n  return buffer;\n}\n/**\n * Reduces passed buffer\n */\n\nfunction reduce(b, stride, callback, acc) {\n  for (var _i7 = 0, _j3 = 0; _i7 < b.length; _i7 += stride, _j3++) {\n    if (stride === 2) {\n      acc = callback(acc, [b[_i7], b[_i7 + 1]], _j3);\n    } else {\n      acc = callback(acc, [b[_i7], b[_i7 + 1], b[_i7 + 2]], _j3);\n    }\n  }\n\n  return acc;\n}\nfunction expand(b, stride, opts) {\n  var defaultExpandOptions = {\n    center: [0, 0, 0]\n  };\n\n  var _defaultExpandOptions = _objectSpread2(_objectSpread2({}, defaultExpandOptions), opts),\n      center = _defaultExpandOptions.center,\n      distance = _defaultExpandOptions.distance;\n\n  for (var _i8 = 0; _i8 < b.length; _i8 += stride) {\n    /**\n     * 1. translate to origin (subtract the scaling center)\n     * 2. scale by the correct amount (multiply by a constant)\n     * 2. translate from origin (add the scaling center)\n     */\n    b[_i8] = (b[_i8] - center[0]) * (1 + distance) + center[0];\n    b[_i8 + 1] = (b[_i8 + 1] - center[1]) * (1 + distance) + center[1];\n\n    if (stride === 3) {\n      b[_i8 + 2] = (b[_i8 + 2] - center[1]) * (1 + distance) + center[2];\n    }\n  }\n\n  return b;\n}\nfunction center(myBuffer, stride) {\n  return reduce(myBuffer, stride, function (acc, point) {\n    if (stride === 3) {\n      // some type hacking is necessary to avoid type errors going from [n, n] => [n, n, n]\n      // but it's not an actual problem, as this path would always get a v3\n      acc = add(acc, point);\n    } else {\n      acc = add$1(acc, point);\n    }\n\n    return acc;\n  }, zero());\n}\nfunction sort(myBuffer, stride, callback) {\n  // 1. make an array of the correct size\n  var indices = Int16Array.from({\n    length: myBuffer.length / stride\n  }, function (_, i) {\n    return i;\n  }); // 2. sort the indices array\n\n  indices.sort(function (a, b) {\n    var pa = myBuffer.slice(a * stride, a * stride + stride);\n    var pb = myBuffer.slice(b * stride, b * stride + stride);\n    return callback(pa, pb);\n  }); // 3. make a copy of the original array to fetch indices from\n\n  var prevBuffer = myBuffer.slice(0); // 4. mutate the passed array\n\n  for (var _i9 = 0; _i9 < indices.length; _i9++) {\n    var _j4 = indices[_i9];\n    myBuffer.set(prevBuffer.slice(_j4 * stride, _j4 * stride + stride), _i9 * 3);\n  }\n\n  return myBuffer;\n}\n\nvar buffer = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  swizzle: swizzle,\n  addAxis: addAxis,\n  lerp: lerp,\n  translate: translate,\n  rotate: rotate,\n  map: map,\n  reduce: reduce,\n  expand: expand,\n  center: center,\n  sort: sort\n});\n\nexport { addAxis as a, buffer as b, reduce as c, center as d, expand as e, sort as f, lerp as l, map as m, rotate as r, swizzle as s, translate as t };\n"],"names":[],"mappings":"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AAI,GAAI,IAAK,IAAK,EAAG,IAAK,IAAK,GAAI,IAAK,GAAI,GAAI,IAAK,EAAG,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,IAAK,EAAG,IAAK,IAAK,IAAK,IAAK,GAAI,EAAG,GAAI,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,GAAI,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,GAAI,IAAK,GAAI,IAAK,GAAI,IAAK,IAAK,GAAI,GAAI,IAAK,GAAI,IAAK,IAAK,IAAK,GAAI,IAAK,IAAK,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,IAAK,IAAK,IAAK,GAAI,GAAI,GAAI,GAAI,IAAK,EAAG,IAAK,GAAI,GAAI,IAAK,GAAI,IAAK,IAAK,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,EAAG,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,EAAG,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,EAAG,GAAI,IAAK,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,IAAK,EAAG,IAAK,GAAI,GAAI,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,IAAK,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,GAAI,IAAK,IAAK,GAAI,IAAK,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,GAAI,GAAI,IAAK,EAAG,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,IAAK,IAAK,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,G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","ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]}