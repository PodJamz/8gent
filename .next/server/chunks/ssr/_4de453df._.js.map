{"version":3,"sources":["../../../../node_modules/.pnpm/three-stdlib%402.36.1_three%400.170.0/node_modules/src/controls/EventDispatcher.ts","../../../../node_modules/.pnpm/%40babel%2Bruntime%407.28.6/node_modules/%40babel/runtime/helpers/esm/extends.js","../../../../node_modules/.pnpm/%40react-three%2Bdrei%4010.7.7_%40react-three%2Bfiber%409.5.0_%40types%2Breact%4019.2.8_react-dom%4019.2.3_react%40_otfyaga7ti6f5mvznauek6nyga/node_modules/%40react-three/drei/core/Texture.js","../../../../node_modules/.pnpm/%40react-three%2Bdrei%4010.7.7_%40react-three%2Bfiber%409.5.0_%40types%2Breact%4019.2.8_react-dom%4019.2.3_react%40_otfyaga7ti6f5mvznauek6nyga/node_modules/%40react-three/drei/core/Float.js","../../../../node_modules/.pnpm/three-stdlib%402.36.1_three%400.170.0/node_modules/src/types/helpers.ts","../../../../node_modules/.pnpm/three-stdlib%402.36.1_three%400.170.0/node_modules/src/utils/BufferGeometryUtils.ts","../../../../src/components/gallery-3d/FloatingCards.tsx","../../../../node_modules/.pnpm/%40react-three%2Bdrei%4010.7.7_%40react-three%2Bfiber%409.5.0_%40types%2Breact%4019.2.8_react-dom%4019.2.3_react%40_otfyaga7ti6f5mvznauek6nyga/node_modules/%40react-three/drei/core/RoundedBox.js"],"sourcesContent":["/*\nDue to @types/three r168 breaking change\nwe have to manually copy the EventDispatcher class from three.js.\nSo this files merges the declarations from https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/three/src/core/EventDispatcher.d.ts\nwith the implementation from https://github.com/mrdoob/three.js/blob/dev/src/core/EventDispatcher.js\nMore info in https://github.com/pmndrs/three-stdlib/issues/387\n*/\n\n/**\n * The minimal basic Event that can be dispatched by a {@link EventDispatcher<>}.\n */\nexport interface BaseEvent<TEventType extends string = string> {\n    readonly type: TEventType;\n    // not defined in @types/three\n    target: any;\n}\n\n/**\n * The minimal expected contract of a fired Event that was dispatched by a {@link EventDispatcher<>}.\n */\nexport interface Event<TEventType extends string = string, TTarget = unknown> {\n    readonly type: TEventType;\n    readonly target: TTarget;\n}\n\nexport type EventListener<TEventData, TEventType extends string, TTarget> = (\n    event: TEventData & Event<TEventType, TTarget>,\n) => void;\n\nexport class EventDispatcher<TEventMap extends {} = {}> {\n    // not defined in @types/three\n    private _listeners: any;\n\n    /**\n     * Adds a listener to an event type.\n     * @param type The type of event to listen to.\n     * @param listener The function that gets called when the event is fired.\n     */\n\taddEventListener<T extends Extract<keyof TEventMap, string>>(\n        type: T,\n        listener: EventListener<TEventMap[T], T, this>,\n    ): void {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t}\n\n\t/**\n     * Checks if listener is added to an event type.\n     * @param type The type of event to listen to.\n     * @param listener The function that gets called when the event is fired.\n     */\n    hasEventListener<T extends Extract<keyof TEventMap, string>>(\n        type: T,\n        listener: EventListener<TEventMap[T], T, this>,\n    ): boolean {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tconst listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t}\n\n\t/**\n     * Removes a listener from an event type.\n     * @param type The type of the listener that gets removed.\n     * @param listener The listener function that gets removed.\n     */\n    removeEventListener<T extends Extract<keyof TEventMap, string>>(\n        type: T,\n        listener: EventListener<TEventMap[T], T, this>,\n    ): void {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n     * Fire an event type.\n     * @param event The event that gets fired.\n     */\n    dispatchEvent<T extends Extract<keyof TEventMap, string>>(event: BaseEvent<T> & TEventMap[T]): void {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t\tevent.target = null;\n\n\t\t}\n\n\t}\n\n}","function _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nexport { _extends as default };","import * as React from 'react';\nimport { useLayoutEffect, useEffect, useMemo } from 'react';\nimport { TextureLoader, Texture as Texture$1 } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\n\nconst IsObject = url => url === Object(url) && !Array.isArray(url) && typeof url !== 'function';\nfunction useTexture(input, onLoad) {\n  const gl = useThree(state => state.gl);\n  const textures = useLoader(TextureLoader, IsObject(input) ? Object.values(input) : input);\n  useLayoutEffect(() => {\n    onLoad == null || onLoad(textures);\n  }, [onLoad]);\n\n  // https://github.com/mrdoob/three.js/issues/22696\n  // Upload the texture to the GPU immediately instead of waiting for the first render\n  // NOTE: only available for WebGLRenderer\n  useEffect(() => {\n    if ('initTexture' in gl) {\n      let textureArray = [];\n      if (Array.isArray(textures)) {\n        textureArray = textures;\n      } else if (textures instanceof Texture$1) {\n        textureArray = [textures];\n      } else if (IsObject(textures)) {\n        textureArray = Object.values(textures);\n      }\n      textureArray.forEach(texture => {\n        if (texture instanceof Texture$1) {\n          gl.initTexture(texture);\n        }\n      });\n    }\n  }, [gl, textures]);\n  const mappedTextures = useMemo(() => {\n    if (IsObject(input)) {\n      const keyed = {};\n      let i = 0;\n      for (const key in input) keyed[key] = textures[i++];\n      return keyed;\n    } else {\n      return textures;\n    }\n  }, [input, textures]);\n  return mappedTextures;\n}\nuseTexture.preload = url => useLoader.preload(TextureLoader, url);\nuseTexture.clear = input => useLoader.clear(TextureLoader, input);\n\n//\n\nconst Texture = ({\n  children,\n  input,\n  onLoad\n}) => {\n  const ret = useTexture(input, onLoad);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children == null ? void 0 : children(ret));\n};\n\nexport { IsObject, Texture, useTexture };\n","import * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\n\nconst Float = /* @__PURE__ */React.forwardRef(({\n  children,\n  enabled = true,\n  speed = 1,\n  rotationIntensity = 1,\n  floatIntensity = 1,\n  floatingRange = [-0.1, 0.1],\n  autoInvalidate = false,\n  ...props\n}, forwardRef) => {\n  const ref = React.useRef(null);\n  React.useImperativeHandle(forwardRef, () => ref.current, []);\n  const offset = React.useRef(Math.random() * 10000);\n  useFrame(state => {\n    var _floatingRange$, _floatingRange$2;\n    if (!enabled || speed === 0) return;\n    if (autoInvalidate) state.invalidate();\n    const t = offset.current + state.clock.elapsedTime;\n    ref.current.rotation.x = Math.cos(t / 4 * speed) / 8 * rotationIntensity;\n    ref.current.rotation.y = Math.sin(t / 4 * speed) / 8 * rotationIntensity;\n    ref.current.rotation.z = Math.sin(t / 4 * speed) / 20 * rotationIntensity;\n    let yPosition = Math.sin(t / 4 * speed) / 10;\n    yPosition = THREE.MathUtils.mapLinear(yPosition, -0.1, 0.1, (_floatingRange$ = floatingRange == null ? void 0 : floatingRange[0]) !== null && _floatingRange$ !== void 0 ? _floatingRange$ : -0.1, (_floatingRange$2 = floatingRange == null ? void 0 : floatingRange[1]) !== null && _floatingRange$2 !== void 0 ? _floatingRange$2 : 0.1);\n    ref.current.position.y = yPosition * floatIntensity;\n    ref.current.updateMatrix();\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    ref: ref,\n    matrixAutoUpdate: false\n  }, children));\n});\n\nexport { Float };\n","export const getWithKey = <T, K extends keyof T>(obj: T, key: K): T[K] => obj[key]\n","import {\n  BufferAttribute,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  TrianglesDrawMode,\n  Vector3,\n  Mesh,\n  Line,\n  Points,\n  Material,\n  SkinnedMesh,\n} from 'three'\n\nimport { getWithKey } from '../types/helpers'\nimport type { TypedArrayConstructors, TypedArray } from '../types/shared'\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nexport const mergeBufferGeometries = (geometries: BufferGeometry[], useGroups?: boolean): BufferGeometry | null => {\n  const isIndexed = geometries[0].index !== null\n\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes))\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes))\n\n  const attributes: { [key: string]: Array<InterleavedBufferAttribute | BufferAttribute> } = {}\n  const morphAttributes: { [key: string]: Array<BufferAttribute | InterleavedBufferAttribute>[] } = {}\n\n  const morphTargetsRelative = geometries[0].morphTargetsRelative\n\n  const mergedGeometry = new BufferGeometry()\n\n  let offset = 0\n\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0\n\n    // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.',\n      )\n      return null\n    }\n\n    // gather attributes, exit early if they're different\n\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. All geometries must have compatible attributes; make sure \"' +\n            name +\n            '\" attribute exists among all geometries, or in none of them.',\n        )\n        return null\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = []\n      }\n\n      attributes[name].push(geom.attributes[name])\n\n      attributesCount++\n    }\n\n    // ensure geometries have the same number of attributes\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. Make sure all geometries have the same number of attributes.',\n      )\n      return null\n    }\n\n    // gather morph attributes, exit early if they're different\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. .morphTargetsRelative must be consistent throughout all geometries.',\n      )\n      return null\n    }\n\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '.  .morphAttributes must be consistent throughout all geometries.',\n        )\n        return null\n      }\n\n      if (morphAttributes[name] === undefined) morphAttributes[name] = []\n\n      morphAttributes[name].push(geom.morphAttributes[name])\n    }\n\n    // gather .userData\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || []\n    mergedGeometry.userData.mergedUserData.push(geom.userData)\n\n    if (useGroups) {\n      let count\n\n      if (geom.index) {\n        count = geom.index.count\n      } else if (geom.attributes.position !== undefined) {\n        count = geom.attributes.position.count\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. The geometry must have either an index or a position attribute',\n        )\n        return null\n      }\n\n      mergedGeometry.addGroup(offset, count, i)\n\n      offset += count\n    }\n  })\n\n  // merge indices\n\n  if (isIndexed) {\n    let indexOffset = 0\n    const mergedIndex: number[] = []\n\n    geometries.forEach((geom) => {\n      const index = geom.index as BufferAttribute\n\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset)\n      }\n\n      indexOffset += geom.attributes.position.count\n    })\n\n    mergedGeometry.setIndex(mergedIndex)\n  }\n\n  // merge attributes\n\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name] as BufferAttribute[])\n\n    if (!mergedAttribute) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.',\n      )\n      return null\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute)\n  }\n\n  // merge morph attributes\n\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length\n\n    if (numMorphTargets === 0) break\n\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {}\n    mergedGeometry.morphAttributes[name] = []\n\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = []\n\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i])\n      }\n\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge as BufferAttribute[])\n\n      if (!mergedMorphAttribute) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' +\n            name +\n            ' morphAttribute.',\n        )\n        return null\n      }\n\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)\n    }\n  }\n\n  return mergedGeometry\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nexport const mergeBufferAttributes = (attributes: BufferAttribute[]): BufferAttribute | null | undefined => {\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let itemSize: number | undefined = undefined\n  let normalized: boolean | undefined = undefined\n  let arrayLength = 0\n\n  attributes.forEach((attr) => {\n    if (TypedArray === undefined) {\n      TypedArray = attr.array.constructor\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.',\n      )\n      return null\n    }\n\n    if (itemSize === undefined) itemSize = attr.itemSize\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    if (normalized === undefined) normalized = attr.normalized\n    if (normalized !== attr.normalized) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    arrayLength += attr.array.length\n  })\n\n  if (TypedArray && itemSize) {\n    // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n    const array = new TypedArray(arrayLength)\n    let offset = 0\n\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset)\n      offset += attr.array.length\n    })\n\n    return new BufferAttribute(array, itemSize, normalized)\n  }\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nexport const interleaveAttributes = (attributes: BufferAttribute[]): InterleavedBufferAttribute[] | null => {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let arrayLength = 0\n  let stride = 0\n\n  // calculate the the length and type of the interleavedBuffer\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i]\n\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved')\n      return null\n    }\n\n    arrayLength += attribute.array.length\n    stride += attribute.itemSize\n  }\n\n  // Create the set of buffer attributes\n  // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride)\n  let offset = 0\n  const res = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n  const setters = ['setX', 'setY', 'setZ', 'setW']\n\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j]\n    const itemSize = attribute.itemSize\n    const count = attribute.count\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized)\n    res.push(iba)\n\n    offset += itemSize\n\n    // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k] as keyof InterleavedBufferAttribute) as InterleavedBufferAttribute[\n          | 'setX'\n          | 'setY'\n          | 'setZ'\n          | 'setW']\n        const get = getWithKey(attribute, getters[k] as keyof BufferAttribute) as BufferAttribute[\n          | 'getX'\n          | 'getY'\n          | 'getZ'\n          | 'getW']\n        set(c, get(c))\n      }\n    }\n  }\n\n  return res\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nexport function estimateBytesUsed(geometry: BufferGeometry): number {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name)\n    mem += attr.count * attr.itemSize * (attr.array as TypedArray).BYTES_PER_ELEMENT\n  }\n\n  const indices = geometry.getIndex()\n  mem += indices ? indices.count * indices.itemSize * (indices.array as TypedArray).BYTES_PER_ELEMENT : 0\n  return mem\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nexport function mergeVertices(geometry: BufferGeometry, tolerance = 1e-4): BufferGeometry {\n  tolerance = Math.max(tolerance, Number.EPSILON)\n\n  // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n  const hashToIndex: {\n    [key: string]: number\n  } = {}\n  const indices = geometry.getIndex()\n  const positions = geometry.getAttribute('position')\n  const vertexCount = indices ? indices.count : positions.count\n\n  // next value for triangle indices\n  let nextIndex = 0\n\n  // attributes and new attribute arrays\n  const attributeNames = Object.keys(geometry.attributes)\n  const attrArrays: {\n    [key: string]: []\n  } = {}\n  const morphAttrsArrays: {\n    [key: string]: Array<Array<BufferAttribute | InterleavedBufferAttribute>>\n  } = {}\n  const newIndices = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n\n  // initialize the arrays\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n\n    attrArrays[name] = []\n\n    const morphAttr = geometry.morphAttributes[name]\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => [])\n    }\n  }\n\n  // convert the error tolerance to an amount of decimal places to truncate to\n  const decimalShift = Math.log10(1 / tolerance)\n  const shiftMultiplier = Math.pow(10, decimalShift)\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i\n\n    // Generate a hash for the vertex attributes at the current index 'i'\n    let hash = ''\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j]\n      const attribute = geometry.getAttribute(name)\n      const itemSize = attribute.itemSize\n\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        // @ts-ignore no\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`\n      }\n    }\n\n    // Add another reference to the vertex if it's already\n    // used by another index\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash])\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j]\n        const attribute = geometry.getAttribute(name)\n        const morphAttr = geometry.morphAttributes[name]\n        const itemSize = attribute.itemSize\n        const newarray = attrArrays[name]\n        const newMorphArrays = morphAttrsArrays[name]\n\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k]\n          // @ts-ignore\n          newarray.push(attribute[getterFunc](index))\n\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              // @ts-ignore\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index))\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex\n      newIndices.push(nextIndex)\n      nextIndex++\n    }\n  }\n\n  // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n  const result = geometry.clone()\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n    const oldAttribute = geometry.getAttribute(name)\n    //@ts-expect-error  something to do with functions and constructors and new\n    const buffer = new (oldAttribute.array as TypedArray).constructor(attrArrays[name])\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized)\n\n    result.setAttribute(name, attribute)\n\n    // Update the attribute arrays\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j]\n        //@ts-expect-error something to do with functions and constructors and new\n        const buffer = new (oldMorphAttribute.array as TypedArray).constructor(morphAttrsArrays[name][j])\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized)\n        result.morphAttributes[name][j] = morphAttribute\n      }\n    }\n  }\n\n  // indices\n\n  result.setIndex(newIndices)\n\n  return result\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nexport function toTrianglesDrawMode(geometry: BufferGeometry, drawMode: number): BufferGeometry {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.')\n    return geometry\n  }\n\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex()\n\n    // generate index if not present\n\n    if (index === null) {\n      const indices = []\n\n      const position = geometry.getAttribute('position')\n\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i)\n        }\n\n        geometry.setIndex(indices)\n        index = geometry.getIndex()\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',\n        )\n        return geometry\n      }\n    }\n\n    //\n\n    const numberOfTriangles = (index as BufferAttribute).count - 2\n    const newIndices = []\n\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0))\n          newIndices.push(index.getX(i))\n          newIndices.push(index.getX(i + 1))\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i + 2))\n          } else {\n            newIndices.push(index.getX(i + 2))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i))\n          }\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.')\n    }\n\n    // build final geometry\n\n    const newGeometry = geometry.clone()\n    newGeometry.setIndex(newIndices)\n    newGeometry.clearGroups()\n\n    return newGeometry\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode)\n    return geometry\n  }\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nexport type ComputedMorphedAttribute = {\n  positionAttribute: BufferAttribute | InterleavedBufferAttribute\n  normalAttribute: BufferAttribute | InterleavedBufferAttribute\n  morphedPositionAttribute: Float32BufferAttribute\n  morphedNormalAttribute: Float32BufferAttribute\n}\n\nexport function computeMorphedAttributes(object: Mesh | Line | Points): ComputedMorphedAttribute | null {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.')\n    return null\n  }\n\n  const _vA = new Vector3()\n  const _vB = new Vector3()\n  const _vC = new Vector3()\n\n  const _tempA = new Vector3()\n  const _tempB = new Vector3()\n  const _tempC = new Vector3()\n\n  const _morphA = new Vector3()\n  const _morphB = new Vector3()\n  const _morphC = new Vector3()\n\n  function _calculateMorphedAttributeData(\n    object: Mesh | Line | Points,\n    material: Material,\n    attribute: BufferAttribute | InterleavedBufferAttribute,\n    morphAttribute: (BufferAttribute | InterleavedBufferAttribute)[],\n    morphTargetsRelative: boolean,\n    a: number,\n    b: number,\n    c: number,\n    modifiedAttributeArray: Float32Array,\n  ): void {\n    _vA.fromBufferAttribute(attribute, a)\n    _vB.fromBufferAttribute(attribute, b)\n    _vC.fromBufferAttribute(attribute, c)\n\n    const morphInfluences = object.morphTargetInfluences\n\n    if (\n      // @ts-ignore\n      material.morphTargets &&\n      morphAttribute &&\n      morphInfluences\n    ) {\n      _morphA.set(0, 0, 0)\n      _morphB.set(0, 0, 0)\n      _morphC.set(0, 0, 0)\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i]\n        const morph = morphAttribute[i]\n\n        if (influence === 0) continue\n\n        _tempA.fromBufferAttribute(morph, a)\n        _tempB.fromBufferAttribute(morph, b)\n        _tempC.fromBufferAttribute(morph, c)\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence)\n          _morphB.addScaledVector(_tempB, influence)\n          _morphC.addScaledVector(_tempC, influence)\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence)\n          _morphB.addScaledVector(_tempB.sub(_vB), influence)\n          _morphC.addScaledVector(_tempC.sub(_vC), influence)\n        }\n      }\n\n      _vA.add(_morphA)\n      _vB.add(_morphB)\n      _vC.add(_morphC)\n    }\n\n    if ((object as SkinnedMesh).isSkinnedMesh) {\n      // @ts-ignore – https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(a, _vA)\n      // @ts-ignore – https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(b, _vB)\n      // @ts-ignore – https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(c, _vC)\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x\n    modifiedAttributeArray[a * 3 + 1] = _vA.y\n    modifiedAttributeArray[a * 3 + 2] = _vA.z\n    modifiedAttributeArray[b * 3 + 0] = _vB.x\n    modifiedAttributeArray[b * 3 + 1] = _vB.y\n    modifiedAttributeArray[b * 3 + 2] = _vB.z\n    modifiedAttributeArray[c * 3 + 0] = _vC.x\n    modifiedAttributeArray[c * 3 + 1] = _vC.y\n    modifiedAttributeArray[c * 3 + 2] = _vC.z\n  }\n\n  const geometry = object.geometry\n  const material = object.material\n\n  let a, b, c\n  const index = geometry.index\n  const positionAttribute = geometry.attributes.position\n  const morphPosition = geometry.morphAttributes.position\n  const morphTargetsRelative = geometry.morphTargetsRelative\n  const normalAttribute = geometry.attributes.normal\n  const morphNormal = geometry.morphAttributes.position\n\n  const groups = geometry.groups\n  const drawRange = geometry.drawRange\n  let i, j, il, jl\n  let group, groupMaterial\n  let start, end\n\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize)\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize)\n\n  if (index !== null) {\n    // indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j)\n          b = index.getX(j + 1)\n          c = index.getX(j + 2)\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(index.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i)\n        b = index.getX(i + 1)\n        c = index.getX(i + 2)\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  } else if (positionAttribute !== undefined) {\n    // non-indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j\n          b = j + 1\n          c = j + 2\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i\n        b = i + 1\n        c = i + 2\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  }\n\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3)\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3)\n\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute,\n  }\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * Backwards compatible with code such as @react-three/drei's `<RoundedBox>`\n * which uses this method to operate on the original geometry.\n *\n * As of this writing, BufferGeometry.toNonIndexed() warns if the geometry is\n * non-indexed and returns `this`, i.e. the same geometry on which it was called:\n * `BufferGeometry is already non-indexed.`\n *\n * @param geometry\n * @param creaseAngle\n */\nexport function toCreasedNormals(geometry: BufferGeometry, creaseAngle = Math.PI / 3 /* 60 degrees */): BufferGeometry {\n  const creaseDot = Math.cos(creaseAngle)\n  const hashMultiplier = (1 + 1e-10) * 1e2\n\n  // reusable vectors\n  const verts = [new Vector3(), new Vector3(), new Vector3()]\n  const tempVec1 = new Vector3()\n  const tempVec2 = new Vector3()\n  const tempNorm = new Vector3()\n  const tempNorm2 = new Vector3()\n\n  // hashes a vector\n  function hashVertex(v: Vector3): string {\n    const x = ~~(v.x * hashMultiplier)\n    const y = ~~(v.y * hashMultiplier)\n    const z = ~~(v.z * hashMultiplier)\n    return `${x},${y},${z}`\n  }\n\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry\n  const posAttr = resultGeometry.attributes.position\n  const vertexMap: { [key: string]: Vector3[] } = {}\n\n  // find all the normals shared by commonly located vertices\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    // add the normal to the map for all vertices\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize()\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = []\n      }\n\n      vertexMap[hash].push(normal)\n    }\n  }\n\n  // average normals from all vertices that share a common location if they are within the\n  // provided crease threshold\n  const normalArray = new Float32Array(posAttr.count * 3)\n  const normAttr = new BufferAttribute(normalArray, 3, false)\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    // get the face normal for this vertex\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize()\n\n    // average all normals that meet the threshold and set the normal value\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      const otherNormals = vertexMap[hash]\n      tempNorm2.set(0, 0, 0)\n\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k]\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm)\n        }\n      }\n\n      tempNorm2.normalize()\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z)\n    }\n  }\n\n  resultGeometry.setAttribute('normal', normAttr)\n  return resultGeometry\n}\n","'use client';\n\nimport { useRef, useMemo, useState, useEffect } from 'react';\nimport { Canvas, useFrame, useThree } from '@react-three/fiber';\nimport { useTexture, Html, Float, OrbitControls, RoundedBox } from '@react-three/drei';\nimport * as THREE from 'three';\nimport type { GalleryImage, AudioReactiveData } from './types';\nimport { lerp } from './utils';\n\ninterface FloatingCardsProps {\n  images: GalleryImage[];\n  className?: string;\n  cardWidth?: number;\n  cardHeight?: number;\n  spread?: number;\n  floatSpeed?: number;\n  floatIntensity?: number;\n  onImageClick?: (image: GalleryImage, index: number) => void;\n  audioData?: AudioReactiveData;\n}\n\ninterface Card3DProps {\n  image: GalleryImage;\n  position: [number, number, number];\n  rotation: [number, number, number];\n  index: number;\n  cardWidth: number;\n  cardHeight: number;\n  floatSpeed: number;\n  floatIntensity: number;\n  isHovered: boolean;\n  isSelected: boolean;\n  onHover: (index: number | null) => void;\n  onClick: () => void;\n}\n\nfunction Card3D({\n  image,\n  position,\n  rotation,\n  index,\n  cardWidth,\n  cardHeight,\n  floatSpeed,\n  floatIntensity,\n  isHovered,\n  isSelected,\n  onHover,\n  onClick,\n}: Card3DProps) {\n  const groupRef = useRef<THREE.Group>(null);\n  const cardRef = useRef<THREE.Mesh>(null);\n  const texture = useTexture(image.src);\n  const [cardRotation, setCardRotation] = useState({ x: 0, y: 0 });\n\n  // Adjust texture aspect\n  const aspect = texture.image ? texture.image.width / texture.image.height : 1;\n  const imgWidth = aspect > 1 ? cardWidth * 0.9 : (cardWidth * 0.9 * aspect);\n  const imgHeight = aspect > 1 ? (cardHeight * 0.85) / aspect : cardHeight * 0.85;\n\n  useFrame((state, delta) => {\n    if (!groupRef.current || !cardRef.current) return;\n\n    // Smooth scale animation\n    const targetScale = isSelected ? 1.4 : isHovered ? 1.15 : 1;\n    groupRef.current.scale.x = lerp(groupRef.current.scale.x, targetScale, delta * 6);\n    groupRef.current.scale.y = lerp(groupRef.current.scale.y, targetScale, delta * 6);\n    groupRef.current.scale.z = lerp(groupRef.current.scale.z, targetScale, delta * 6);\n\n    // Card tilt on hover\n    if (isHovered) {\n      const time = state.clock.elapsedTime;\n      setCardRotation({\n        x: Math.sin(time * 2) * 0.05,\n        y: Math.cos(time * 2) * 0.05,\n      });\n    } else {\n      setCardRotation({ x: 0, y: 0 });\n    }\n\n    cardRef.current.rotation.x = lerp(cardRef.current.rotation.x, cardRotation.x, delta * 5);\n    cardRef.current.rotation.y = lerp(cardRef.current.rotation.y, cardRotation.y, delta * 5);\n  });\n\n  const cardDepth = 0.02;\n\n  return (\n    <Float\n      speed={floatSpeed}\n      rotationIntensity={0.2}\n      floatIntensity={floatIntensity}\n      floatingRange={[-0.1, 0.1]}\n    >\n      <group\n        ref={groupRef}\n        position={position}\n        rotation={rotation}\n        onPointerEnter={() => onHover(index)}\n        onPointerLeave={() => onHover(null)}\n        onClick={onClick}\n      >\n        <mesh ref={cardRef}>\n          {/* Card body */}\n          <RoundedBox args={[cardWidth, cardHeight, cardDepth]} radius={0.05} smoothness={4}>\n            <meshStandardMaterial\n              color={isHovered ? '#ffffff' : '#f8fafc'}\n              metalness={0.1}\n              roughness={0.3}\n            />\n          </RoundedBox>\n\n          {/* Image on card */}\n          <mesh position={[0, 0.05, cardDepth / 2 + 0.001]}>\n            <planeGeometry args={[imgWidth, imgHeight]} />\n            <meshStandardMaterial map={texture} />\n          </mesh>\n\n          {/* Card shadow */}\n          <mesh position={[0.05, -0.05, -cardDepth]} rotation={[0, 0, 0]}>\n            <RoundedBox args={[cardWidth, cardHeight, 0.01]} radius={0.05} smoothness={4}>\n              <meshBasicMaterial color=\"#000000\" transparent opacity={0.15} />\n            </RoundedBox>\n          </mesh>\n\n          {/* Title strip at bottom */}\n          {image.alt && (\n            <mesh position={[0, -cardHeight / 2 + 0.15, cardDepth / 2 + 0.002]}>\n              <planeGeometry args={[cardWidth - 0.2, 0.2]} />\n              <meshBasicMaterial color=\"#1e1b4b\" />\n            </mesh>\n          )}\n        </mesh>\n\n        {/* Glow effect on selection */}\n        {isSelected && (\n          <mesh position={[0, 0, -0.02]}>\n            <RoundedBox args={[cardWidth + 0.15, cardHeight + 0.15, 0.01]} radius={0.08} smoothness={4}>\n              <meshBasicMaterial color=\"#4f46e5\" transparent opacity={0.4} />\n            </RoundedBox>\n          </mesh>\n        )}\n\n        {/* Hover label */}\n        {isHovered && image.alt && (\n          <Html center position={[0, -cardHeight / 2 - 0.3, 0]}>\n            <div className=\"bg-slate-900/95 text-white px-4 py-2 rounded-xl text-sm whitespace-nowrap shadow-xl border border-indigo-500/30\">\n              <span className=\"font-medium\">{image.alt}</span>\n              {image.description && (\n                <p className=\"text-slate-400 text-xs mt-1\">{image.description}</p>\n              )}\n            </div>\n          </Html>\n        )}\n      </group>\n    </Float>\n  );\n}\n\ninterface CardsSceneProps {\n  images: GalleryImage[];\n  cardWidth: number;\n  cardHeight: number;\n  spread: number;\n  floatSpeed: number;\n  floatIntensity: number;\n  onImageClick?: (image: GalleryImage, index: number) => void;\n  audioData?: AudioReactiveData;\n}\n\nfunction CardsScene({\n  images,\n  cardWidth,\n  cardHeight,\n  spread,\n  floatSpeed,\n  floatIntensity,\n  onImageClick,\n  audioData,\n}: CardsSceneProps) {\n  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);\n  const [selectedIndex, setSelectedIndex] = useState<number | null>(null);\n\n  // Generate card positions in a scattered but organized manner\n  const cardConfigs = useMemo(() => {\n    return images.map((_, i) => {\n      const cols = Math.ceil(Math.sqrt(images.length));\n      const row = Math.floor(i / cols);\n      const col = i % cols;\n\n      // Base grid position with offset\n      const baseX = (col - (cols - 1) / 2) * (cardWidth + 0.5) * spread;\n      const baseY = (row - Math.floor(images.length / cols) / 2) * (cardHeight + 0.4) * spread;\n      const baseZ = (Math.random() - 0.5) * 2;\n\n      // Add some randomness\n      const x = baseX + (Math.random() - 0.5) * 0.5;\n      const y = baseY + (Math.random() - 0.5) * 0.3;\n      const z = baseZ;\n\n      // Slight random rotation\n      const rotX = (Math.random() - 0.5) * 0.2;\n      const rotY = (Math.random() - 0.5) * 0.3;\n      const rotZ = (Math.random() - 0.5) * 0.1;\n\n      return {\n        position: [x, y, z] as [number, number, number],\n        rotation: [rotX, rotY, rotZ] as [number, number, number],\n      };\n    });\n  }, [images.length, cardWidth, cardHeight, spread]);\n\n  return (\n    <>\n      {/* Soft lighting with audio reactivity */}\n      <ambientLight intensity={audioData?.enabled ? 0.5 + audioData.energy * 0.3 : 0.6} />\n      <directionalLight\n        position={[5, 10, 5]}\n        intensity={audioData?.enabled ? 0.8 + audioData.treble * 0.4 : 1}\n        castShadow\n        color={audioData?.enabled ? `hsl(${240 + audioData.mid * 40}, 70%, 80%)` : '#ffffff'}\n      />\n      <directionalLight position={[-5, 5, -5]} intensity={audioData?.enabled ? 0.2 + audioData.bass * 0.3 : 0.3} color=\"#4f46e5\" />\n      <pointLight position={[0, 0, 5]} intensity={audioData?.enabled ? 0.4 + audioData.mid * 0.4 : 0.5} color=\"#06b6d4\" />\n\n      {/* Cards */}\n      {images.map((image, index) => (\n        <Card3D\n          key={`${image.src}-${index}`}\n          image={image}\n          position={cardConfigs[index].position}\n          rotation={cardConfigs[index].rotation}\n          index={index}\n          cardWidth={cardWidth}\n          cardHeight={cardHeight}\n          floatSpeed={floatSpeed}\n          floatIntensity={floatIntensity}\n          isHovered={hoveredIndex === index}\n          isSelected={selectedIndex === index}\n          onHover={setHoveredIndex}\n          onClick={() => {\n            setSelectedIndex(selectedIndex === index ? null : index);\n            onImageClick?.(image, index);\n          }}\n        />\n      ))}\n\n      {/* Decorative background elements */}\n      <BackgroundElements spread={spread * 3} audioData={audioData} />\n\n      {/* Orbit controls */}\n      <OrbitControls\n        enablePan={true}\n        enableZoom={true}\n        minDistance={3}\n        maxDistance={20}\n        maxPolarAngle={Math.PI / 1.5}\n        minPolarAngle={Math.PI / 4}\n      />\n    </>\n  );\n}\n\nfunction BackgroundElements({ spread, audioData }: { spread: number; audioData?: AudioReactiveData }) {\n  const groupRef = useRef<THREE.Group>(null);\n\n  // Create floating geometric shapes\n  const shapes = useMemo(() => {\n    const items = [];\n    for (let i = 0; i < 20; i++) {\n      items.push({\n        position: [\n          (Math.random() - 0.5) * spread,\n          (Math.random() - 0.5) * spread,\n          (Math.random() - 0.5) * spread - 5,\n        ] as [number, number, number],\n        scale: 0.1 + Math.random() * 0.2,\n        type: Math.random() > 0.5 ? 'box' : 'sphere',\n      });\n    }\n    return items;\n  }, [spread]);\n\n  useFrame((state) => {\n    if (groupRef.current) {\n      let rotSpeed = state.clock.elapsedTime * 0.02;\n\n      if (audioData?.enabled) {\n        rotSpeed *= 1 + audioData.energy * 2;\n      }\n\n      groupRef.current.rotation.y = rotSpeed;\n    }\n  });\n\n  return (\n    <group ref={groupRef}>\n      {shapes.map((shape, i) => (\n        <Float\n          key={i}\n          speed={audioData?.enabled ? 1 + audioData.energy * 2 : 1}\n          floatIntensity={audioData?.enabled ? 0.5 + audioData.beatIntensity * 0.5 : 0.5}\n        >\n          <mesh position={shape.position} scale={audioData?.enabled ? shape.scale * (1 + audioData.bass * 0.5) : shape.scale}>\n            {shape.type === 'box' ? (\n              <boxGeometry args={[1, 1, 1]} />\n            ) : (\n              <sphereGeometry args={[0.5, 16, 16]} />\n            )}\n            <meshStandardMaterial\n              color={audioData?.enabled ? `hsl(${260 + audioData.mid * 60}, 70%, 50%)` : '#4f46e5'}\n              transparent\n              opacity={audioData?.enabled ? 0.1 + audioData.energy * 0.2 : 0.1}\n              wireframe\n            />\n          </mesh>\n        </Float>\n      ))}\n    </group>\n  );\n}\n\nfunction FallbackGallery({ images }: { images: GalleryImage[] }) {\n  return (\n    <div className=\"w-full h-full bg-gradient-to-br from-slate-100 to-indigo-50 p-8 overflow-y-auto\">\n      <div className=\"grid grid-cols-2 md:grid-cols-3 gap-6 max-w-4xl mx-auto\">\n        {images.map((img, i) => (\n          <div\n            key={i}\n            className=\"bg-white rounded-xl shadow-lg p-3 transform hover:scale-105 hover:-rotate-1 transition-all duration-300\"\n          >\n            <img\n              src={img.src}\n              alt={img.alt || ''}\n              className=\"w-full h-40 object-cover rounded-lg\"\n            />\n            {img.alt && (\n              <p className=\"text-slate-700 text-sm mt-2 font-medium\">{img.alt}</p>\n            )}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default function FloatingCards({\n  images,\n  className = 'w-full h-[600px]',\n  cardWidth = 1.8,\n  cardHeight = 2.4,\n  spread = 1,\n  floatSpeed = 2,\n  floatIntensity = 0.3,\n  onImageClick,\n  audioData,\n}: FloatingCardsProps) {\n  const [webglSupported, setWebglSupported] = useState(true);\n\n  useEffect(() => {\n    try {\n      const canvas = document.createElement('canvas');\n      if (!canvas.getContext('webgl') && !canvas.getContext('experimental-webgl')) {\n        setWebglSupported(false);\n      }\n    } catch {\n      setWebglSupported(false);\n    }\n  }, []);\n\n  if (!webglSupported) {\n    return (\n      <div className={className}>\n        <FallbackGallery images={images} />\n      </div>\n    );\n  }\n\n  return (\n    <div className={className}>\n      <Canvas\n        camera={{ position: [0, 0, 8], fov: 50 }}\n        shadows\n        gl={{ antialias: true, alpha: true }}\n        style={{ background: 'linear-gradient(135deg, #f8fafc 0%, #e0e7ff 50%, #f8fafc 100%)' }}\n      >\n        <CardsScene\n          images={images}\n          cardWidth={cardWidth}\n          cardHeight={cardHeight}\n          spread={spread}\n          floatSpeed={audioData?.enabled ? floatSpeed * (1 + audioData.energy) : floatSpeed}\n          floatIntensity={audioData?.enabled ? floatIntensity * (1 + audioData.beatIntensity) : floatIntensity}\n          onImageClick={onImageClick}\n          audioData={audioData}\n        />\n      </Canvas>\n    </div>\n  );\n}\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { Shape } from 'three';\nimport { toCreasedNormals } from 'three-stdlib';\n\nconst eps = 0.00001;\nfunction createShape(width, height, radius0) {\n  const shape = new Shape();\n  const radius = radius0 - eps;\n  shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);\n  shape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);\n  shape.absarc(width - radius * 2, height - radius * 2, eps, Math.PI / 2, 0, true);\n  shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);\n  return shape;\n}\nconst RoundedBox = /* @__PURE__ */React.forwardRef(function RoundedBox({\n  args: [width = 1, height = 1, depth = 1] = [],\n  radius = 0.05,\n  steps = 1,\n  smoothness = 4,\n  bevelSegments = 4,\n  creaseAngle = 0.4,\n  children,\n  ...rest\n}, ref) {\n  return /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: ref\n  }, rest), /*#__PURE__*/React.createElement(RoundedBoxGeometry, {\n    args: [width, height, depth],\n    radius: radius,\n    steps: steps,\n    smoothness: smoothness,\n    bevelSegments: bevelSegments,\n    creaseAngle: creaseAngle\n  }), children);\n});\nconst RoundedBoxGeometry = /* @__PURE__ */React.forwardRef(function RoundedBoxGeometry({\n  args: [width = 1, height = 1, depth = 1] = [],\n  radius = 0.05,\n  steps = 1,\n  smoothness = 4,\n  bevelSegments = 4,\n  creaseAngle = 0.4,\n  ...rest\n}, ref) {\n  const shape = React.useMemo(() => createShape(width, height, radius), [width, height, radius]);\n  const params = React.useMemo(() => ({\n    depth: depth - radius * 2,\n    bevelEnabled: true,\n    bevelSegments: bevelSegments * 2,\n    steps,\n    bevelSize: radius - eps,\n    bevelThickness: radius,\n    curveSegments: smoothness\n  }), [depth, radius, smoothness, bevelSegments, steps]);\n  const geomRef = React.useRef(null);\n  React.useLayoutEffect(() => {\n    if (geomRef.current) {\n      geomRef.current.center();\n      toCreasedNormals(geomRef.current, creaseAngle);\n    }\n  }, [shape, params, creaseAngle]);\n  React.useImperativeHandle(ref, () => geomRef.current);\n  return /*#__PURE__*/React.createElement(\"extrudeGeometry\", _extends({\n    ref: geomRef,\n    args: [shape, params]\n  }, rest));\n});\n\nexport { RoundedBox, RoundedBoxGeometry };\n"],"names":["buffer","object","material","morphTargetsRelative","a","b","c","i","il"],"mappings":"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","ignoreList":[1,2,3,4,5,7]}