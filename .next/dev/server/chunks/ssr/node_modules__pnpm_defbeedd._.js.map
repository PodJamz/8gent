{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Bcore%400.5.2_zod%404.3.6/node_modules/%40json-render/core/src/types.ts","file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Bcore%400.5.2_zod%404.3.6/node_modules/%40json-render/core/src/visibility.ts","file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Bcore%400.5.2_zod%404.3.6/node_modules/%40json-render/core/src/props.ts","file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Bcore%400.5.2_zod%404.3.6/node_modules/%40json-render/core/src/actions.ts","file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Bcore%400.5.2_zod%404.3.6/node_modules/%40json-render/core/src/validation.ts","file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Bcore%400.5.2_zod%404.3.6/node_modules/%40json-render/core/src/spec-validator.ts","file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Bcore%400.5.2_zod%404.3.6/node_modules/%40json-render/core/src/schema.ts","file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Bcore%400.5.2_zod%404.3.6/node_modules/%40json-render/core/src/prompt.ts","file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Bcore%400.5.2_zod%404.3.6/node_modules/%40json-render/core/src/catalog.ts"],"sourcesContent":["import { z } from \"zod\";\nimport type { ActionBinding } from \"./actions\";\n\n/**\n * Dynamic value - can be a literal or a path reference to state model\n */\nexport type DynamicValue<T = unknown> = T | { path: string };\n\n/**\n * Dynamic string value\n */\nexport type DynamicString = DynamicValue<string>;\n\n/**\n * Dynamic number value\n */\nexport type DynamicNumber = DynamicValue<number>;\n\n/**\n * Dynamic boolean value\n */\nexport type DynamicBoolean = DynamicValue<boolean>;\n\n/**\n * Zod schema for dynamic values\n */\nexport const DynamicValueSchema = z.union([\n  z.string(),\n  z.number(),\n  z.boolean(),\n  z.null(),\n  z.object({ path: z.string() }),\n]);\n\nexport const DynamicStringSchema = z.union([\n  z.string(),\n  z.object({ path: z.string() }),\n]);\n\nexport const DynamicNumberSchema = z.union([\n  z.number(),\n  z.object({ path: z.string() }),\n]);\n\nexport const DynamicBooleanSchema = z.union([\n  z.boolean(),\n  z.object({ path: z.string() }),\n]);\n\n/**\n * Base UI element structure for v2\n */\nexport interface UIElement<\n  T extends string = string,\n  P = Record<string, unknown>,\n> {\n  /** Component type from the catalog */\n  type: T;\n  /** Component props */\n  props: P;\n  /** Child element keys (flat structure) */\n  children?: string[];\n  /** Visibility condition */\n  visible?: VisibilityCondition;\n  /** Event bindings — maps event names to action bindings */\n  on?: Record<string, ActionBinding | ActionBinding[]>;\n  /** Repeat children once per item in a state array */\n  repeat?: { path: string; key?: string };\n}\n\n/**\n * Element with key and parentKey for use with flatToTree.\n * When elements are in an array (not a keyed map), key and parentKey\n * are needed to establish identity and parent-child relationships.\n */\nexport interface FlatElement<\n  T extends string = string,\n  P = Record<string, unknown>,\n> extends UIElement<T, P> {\n  /** Unique key identifying this element */\n  key: string;\n  /** Parent element key (null for root) */\n  parentKey?: string | null;\n}\n\n/**\n * Visibility condition types\n */\nexport type VisibilityCondition =\n  | boolean\n  | { path: string }\n  | { auth: \"signedIn\" | \"signedOut\" }\n  | LogicExpression;\n\n/**\n * Logic expression for complex conditions\n */\nexport type LogicExpression =\n  | { and: LogicExpression[] }\n  | { or: LogicExpression[] }\n  | { not: LogicExpression }\n  | { path: string }\n  | { eq: [DynamicValue, DynamicValue] }\n  | { neq: [DynamicValue, DynamicValue] }\n  | { gt: [DynamicValue<number>, DynamicValue<number>] }\n  | { gte: [DynamicValue<number>, DynamicValue<number>] }\n  | { lt: [DynamicValue<number>, DynamicValue<number>] }\n  | { lte: [DynamicValue<number>, DynamicValue<number>] };\n\n/**\n * Flat UI tree structure (optimized for LLM generation)\n */\nexport interface Spec {\n  /** Root element key */\n  root: string;\n  /** Flat map of elements by key */\n  elements: Record<string, UIElement>;\n  /** Optional initial state to seed the state model.\n   *  Components using statePath will read from / write to this state. */\n  state?: Record<string, unknown>;\n}\n\n/**\n * Auth state for visibility evaluation\n */\nexport interface AuthState {\n  isSignedIn: boolean;\n  user?: Record<string, unknown>;\n}\n\n/**\n * State model type\n */\nexport type StateModel = Record<string, unknown>;\n\n/**\n * Component schema definition using Zod\n */\nexport type ComponentSchema = z.ZodType<Record<string, unknown>>;\n\n/**\n * Validation mode for catalog validation\n */\nexport type ValidationMode = \"strict\" | \"warn\" | \"ignore\";\n\n/**\n * JSON patch operation types (RFC 6902)\n */\nexport type PatchOp = \"add\" | \"remove\" | \"replace\" | \"move\" | \"copy\" | \"test\";\n\n/**\n * JSON patch operation (RFC 6902)\n */\nexport interface JsonPatch {\n  op: PatchOp;\n  path: string;\n  /** Required for add, replace, test */\n  value?: unknown;\n  /** Required for move, copy (source location) */\n  from?: string;\n}\n\n/**\n * Resolve a dynamic value against a state model\n */\nexport function resolveDynamicValue<T>(\n  value: DynamicValue<T>,\n  stateModel: StateModel,\n): T | undefined {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n\n  if (typeof value === \"object\" && \"path\" in value) {\n    return getByPath(stateModel, value.path) as T | undefined;\n  }\n\n  return value as T;\n}\n\n/**\n * Unescape a JSON Pointer token per RFC 6901 Section 4.\n * ~1 is decoded to / and ~0 is decoded to ~ (order matters).\n */\nfunction unescapeJsonPointer(token: string): string {\n  return token.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n\n/**\n * Parse a JSON Pointer path into unescaped segments.\n */\nfunction parseJsonPointer(path: string): string[] {\n  const raw = path.startsWith(\"/\") ? path.slice(1).split(\"/\") : path.split(\"/\");\n  return raw.map(unescapeJsonPointer);\n}\n\n/**\n * Get a value from an object by JSON Pointer path (RFC 6901)\n */\nexport function getByPath(obj: unknown, path: string): unknown {\n  if (!path || path === \"/\") {\n    return obj;\n  }\n\n  const segments = parseJsonPointer(path);\n\n  let current: unknown = obj;\n\n  for (const segment of segments) {\n    if (current === null || current === undefined) {\n      return undefined;\n    }\n\n    if (Array.isArray(current)) {\n      const index = parseInt(segment, 10);\n      current = current[index];\n    } else if (typeof current === \"object\") {\n      current = (current as Record<string, unknown>)[segment];\n    } else {\n      return undefined;\n    }\n  }\n\n  return current;\n}\n\n/**\n * Check if a string is a numeric index\n */\nfunction isNumericIndex(str: string): boolean {\n  return /^\\d+$/.test(str);\n}\n\n/**\n * Set a value in an object by JSON Pointer path (RFC 6901).\n * Automatically creates arrays when the path segment is a numeric index.\n */\nexport function setByPath(\n  obj: Record<string, unknown>,\n  path: string,\n  value: unknown,\n): void {\n  const segments = parseJsonPointer(path);\n\n  if (segments.length === 0) return;\n\n  let current: Record<string, unknown> | unknown[] = obj;\n\n  for (let i = 0; i < segments.length - 1; i++) {\n    const segment = segments[i]!;\n    const nextSegment = segments[i + 1];\n    const nextIsNumeric =\n      nextSegment !== undefined &&\n      (isNumericIndex(nextSegment) || nextSegment === \"-\");\n\n    if (Array.isArray(current)) {\n      const index = parseInt(segment, 10);\n      if (current[index] === undefined || typeof current[index] !== \"object\") {\n        current[index] = nextIsNumeric ? [] : {};\n      }\n      current = current[index] as Record<string, unknown> | unknown[];\n    } else {\n      if (!(segment in current) || typeof current[segment] !== \"object\") {\n        current[segment] = nextIsNumeric ? [] : {};\n      }\n      current = current[segment] as Record<string, unknown> | unknown[];\n    }\n  }\n\n  const lastSegment = segments[segments.length - 1]!;\n  if (Array.isArray(current)) {\n    if (lastSegment === \"-\") {\n      current.push(value);\n    } else {\n      const index = parseInt(lastSegment, 10);\n      current[index] = value;\n    }\n  } else {\n    current[lastSegment] = value;\n  }\n}\n\n/**\n * Add a value per RFC 6902 \"add\" semantics.\n * For objects: create-or-replace the member.\n * For arrays: insert before the given index, or append if \"-\".\n */\nexport function addByPath(\n  obj: Record<string, unknown>,\n  path: string,\n  value: unknown,\n): void {\n  const segments = parseJsonPointer(path);\n\n  if (segments.length === 0) return;\n\n  let current: Record<string, unknown> | unknown[] = obj;\n\n  for (let i = 0; i < segments.length - 1; i++) {\n    const segment = segments[i]!;\n    const nextSegment = segments[i + 1];\n    const nextIsNumeric =\n      nextSegment !== undefined &&\n      (isNumericIndex(nextSegment) || nextSegment === \"-\");\n\n    if (Array.isArray(current)) {\n      const index = parseInt(segment, 10);\n      if (current[index] === undefined || typeof current[index] !== \"object\") {\n        current[index] = nextIsNumeric ? [] : {};\n      }\n      current = current[index] as Record<string, unknown> | unknown[];\n    } else {\n      if (!(segment in current) || typeof current[segment] !== \"object\") {\n        current[segment] = nextIsNumeric ? [] : {};\n      }\n      current = current[segment] as Record<string, unknown> | unknown[];\n    }\n  }\n\n  const lastSegment = segments[segments.length - 1]!;\n  if (Array.isArray(current)) {\n    if (lastSegment === \"-\") {\n      current.push(value);\n    } else {\n      const index = parseInt(lastSegment, 10);\n      current.splice(index, 0, value);\n    }\n  } else {\n    current[lastSegment] = value;\n  }\n}\n\n/**\n * Remove a value per RFC 6902 \"remove\" semantics.\n * For objects: delete the property.\n * For arrays: splice out the element at the given index.\n */\nexport function removeByPath(obj: Record<string, unknown>, path: string): void {\n  const segments = parseJsonPointer(path);\n\n  if (segments.length === 0) return;\n\n  let current: Record<string, unknown> | unknown[] = obj;\n\n  for (let i = 0; i < segments.length - 1; i++) {\n    const segment = segments[i]!;\n\n    if (Array.isArray(current)) {\n      const index = parseInt(segment, 10);\n      if (current[index] === undefined || typeof current[index] !== \"object\") {\n        return; // path does not exist\n      }\n      current = current[index] as Record<string, unknown> | unknown[];\n    } else {\n      if (!(segment in current) || typeof current[segment] !== \"object\") {\n        return; // path does not exist\n      }\n      current = current[segment] as Record<string, unknown> | unknown[];\n    }\n  }\n\n  const lastSegment = segments[segments.length - 1]!;\n  if (Array.isArray(current)) {\n    const index = parseInt(lastSegment, 10);\n    if (index >= 0 && index < current.length) {\n      current.splice(index, 1);\n    }\n  } else {\n    delete current[lastSegment];\n  }\n}\n\n/**\n * Deep equality check for RFC 6902 \"test\" operation.\n */\nfunction deepEqual(a: unknown, b: unknown): boolean {\n  if (a === b) return true;\n  if (a === null || b === null) return false;\n  if (typeof a !== typeof b) return false;\n  if (typeof a !== \"object\") return false;\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) return false;\n    if (a.length !== b.length) return false;\n    return a.every((item, i) => deepEqual(item, b[i]));\n  }\n\n  const aObj = a as Record<string, unknown>;\n  const bObj = b as Record<string, unknown>;\n  const aKeys = Object.keys(aObj);\n  const bKeys = Object.keys(bObj);\n\n  if (aKeys.length !== bKeys.length) return false;\n  return aKeys.every((key) => deepEqual(aObj[key], bObj[key]));\n}\n\n/**\n * Find a form value from params and/or data.\n * Useful in action handlers to locate form input values regardless of path format.\n *\n * Checks in order:\n * 1. Direct param key (if not a path reference)\n * 2. Param keys ending with the field name\n * 3. Data keys ending with the field name (dot notation)\n * 4. Data paths using getByPath (slash notation)\n *\n * @example\n * // Find \"name\" from params or data\n * const name = findFormValue(\"name\", params, data);\n *\n * // Will find from: params.name, params[\"form.name\"], data[\"customerForm.name\"], data.customerForm.name\n */\nexport function findFormValue(\n  fieldName: string,\n  params?: Record<string, unknown>,\n  data?: Record<string, unknown>,\n): unknown {\n  // Check params first (but not if it looks like a data path reference)\n  if (params?.[fieldName] !== undefined) {\n    const val = params[fieldName];\n    // If the value looks like a path reference (contains dots), skip it\n    if (typeof val !== \"string\" || !val.includes(\".\")) {\n      return val;\n    }\n  }\n\n  // Check param keys that end with the field name\n  if (params) {\n    for (const key of Object.keys(params)) {\n      if (key.endsWith(`.${fieldName}`)) {\n        const val = params[key];\n        if (typeof val !== \"string\" || !val.includes(\".\")) {\n          return val;\n        }\n      }\n    }\n  }\n\n  // Check data keys that end with the field name (handles any form naming)\n  if (data) {\n    for (const key of Object.keys(data)) {\n      if (key === fieldName || key.endsWith(`.${fieldName}`)) {\n        return data[key];\n      }\n    }\n\n    // Try getByPath with common prefixes\n    const prefixes = [\"form\", \"newCustomer\", \"customer\", \"\"];\n    for (const prefix of prefixes) {\n      const path = prefix ? `${prefix}/${fieldName}` : fieldName;\n      const val = getByPath(data, path);\n      if (val !== undefined) {\n        return val;\n      }\n    }\n  }\n\n  return undefined;\n}\n\n// =============================================================================\n// SpecStream - Streaming format for progressively building specs\n// =============================================================================\n\n/**\n * A SpecStream line - a single patch operation in the stream.\n */\nexport type SpecStreamLine = JsonPatch;\n\n/**\n * Parse a single SpecStream line into a patch operation.\n * Returns null if the line is invalid or empty.\n *\n * SpecStream is json-render's streaming format where each line is a JSON patch\n * operation that progressively builds up the final spec.\n */\nexport function parseSpecStreamLine(line: string): SpecStreamLine | null {\n  const trimmed = line.trim();\n  if (!trimmed || !trimmed.startsWith(\"{\")) return null;\n\n  try {\n    const patch = JSON.parse(trimmed) as SpecStreamLine;\n    if (patch.op && patch.path !== undefined) {\n      return patch;\n    }\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Apply a single RFC 6902 JSON Patch operation to an object.\n * Mutates the object in place.\n *\n * Supports all six RFC 6902 operations: add, remove, replace, move, copy, test.\n *\n * @throws {Error} If a \"test\" operation fails (value mismatch).\n */\nexport function applySpecStreamPatch<T extends Record<string, unknown>>(\n  obj: T,\n  patch: SpecStreamLine,\n): T {\n  switch (patch.op) {\n    case \"add\":\n      addByPath(obj, patch.path, patch.value);\n      break;\n    case \"replace\":\n      // RFC 6902: target must exist. For streaming tolerance we set regardless.\n      setByPath(obj, patch.path, patch.value);\n      break;\n    case \"remove\":\n      removeByPath(obj, patch.path);\n      break;\n    case \"move\": {\n      if (!patch.from) break;\n      const moveValue = getByPath(obj, patch.from);\n      removeByPath(obj, patch.from);\n      addByPath(obj, patch.path, moveValue);\n      break;\n    }\n    case \"copy\": {\n      if (!patch.from) break;\n      const copyValue = getByPath(obj, patch.from);\n      addByPath(obj, patch.path, copyValue);\n      break;\n    }\n    case \"test\": {\n      const actual = getByPath(obj, patch.path);\n      if (!deepEqual(actual, patch.value)) {\n        throw new Error(\n          `Test operation failed: value at \"${patch.path}\" does not match`,\n        );\n      }\n      break;\n    }\n  }\n  return obj;\n}\n\n/**\n * Compile a SpecStream string into a JSON object.\n * Each line should be a patch operation.\n *\n * @example\n * const stream = `{\"op\":\"add\",\"path\":\"/name\",\"value\":\"Alice\"}\n * {\"op\":\"add\",\"path\":\"/age\",\"value\":30}`;\n * const result = compileSpecStream(stream);\n * // { name: \"Alice\", age: 30 }\n */\nexport function compileSpecStream<\n  T extends Record<string, unknown> = Record<string, unknown>,\n>(stream: string, initial: T = {} as T): T {\n  const lines = stream.split(\"\\n\");\n  const result = { ...initial };\n\n  for (const line of lines) {\n    const patch = parseSpecStreamLine(line);\n    if (patch) {\n      applySpecStreamPatch(result, patch);\n    }\n  }\n\n  return result as T;\n}\n\n/**\n * Streaming SpecStream compiler.\n * Useful for processing SpecStream data as it streams in from AI.\n *\n * @example\n * const compiler = createSpecStreamCompiler<MySpec>();\n *\n * // As chunks arrive:\n * const { result, newPatches } = compiler.push(chunk);\n * if (newPatches.length > 0) {\n *   updateUI(result);\n * }\n *\n * // When done:\n * const finalResult = compiler.getResult();\n */\nexport interface SpecStreamCompiler<T> {\n  /** Push a chunk of text. Returns the current result and any new patches applied. */\n  push(chunk: string): { result: T; newPatches: SpecStreamLine[] };\n  /** Get the current compiled result */\n  getResult(): T;\n  /** Get all patches that have been applied */\n  getPatches(): SpecStreamLine[];\n  /** Reset the compiler to initial state */\n  reset(initial?: Partial<T>): void;\n}\n\n/**\n * Create a streaming SpecStream compiler.\n *\n * SpecStream is json-render's streaming format. AI outputs patch operations\n * line by line, and this compiler progressively builds the final spec.\n *\n * @example\n * const compiler = createSpecStreamCompiler<TimelineSpec>();\n *\n * // Process streaming response\n * const reader = response.body.getReader();\n * while (true) {\n *   const { done, value } = await reader.read();\n *   if (done) break;\n *\n *   const { result, newPatches } = compiler.push(decoder.decode(value));\n *   if (newPatches.length > 0) {\n *     setSpec(result); // Update UI with partial result\n *   }\n * }\n */\nexport function createSpecStreamCompiler<T = Record<string, unknown>>(\n  initial: Partial<T> = {},\n): SpecStreamCompiler<T> {\n  let result = { ...initial } as T;\n  let buffer = \"\";\n  const appliedPatches: SpecStreamLine[] = [];\n  const processedLines = new Set<string>();\n\n  return {\n    push(chunk: string): { result: T; newPatches: SpecStreamLine[] } {\n      buffer += chunk;\n      const newPatches: SpecStreamLine[] = [];\n\n      // Process complete lines\n      const lines = buffer.split(\"\\n\");\n      buffer = lines.pop() || \"\"; // Keep incomplete line in buffer\n\n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (!trimmed || processedLines.has(trimmed)) continue;\n        processedLines.add(trimmed);\n\n        const patch = parseSpecStreamLine(trimmed);\n        if (patch) {\n          applySpecStreamPatch(result as Record<string, unknown>, patch);\n          appliedPatches.push(patch);\n          newPatches.push(patch);\n        }\n      }\n\n      // Return a shallow copy to trigger re-renders\n      if (newPatches.length > 0) {\n        result = { ...result };\n      }\n\n      return { result, newPatches };\n    },\n\n    getResult(): T {\n      // Process any remaining buffer\n      if (buffer.trim()) {\n        const patch = parseSpecStreamLine(buffer);\n        if (patch && !processedLines.has(buffer.trim())) {\n          processedLines.add(buffer.trim());\n          applySpecStreamPatch(result as Record<string, unknown>, patch);\n          appliedPatches.push(patch);\n          result = { ...result };\n        }\n        buffer = \"\";\n      }\n      return result;\n    },\n\n    getPatches(): SpecStreamLine[] {\n      return [...appliedPatches];\n    },\n\n    reset(newInitial: Partial<T> = {}): void {\n      result = { ...newInitial } as T;\n      buffer = \"\";\n      appliedPatches.length = 0;\n      processedLines.clear();\n    },\n  };\n}\n","import { z } from \"zod\";\nimport type {\n  VisibilityCondition,\n  LogicExpression,\n  StateModel,\n  AuthState,\n  DynamicValue,\n} from \"./types\";\nimport { resolveDynamicValue, DynamicValueSchema } from \"./types\";\n\n// Dynamic value schema for comparisons (number-focused)\nconst DynamicNumberValueSchema = z.union([\n  z.number(),\n  z.object({ path: z.string() }),\n]);\n\n/**\n * Logic expression schema (recursive)\n * Using a more permissive schema that aligns with runtime behavior\n */\nexport const LogicExpressionSchema: z.ZodType<LogicExpression> = z.lazy(() =>\n  z.union([\n    z.object({ and: z.array(LogicExpressionSchema) }),\n    z.object({ or: z.array(LogicExpressionSchema) }),\n    z.object({ not: LogicExpressionSchema }),\n    z.object({ path: z.string() }),\n    z.object({ eq: z.tuple([DynamicValueSchema, DynamicValueSchema]) }),\n    z.object({ neq: z.tuple([DynamicValueSchema, DynamicValueSchema]) }),\n    z.object({\n      gt: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\n    }),\n    z.object({\n      gte: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\n    }),\n    z.object({\n      lt: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\n    }),\n    z.object({\n      lte: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\n    }),\n  ]),\n) as z.ZodType<LogicExpression>;\n\n/**\n * Visibility condition schema\n */\nexport const VisibilityConditionSchema: z.ZodType<VisibilityCondition> =\n  z.union([\n    z.boolean(),\n    z.object({ path: z.string() }),\n    z.object({ auth: z.enum([\"signedIn\", \"signedOut\"]) }),\n    LogicExpressionSchema,\n  ]);\n\n/**\n * Context for evaluating visibility\n */\nexport interface VisibilityContext {\n  stateModel: StateModel;\n  authState?: AuthState;\n}\n\n/**\n * Evaluate a logic expression against data and auth state\n */\nexport function evaluateLogicExpression(\n  expr: LogicExpression,\n  ctx: VisibilityContext,\n): boolean {\n  const { stateModel } = ctx;\n\n  // AND expression\n  if (\"and\" in expr) {\n    return expr.and.every((subExpr) => evaluateLogicExpression(subExpr, ctx));\n  }\n\n  // OR expression\n  if (\"or\" in expr) {\n    return expr.or.some((subExpr) => evaluateLogicExpression(subExpr, ctx));\n  }\n\n  // NOT expression\n  if (\"not\" in expr) {\n    return !evaluateLogicExpression(expr.not, ctx);\n  }\n\n  // Path expression (resolve to boolean)\n  if (\"path\" in expr) {\n    const value = resolveDynamicValue({ path: expr.path }, stateModel);\n    return Boolean(value);\n  }\n\n  // Equality comparison\n  if (\"eq\" in expr) {\n    const [left, right] = expr.eq;\n    const leftValue = resolveDynamicValue(left, stateModel);\n    const rightValue = resolveDynamicValue(right, stateModel);\n    return leftValue === rightValue;\n  }\n\n  // Not equal comparison\n  if (\"neq\" in expr) {\n    const [left, right] = expr.neq;\n    const leftValue = resolveDynamicValue(left, stateModel);\n    const rightValue = resolveDynamicValue(right, stateModel);\n    return leftValue !== rightValue;\n  }\n\n  // Greater than\n  if (\"gt\" in expr) {\n    const [left, right] = expr.gt;\n    const leftValue = resolveDynamicValue(\n      left as DynamicValue<number>,\n      stateModel,\n    );\n    const rightValue = resolveDynamicValue(\n      right as DynamicValue<number>,\n      stateModel,\n    );\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\n      return leftValue > rightValue;\n    }\n    return false;\n  }\n\n  // Greater than or equal\n  if (\"gte\" in expr) {\n    const [left, right] = expr.gte;\n    const leftValue = resolveDynamicValue(\n      left as DynamicValue<number>,\n      stateModel,\n    );\n    const rightValue = resolveDynamicValue(\n      right as DynamicValue<number>,\n      stateModel,\n    );\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\n      return leftValue >= rightValue;\n    }\n    return false;\n  }\n\n  // Less than\n  if (\"lt\" in expr) {\n    const [left, right] = expr.lt;\n    const leftValue = resolveDynamicValue(\n      left as DynamicValue<number>,\n      stateModel,\n    );\n    const rightValue = resolveDynamicValue(\n      right as DynamicValue<number>,\n      stateModel,\n    );\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\n      return leftValue < rightValue;\n    }\n    return false;\n  }\n\n  // Less than or equal\n  if (\"lte\" in expr) {\n    const [left, right] = expr.lte;\n    const leftValue = resolveDynamicValue(\n      left as DynamicValue<number>,\n      stateModel,\n    );\n    const rightValue = resolveDynamicValue(\n      right as DynamicValue<number>,\n      stateModel,\n    );\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\n      return leftValue <= rightValue;\n    }\n    return false;\n  }\n\n  return false;\n}\n\n/**\n * Evaluate a visibility condition\n */\nexport function evaluateVisibility(\n  condition: VisibilityCondition | undefined,\n  ctx: VisibilityContext,\n): boolean {\n  // No condition = visible\n  if (condition === undefined) {\n    return true;\n  }\n\n  // Boolean literal\n  if (typeof condition === \"boolean\") {\n    return condition;\n  }\n\n  // Path reference\n  if (\"path\" in condition && !(\"and\" in condition) && !(\"or\" in condition)) {\n    const value = resolveDynamicValue({ path: condition.path }, ctx.stateModel);\n    return Boolean(value);\n  }\n\n  // Auth condition\n  if (\"auth\" in condition) {\n    const isSignedIn = ctx.authState?.isSignedIn ?? false;\n    if (condition.auth === \"signedIn\") {\n      return isSignedIn;\n    }\n    if (condition.auth === \"signedOut\") {\n      return !isSignedIn;\n    }\n    return false;\n  }\n\n  // Logic expression\n  return evaluateLogicExpression(condition as LogicExpression, ctx);\n}\n\n/**\n * Helper to create visibility conditions\n */\nexport const visibility = {\n  /** Always visible */\n  always: true as const,\n\n  /** Never visible */\n  never: false as const,\n\n  /** Visible when path is truthy */\n  when: (path: string): VisibilityCondition => ({ path }),\n\n  /** Visible when signed in */\n  signedIn: { auth: \"signedIn\" } as const,\n\n  /** Visible when signed out */\n  signedOut: { auth: \"signedOut\" } as const,\n\n  /** AND multiple conditions */\n  and: (...conditions: LogicExpression[]): LogicExpression => ({\n    and: conditions,\n  }),\n\n  /** OR multiple conditions */\n  or: (...conditions: LogicExpression[]): LogicExpression => ({\n    or: conditions,\n  }),\n\n  /** NOT a condition */\n  not: (condition: LogicExpression): LogicExpression => ({ not: condition }),\n\n  /** Equality check */\n  eq: (left: DynamicValue, right: DynamicValue): LogicExpression => ({\n    eq: [left, right],\n  }),\n\n  /** Not equal check */\n  neq: (left: DynamicValue, right: DynamicValue): LogicExpression => ({\n    neq: [left, right],\n  }),\n\n  /** Greater than */\n  gt: (\n    left: DynamicValue<number>,\n    right: DynamicValue<number>,\n  ): LogicExpression => ({ gt: [left, right] }),\n\n  /** Greater than or equal */\n  gte: (\n    left: DynamicValue<number>,\n    right: DynamicValue<number>,\n  ): LogicExpression => ({ gte: [left, right] }),\n\n  /** Less than */\n  lt: (\n    left: DynamicValue<number>,\n    right: DynamicValue<number>,\n  ): LogicExpression => ({ lt: [left, right] }),\n\n  /** Less than or equal */\n  lte: (\n    left: DynamicValue<number>,\n    right: DynamicValue<number>,\n  ): LogicExpression => ({ lte: [left, right] }),\n};\n","import type { VisibilityCondition, StateModel, AuthState } from \"./types\";\nimport { getByPath } from \"./types\";\nimport { evaluateVisibility, type VisibilityContext } from \"./visibility\";\n\n// =============================================================================\n// Prop Expression Types\n// =============================================================================\n\n/**\n * A prop expression that resolves to a value based on state.\n *\n * - `{ $path: string }` reads a value from the state model\n * - `{ $cond, $then, $else }` conditionally picks a value\n * - Any other value is a literal (passthrough)\n */\nexport type PropExpression<T = unknown> =\n  | T\n  | { $path: string }\n  | {\n      $cond: VisibilityCondition;\n      $then: PropExpression<T>;\n      $else: PropExpression<T>;\n    };\n\n/**\n * Check if a value is a $path expression\n */\nfunction isPathExpression(value: unknown): value is { $path: string } {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"$path\" in value &&\n    typeof (value as Record<string, unknown>).$path === \"string\"\n  );\n}\n\n/**\n * Check if a value is a $cond expression\n */\nfunction isCondExpression(\n  value: unknown,\n): value is { $cond: VisibilityCondition; $then: unknown; $else: unknown } {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"$cond\" in value &&\n    \"$then\" in value &&\n    \"$else\" in value\n  );\n}\n\n// =============================================================================\n// Prop Expression Resolution\n// =============================================================================\n\n/**\n * Resolve a single prop value that may contain expressions.\n * Recursively resolves $path and $cond/$then/$else expressions.\n */\nexport function resolvePropValue(\n  value: unknown,\n  ctx: VisibilityContext,\n): unknown {\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  // $path: read from state model\n  if (isPathExpression(value)) {\n    return getByPath(ctx.stateModel, value.$path);\n  }\n\n  // $cond/$then/$else: evaluate condition and pick branch\n  if (isCondExpression(value)) {\n    const result = evaluateVisibility(value.$cond, ctx);\n    return resolvePropValue(result ? value.$then : value.$else, ctx);\n  }\n\n  // Arrays: resolve each element\n  if (Array.isArray(value)) {\n    return value.map((item) => resolvePropValue(item, ctx));\n  }\n\n  // Plain objects (not expressions): resolve each value recursively\n  if (typeof value === \"object\") {\n    const resolved: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value as Record<string, unknown>)) {\n      resolved[key] = resolvePropValue(val, ctx);\n    }\n    return resolved;\n  }\n\n  // Primitive literal: passthrough\n  return value;\n}\n\n/**\n * Resolve all prop values in an element's props object.\n * Returns a new props object with all expressions resolved.\n */\nexport function resolveElementProps(\n  props: Record<string, unknown>,\n  ctx: VisibilityContext,\n): Record<string, unknown> {\n  const resolved: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(props)) {\n    resolved[key] = resolvePropValue(value, ctx);\n  }\n  return resolved;\n}\n","import { z } from \"zod\";\nimport type { DynamicValue, StateModel } from \"./types\";\nimport { DynamicValueSchema, resolveDynamicValue } from \"./types\";\n\n/**\n * Confirmation dialog configuration\n */\nexport interface ActionConfirm {\n  title: string;\n  message: string;\n  confirmLabel?: string;\n  cancelLabel?: string;\n  variant?: \"default\" | \"danger\";\n}\n\n/**\n * Action success handler\n */\nexport type ActionOnSuccess =\n  | { navigate: string }\n  | { set: Record<string, unknown> }\n  | { action: string };\n\n/**\n * Action error handler\n */\nexport type ActionOnError =\n  | { set: Record<string, unknown> }\n  | { action: string };\n\n/**\n * Action binding — maps an event to an action invocation.\n *\n * Used inside the `on` field of a UIElement:\n * ```json\n * { \"on\": { \"press\": { \"action\": \"setState\", \"params\": { \"path\": \"/x\", \"value\": 1 } } } }\n * ```\n */\nexport interface ActionBinding {\n  /** Action name (must be in catalog) */\n  action: string;\n  /** Parameters to pass to the action handler */\n  params?: Record<string, DynamicValue>;\n  /** Confirmation dialog before execution */\n  confirm?: ActionConfirm;\n  /** Handler after successful execution */\n  onSuccess?: ActionOnSuccess;\n  /** Handler after failed execution */\n  onError?: ActionOnError;\n}\n\n/**\n * @deprecated Use ActionBinding instead\n */\nexport type Action = ActionBinding;\n\n/**\n * Schema for action confirmation\n */\nexport const ActionConfirmSchema = z.object({\n  title: z.string(),\n  message: z.string(),\n  confirmLabel: z.string().optional(),\n  cancelLabel: z.string().optional(),\n  variant: z.enum([\"default\", \"danger\"]).optional(),\n});\n\n/**\n * Schema for success handlers\n */\nexport const ActionOnSuccessSchema = z.union([\n  z.object({ navigate: z.string() }),\n  z.object({ set: z.record(z.string(), z.unknown()) }),\n  z.object({ action: z.string() }),\n]);\n\n/**\n * Schema for error handlers\n */\nexport const ActionOnErrorSchema = z.union([\n  z.object({ set: z.record(z.string(), z.unknown()) }),\n  z.object({ action: z.string() }),\n]);\n\n/**\n * Full action binding schema\n */\nexport const ActionBindingSchema = z.object({\n  action: z.string(),\n  params: z.record(z.string(), DynamicValueSchema).optional(),\n  confirm: ActionConfirmSchema.optional(),\n  onSuccess: ActionOnSuccessSchema.optional(),\n  onError: ActionOnErrorSchema.optional(),\n});\n\n/**\n * @deprecated Use ActionBindingSchema instead\n */\nexport const ActionSchema = ActionBindingSchema;\n\n/**\n * Action handler function signature\n */\nexport type ActionHandler<\n  TParams = Record<string, unknown>,\n  TResult = unknown,\n> = (params: TParams) => Promise<TResult> | TResult;\n\n/**\n * Action definition in catalog\n */\nexport interface ActionDefinition<TParams = Record<string, unknown>> {\n  /** Zod schema for params validation */\n  params?: z.ZodType<TParams>;\n  /** Description for AI */\n  description?: string;\n}\n\n/**\n * Resolved action with all dynamic values resolved\n */\nexport interface ResolvedAction {\n  action: string;\n  params: Record<string, unknown>;\n  confirm?: ActionConfirm;\n  onSuccess?: ActionOnSuccess;\n  onError?: ActionOnError;\n}\n\n/**\n * Resolve all dynamic values in an action binding\n */\nexport function resolveAction(\n  binding: ActionBinding,\n  stateModel: StateModel,\n): ResolvedAction {\n  const resolvedParams: Record<string, unknown> = {};\n\n  if (binding.params) {\n    for (const [key, value] of Object.entries(binding.params)) {\n      resolvedParams[key] = resolveDynamicValue(value, stateModel);\n    }\n  }\n\n  // Interpolate confirmation message if present\n  let confirm = binding.confirm;\n  if (confirm) {\n    confirm = {\n      ...confirm,\n      message: interpolateString(confirm.message, stateModel),\n      title: interpolateString(confirm.title, stateModel),\n    };\n  }\n\n  return {\n    action: binding.action,\n    params: resolvedParams,\n    confirm,\n    onSuccess: binding.onSuccess,\n    onError: binding.onError,\n  };\n}\n\n/**\n * Interpolate ${path} expressions in a string\n */\nexport function interpolateString(\n  template: string,\n  stateModel: StateModel,\n): string {\n  return template.replace(/\\$\\{([^}]+)\\}/g, (_, path) => {\n    const value = resolveDynamicValue({ path }, stateModel);\n    return String(value ?? \"\");\n  });\n}\n\n/**\n * Context for action execution\n */\nexport interface ActionExecutionContext {\n  /** The resolved action */\n  action: ResolvedAction;\n  /** The action handler from the host */\n  handler: ActionHandler;\n  /** Function to update state model */\n  setState: (path: string, value: unknown) => void;\n  /** Function to navigate */\n  navigate?: (path: string) => void;\n  /** Function to execute another action */\n  executeAction?: (name: string) => Promise<void>;\n}\n\n/**\n * Execute an action with all callbacks\n */\nexport async function executeAction(\n  ctx: ActionExecutionContext,\n): Promise<void> {\n  const { action, handler, setState, navigate, executeAction } = ctx;\n\n  try {\n    await handler(action.params);\n\n    // Handle success\n    if (action.onSuccess) {\n      if (\"navigate\" in action.onSuccess && navigate) {\n        navigate(action.onSuccess.navigate);\n      } else if (\"set\" in action.onSuccess) {\n        for (const [path, value] of Object.entries(action.onSuccess.set)) {\n          setState(path, value);\n        }\n      } else if (\"action\" in action.onSuccess && executeAction) {\n        await executeAction(action.onSuccess.action);\n      }\n    }\n  } catch (error) {\n    // Handle error\n    if (action.onError) {\n      if (\"set\" in action.onError) {\n        for (const [path, value] of Object.entries(action.onError.set)) {\n          // Replace $error.message with actual error\n          const resolvedValue =\n            typeof value === \"string\" && value === \"$error.message\"\n              ? (error as Error).message\n              : value;\n          setState(path, resolvedValue);\n        }\n      } else if (\"action\" in action.onError && executeAction) {\n        await executeAction(action.onError.action);\n      }\n    } else {\n      throw error;\n    }\n  }\n}\n\n/**\n * Helper to create action bindings\n */\nexport const actionBinding = {\n  /** Create a simple action binding */\n  simple: (\n    actionName: string,\n    params?: Record<string, DynamicValue>,\n  ): ActionBinding => ({\n    action: actionName,\n    params,\n  }),\n\n  /** Create an action binding with confirmation */\n  withConfirm: (\n    actionName: string,\n    confirm: ActionConfirm,\n    params?: Record<string, DynamicValue>,\n  ): ActionBinding => ({\n    action: actionName,\n    params,\n    confirm,\n  }),\n\n  /** Create an action binding with success handler */\n  withSuccess: (\n    actionName: string,\n    onSuccess: ActionOnSuccess,\n    params?: Record<string, DynamicValue>,\n  ): ActionBinding => ({\n    action: actionName,\n    params,\n    onSuccess,\n  }),\n};\n\n/**\n * @deprecated Use actionBinding instead\n */\nexport const action = actionBinding;\n","import { z } from \"zod\";\nimport type { DynamicValue, StateModel, LogicExpression } from \"./types\";\nimport { DynamicValueSchema, resolveDynamicValue } from \"./types\";\nimport { LogicExpressionSchema, evaluateLogicExpression } from \"./visibility\";\n\n/**\n * Validation check definition\n */\nexport interface ValidationCheck {\n  /** Function name (built-in or from catalog) */\n  fn: string;\n  /** Additional arguments for the function */\n  args?: Record<string, DynamicValue>;\n  /** Error message to display if check fails */\n  message: string;\n}\n\n/**\n * Validation configuration for a field\n */\nexport interface ValidationConfig {\n  /** Array of checks to run */\n  checks?: ValidationCheck[];\n  /** When to run validation */\n  validateOn?: \"change\" | \"blur\" | \"submit\";\n  /** Condition for when validation is enabled */\n  enabled?: LogicExpression;\n}\n\n/**\n * Schema for validation check\n */\nexport const ValidationCheckSchema = z.object({\n  fn: z.string(),\n  args: z.record(z.string(), DynamicValueSchema).optional(),\n  message: z.string(),\n});\n\n/**\n * Schema for validation config\n */\nexport const ValidationConfigSchema = z.object({\n  checks: z.array(ValidationCheckSchema).optional(),\n  validateOn: z.enum([\"change\", \"blur\", \"submit\"]).optional(),\n  enabled: LogicExpressionSchema.optional(),\n});\n\n/**\n * Validation function signature\n */\nexport type ValidationFunction = (\n  value: unknown,\n  args?: Record<string, unknown>,\n) => boolean;\n\n/**\n * Validation function definition in catalog\n */\nexport interface ValidationFunctionDefinition {\n  /** The validation function */\n  validate: ValidationFunction;\n  /** Description for AI */\n  description?: string;\n}\n\n/**\n * Built-in validation functions\n */\nexport const builtInValidationFunctions: Record<string, ValidationFunction> = {\n  /**\n   * Check if value is not null, undefined, or empty string\n   */\n  required: (value: unknown) => {\n    if (value === null || value === undefined) return false;\n    if (typeof value === \"string\") return value.trim().length > 0;\n    if (Array.isArray(value)) return value.length > 0;\n    return true;\n  },\n\n  /**\n   * Check if value is a valid email address\n   */\n  email: (value: unknown) => {\n    if (typeof value !== \"string\") return false;\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value);\n  },\n\n  /**\n   * Check minimum string length\n   */\n  minLength: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"string\") return false;\n    const min = args?.min;\n    if (typeof min !== \"number\") return false;\n    return value.length >= min;\n  },\n\n  /**\n   * Check maximum string length\n   */\n  maxLength: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"string\") return false;\n    const max = args?.max;\n    if (typeof max !== \"number\") return false;\n    return value.length <= max;\n  },\n\n  /**\n   * Check if string matches a regex pattern\n   */\n  pattern: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"string\") return false;\n    const pattern = args?.pattern;\n    if (typeof pattern !== \"string\") return false;\n    try {\n      return new RegExp(pattern).test(value);\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Check minimum numeric value\n   */\n  min: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"number\") return false;\n    const min = args?.min;\n    if (typeof min !== \"number\") return false;\n    return value >= min;\n  },\n\n  /**\n   * Check maximum numeric value\n   */\n  max: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"number\") return false;\n    const max = args?.max;\n    if (typeof max !== \"number\") return false;\n    return value <= max;\n  },\n\n  /**\n   * Check if value is a number\n   */\n  numeric: (value: unknown) => {\n    if (typeof value === \"number\") return !isNaN(value);\n    if (typeof value === \"string\") return !isNaN(parseFloat(value));\n    return false;\n  },\n\n  /**\n   * Check if value is a valid URL\n   */\n  url: (value: unknown) => {\n    if (typeof value !== \"string\") return false;\n    try {\n      new URL(value);\n      return true;\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Check if value matches another field\n   */\n  matches: (value: unknown, args?: Record<string, unknown>) => {\n    const other = args?.other;\n    return value === other;\n  },\n};\n\n/**\n * Validation result for a single check\n */\nexport interface ValidationCheckResult {\n  fn: string;\n  valid: boolean;\n  message: string;\n}\n\n/**\n * Full validation result for a field\n */\nexport interface ValidationResult {\n  valid: boolean;\n  errors: string[];\n  checks: ValidationCheckResult[];\n}\n\n/**\n * Context for running validation\n */\nexport interface ValidationContext {\n  /** Current value to validate */\n  value: unknown;\n  /** Full data model for resolving paths */\n  stateModel: StateModel;\n  /** Custom validation functions from catalog */\n  customFunctions?: Record<string, ValidationFunction>;\n}\n\n/**\n * Run a single validation check\n */\nexport function runValidationCheck(\n  check: ValidationCheck,\n  ctx: ValidationContext,\n): ValidationCheckResult {\n  const { value, stateModel, customFunctions } = ctx;\n\n  // Resolve args\n  const resolvedArgs: Record<string, unknown> = {};\n  if (check.args) {\n    for (const [key, argValue] of Object.entries(check.args)) {\n      resolvedArgs[key] = resolveDynamicValue(argValue, stateModel);\n    }\n  }\n\n  // Find the validation function\n  const fn =\n    builtInValidationFunctions[check.fn] ?? customFunctions?.[check.fn];\n\n  if (!fn) {\n    console.warn(`Unknown validation function: ${check.fn}`);\n    return {\n      fn: check.fn,\n      valid: true, // Don't fail on unknown functions\n      message: check.message,\n    };\n  }\n\n  const valid = fn(value, resolvedArgs);\n\n  return {\n    fn: check.fn,\n    valid,\n    message: check.message,\n  };\n}\n\n/**\n * Run all validation checks for a field\n */\nexport function runValidation(\n  config: ValidationConfig,\n  ctx: ValidationContext & { authState?: { isSignedIn: boolean } },\n): ValidationResult {\n  const checks: ValidationCheckResult[] = [];\n  const errors: string[] = [];\n\n  // Check if validation is enabled\n  if (config.enabled) {\n    const enabled = evaluateLogicExpression(config.enabled, {\n      stateModel: ctx.stateModel,\n      authState: ctx.authState,\n    });\n    if (!enabled) {\n      return { valid: true, errors: [], checks: [] };\n    }\n  }\n\n  // Run each check\n  if (config.checks) {\n    for (const check of config.checks) {\n      const result = runValidationCheck(check, ctx);\n      checks.push(result);\n      if (!result.valid) {\n        errors.push(result.message);\n      }\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    checks,\n  };\n}\n\n/**\n * Helper to create validation checks\n */\nexport const check = {\n  required: (message = \"This field is required\"): ValidationCheck => ({\n    fn: \"required\",\n    message,\n  }),\n\n  email: (message = \"Invalid email address\"): ValidationCheck => ({\n    fn: \"email\",\n    message,\n  }),\n\n  minLength: (min: number, message?: string): ValidationCheck => ({\n    fn: \"minLength\",\n    args: { min },\n    message: message ?? `Must be at least ${min} characters`,\n  }),\n\n  maxLength: (max: number, message?: string): ValidationCheck => ({\n    fn: \"maxLength\",\n    args: { max },\n    message: message ?? `Must be at most ${max} characters`,\n  }),\n\n  pattern: (pattern: string, message = \"Invalid format\"): ValidationCheck => ({\n    fn: \"pattern\",\n    args: { pattern },\n    message,\n  }),\n\n  min: (min: number, message?: string): ValidationCheck => ({\n    fn: \"min\",\n    args: { min },\n    message: message ?? `Must be at least ${min}`,\n  }),\n\n  max: (max: number, message?: string): ValidationCheck => ({\n    fn: \"max\",\n    args: { max },\n    message: message ?? `Must be at most ${max}`,\n  }),\n\n  url: (message = \"Invalid URL\"): ValidationCheck => ({\n    fn: \"url\",\n    message,\n  }),\n\n  matches: (\n    otherPath: string,\n    message = \"Fields must match\",\n  ): ValidationCheck => ({\n    fn: \"matches\",\n    args: { other: { path: otherPath } },\n    message,\n  }),\n};\n","import type { Spec, UIElement } from \"./types\";\n\n// =============================================================================\n// Spec Structural Validation\n// =============================================================================\n\n/**\n * Severity level for validation issues.\n */\nexport type SpecIssueSeverity = \"error\" | \"warning\";\n\n/**\n * A single validation issue found in a spec.\n */\nexport interface SpecIssue {\n  /** Severity: errors should be fixed, warnings are informational */\n  severity: SpecIssueSeverity;\n  /** Human-readable description of the issue */\n  message: string;\n  /** The element key where the issue was found (if applicable) */\n  elementKey?: string;\n  /** Machine-readable issue code for programmatic handling */\n  code:\n    | \"missing_root\"\n    | \"root_not_found\"\n    | \"missing_child\"\n    | \"visible_in_props\"\n    | \"orphaned_element\"\n    | \"empty_spec\"\n    | \"on_in_props\"\n    | \"repeat_in_props\";\n}\n\n/**\n * Result of spec structural validation.\n */\nexport interface SpecValidationIssues {\n  /** Whether the spec passed validation (no errors; warnings are OK) */\n  valid: boolean;\n  /** List of issues found */\n  issues: SpecIssue[];\n}\n\n/**\n * Options for validateSpec.\n */\nexport interface ValidateSpecOptions {\n  /**\n   * Whether to check for orphaned elements (elements not reachable from root).\n   * Defaults to false since orphans are harmless (just unused).\n   */\n  checkOrphans?: boolean;\n}\n\n/**\n * Validate a spec for structural integrity.\n *\n * Checks for common AI-generation errors:\n * - Missing or empty root\n * - Root element not found in elements map\n * - Children referencing non-existent elements\n * - `visible` placed inside `props` instead of on the element\n * - Orphaned elements (optional)\n *\n * @example\n * ```ts\n * const result = validateSpec(spec);\n * if (!result.valid) {\n *   console.log(\"Spec errors:\", result.issues);\n * }\n * ```\n */\nexport function validateSpec(\n  spec: Spec,\n  options: ValidateSpecOptions = {},\n): SpecValidationIssues {\n  const { checkOrphans = false } = options;\n  const issues: SpecIssue[] = [];\n\n  // 1. Check root\n  if (!spec.root) {\n    issues.push({\n      severity: \"error\",\n      message: \"Spec has no root element defined.\",\n      code: \"missing_root\",\n    });\n    return { valid: false, issues };\n  }\n\n  if (!spec.elements[spec.root]) {\n    issues.push({\n      severity: \"error\",\n      message: `Root element \"${spec.root}\" not found in elements map.`,\n      code: \"root_not_found\",\n    });\n  }\n\n  // 2. Check for empty spec\n  if (Object.keys(spec.elements).length === 0) {\n    issues.push({\n      severity: \"error\",\n      message: \"Spec has no elements.\",\n      code: \"empty_spec\",\n    });\n    return { valid: false, issues };\n  }\n\n  // 3. Check each element\n  for (const [key, element] of Object.entries(spec.elements)) {\n    // 3a. Missing children\n    if (element.children) {\n      for (const childKey of element.children) {\n        if (!spec.elements[childKey]) {\n          issues.push({\n            severity: \"error\",\n            message: `Element \"${key}\" references child \"${childKey}\" which does not exist in the elements map.`,\n            elementKey: key,\n            code: \"missing_child\",\n          });\n        }\n      }\n    }\n\n    // 3b. `visible` inside props\n    const props = element.props as Record<string, unknown> | undefined;\n    if (props && \"visible\" in props && props.visible !== undefined) {\n      issues.push({\n        severity: \"error\",\n        message: `Element \"${key}\" has \"visible\" inside \"props\". It should be a top-level field on the element (sibling of type/props/children).`,\n        elementKey: key,\n        code: \"visible_in_props\",\n      });\n    }\n\n    // 3c. `on` inside props (should be a top-level field)\n    if (props && \"on\" in props && props.on !== undefined) {\n      issues.push({\n        severity: \"error\",\n        message: `Element \"${key}\" has \"on\" inside \"props\". It should be a top-level field on the element (sibling of type/props/children).`,\n        elementKey: key,\n        code: \"on_in_props\",\n      });\n    }\n\n    // 3d. `repeat` inside props (should be a top-level field)\n    if (props && \"repeat\" in props && props.repeat !== undefined) {\n      issues.push({\n        severity: \"error\",\n        message: `Element \"${key}\" has \"repeat\" inside \"props\". It should be a top-level field on the element (sibling of type/props/children).`,\n        elementKey: key,\n        code: \"repeat_in_props\",\n      });\n    }\n  }\n\n  // 4. Orphaned elements (optional)\n  if (checkOrphans) {\n    const reachable = new Set<string>();\n    const walk = (key: string) => {\n      if (reachable.has(key)) return;\n      reachable.add(key);\n      const el = spec.elements[key];\n      if (el?.children) {\n        for (const childKey of el.children) {\n          if (spec.elements[childKey]) {\n            walk(childKey);\n          }\n        }\n      }\n    };\n    if (spec.elements[spec.root]) {\n      walk(spec.root);\n    }\n\n    for (const key of Object.keys(spec.elements)) {\n      if (!reachable.has(key)) {\n        issues.push({\n          severity: \"warning\",\n          message: `Element \"${key}\" is not reachable from root \"${spec.root}\".`,\n          elementKey: key,\n          code: \"orphaned_element\",\n        });\n      }\n    }\n  }\n\n  const hasErrors = issues.some((i) => i.severity === \"error\");\n  return { valid: !hasErrors, issues };\n}\n\n/**\n * Auto-fix common spec issues in-place and return a corrected copy.\n *\n * Currently fixes:\n * - `visible` inside `props` → moved to element level\n * - `on` inside `props` → moved to element level\n * - `repeat` inside `props` → moved to element level\n *\n * Returns the fixed spec and a list of fixes applied.\n */\nexport function autoFixSpec(spec: Spec): {\n  spec: Spec;\n  fixes: string[];\n} {\n  const fixes: string[] = [];\n  const fixedElements: Record<string, UIElement> = {};\n\n  for (const [key, element] of Object.entries(spec.elements)) {\n    const props = element.props as Record<string, unknown> | undefined;\n    let fixed = element;\n\n    if (props && \"visible\" in props && props.visible !== undefined) {\n      // Move visible from props to element level\n      const { visible, ...restProps } = fixed.props as Record<string, unknown>;\n      fixed = {\n        ...fixed,\n        props: restProps,\n        visible: visible as UIElement[\"visible\"],\n      };\n      fixes.push(`Moved \"visible\" from props to element level on \"${key}\".`);\n    }\n\n    let currentProps = fixed.props as Record<string, unknown> | undefined;\n    if (currentProps && \"on\" in currentProps && currentProps.on !== undefined) {\n      // Move on from props to element level\n      const { on, ...restProps } = currentProps;\n      fixed = {\n        ...fixed,\n        props: restProps,\n        on: on as UIElement[\"on\"],\n      };\n      fixes.push(`Moved \"on\" from props to element level on \"${key}\".`);\n    }\n\n    currentProps = fixed.props as Record<string, unknown> | undefined;\n    if (\n      currentProps &&\n      \"repeat\" in currentProps &&\n      currentProps.repeat !== undefined\n    ) {\n      // Move repeat from props to element level\n      const { repeat, ...restProps } = currentProps;\n      fixed = {\n        ...fixed,\n        props: restProps,\n        repeat: repeat as UIElement[\"repeat\"],\n      };\n      fixes.push(`Moved \"repeat\" from props to element level on \"${key}\".`);\n    }\n\n    fixedElements[key] = fixed;\n  }\n\n  return {\n    spec: { root: spec.root, elements: fixedElements },\n    fixes,\n  };\n}\n\n/**\n * Format validation issues into a human-readable string suitable for\n * inclusion in a repair prompt sent back to the AI.\n */\nexport function formatSpecIssues(issues: SpecIssue[]): string {\n  const errors = issues.filter((i) => i.severity === \"error\");\n  if (errors.length === 0) return \"\";\n\n  const lines = [\"The generated UI spec has the following errors:\"];\n  for (const issue of errors) {\n    lines.push(`- ${issue.message}`);\n  }\n  return lines.join(\"\\n\");\n}\n","import { z } from \"zod\";\n\n/**\n * Schema builder primitives\n */\nexport interface SchemaBuilder {\n  /** String type */\n  string(): SchemaType<\"string\">;\n  /** Number type */\n  number(): SchemaType<\"number\">;\n  /** Boolean type */\n  boolean(): SchemaType<\"boolean\">;\n  /** Array of type */\n  array<T extends SchemaType>(item: T): SchemaType<\"array\", T>;\n  /** Object with shape */\n  object<T extends Record<string, SchemaType>>(\n    shape: T,\n  ): SchemaType<\"object\", T>;\n  /** Record/map with value type */\n  record<T extends SchemaType>(value: T): SchemaType<\"record\", T>;\n  /** Any type */\n  any(): SchemaType<\"any\">;\n  /** Placeholder for user-provided Zod schema */\n  zod(): SchemaType<\"zod\">;\n  /** Reference to catalog key (e.g., 'catalog.components') */\n  ref(path: string): SchemaType<\"ref\", string>;\n  /** Props from referenced catalog entry */\n  propsOf(path: string): SchemaType<\"propsOf\", string>;\n  /** Map of named entries with shared shape */\n  map<T extends Record<string, SchemaType>>(\n    entryShape: T,\n  ): SchemaType<\"map\", T>;\n  /** Optional modifier */\n  optional(): { optional: true };\n}\n\n/**\n * Schema type representation\n */\nexport interface SchemaType<TKind extends string = string, TInner = unknown> {\n  kind: TKind;\n  inner?: TInner;\n  optional?: boolean;\n}\n\n/**\n * Schema definition shape\n */\nexport interface SchemaDefinition<\n  TSpec extends SchemaType = SchemaType,\n  TCatalog extends SchemaType = SchemaType,\n> {\n  /** What the AI-generated spec looks like */\n  spec: TSpec;\n  /** What the catalog must provide */\n  catalog: TCatalog;\n}\n\n/**\n * Schema instance with methods\n */\nexport interface Schema<TDef extends SchemaDefinition = SchemaDefinition> {\n  /** The schema definition */\n  readonly definition: TDef;\n  /** Custom prompt template for this schema */\n  readonly promptTemplate?: PromptTemplate;\n  /** Default rules baked into the schema (injected before customRules) */\n  readonly defaultRules?: string[];\n  /** Create a catalog from this schema */\n  createCatalog<TCatalog extends InferCatalogInput<TDef[\"catalog\"]>>(\n    catalog: TCatalog,\n  ): Catalog<TDef, TCatalog>;\n}\n\n/**\n * Catalog instance with methods\n */\nexport interface Catalog<\n  TDef extends SchemaDefinition = SchemaDefinition,\n  TCatalog = unknown,\n> {\n  /** The schema this catalog is based on */\n  readonly schema: Schema<TDef>;\n  /** The catalog data */\n  readonly data: TCatalog;\n  /** Component names */\n  readonly componentNames: string[];\n  /** Action names */\n  readonly actionNames: string[];\n  /** Generate system prompt for AI */\n  prompt(options?: PromptOptions): string;\n  /** Export as JSON Schema for structured outputs */\n  jsonSchema(): object;\n  /** Validate a spec against this catalog */\n  validate(spec: unknown): SpecValidationResult<InferSpec<TDef, TCatalog>>;\n  /** Get the Zod schema for the spec */\n  zodSchema(): z.ZodType<InferSpec<TDef, TCatalog>>;\n  /** Type helper for the spec type */\n  readonly _specType: InferSpec<TDef, TCatalog>;\n}\n\n/**\n * Prompt generation options\n */\nexport interface PromptOptions {\n  /** Custom system message intro */\n  system?: string;\n  /** Additional rules to append */\n  customRules?: string[];\n}\n\n/**\n * Context provided to prompt templates\n */\nexport interface PromptContext<TCatalog = unknown> {\n  /** The catalog data */\n  catalog: TCatalog;\n  /** Component names from the catalog */\n  componentNames: string[];\n  /** Action names from the catalog (if any) */\n  actionNames: string[];\n  /** Prompt options provided by the user */\n  options: PromptOptions;\n  /** Helper to format a Zod type as a human-readable string */\n  formatZodType: (schema: z.ZodType) => string;\n}\n\n/**\n * Prompt template function type\n */\nexport type PromptTemplate<TCatalog = unknown> = (\n  context: PromptContext<TCatalog>,\n) => string;\n\n/**\n * Schema options\n */\nexport interface SchemaOptions<TCatalog = unknown> {\n  /** Custom prompt template for this schema */\n  promptTemplate?: PromptTemplate<TCatalog>;\n  /** Default rules baked into the schema (injected before customRules in prompts) */\n  defaultRules?: string[];\n}\n\n/**\n * Spec validation result\n */\nexport interface SpecValidationResult<T> {\n  success: boolean;\n  data?: T;\n  error?: z.ZodError;\n}\n\n// =============================================================================\n// Catalog Type Inference Helpers\n// =============================================================================\n\n/**\n * Extract the components map type from a catalog\n * @example type Components = InferCatalogComponents<typeof myCatalog>;\n */\nexport type InferCatalogComponents<C extends Catalog> =\n  C extends Catalog<SchemaDefinition, infer TCatalog>\n    ? TCatalog extends { components: infer Comps }\n      ? Comps\n      : never\n    : never;\n\n/**\n * Extract the actions map type from a catalog\n * @example type Actions = InferCatalogActions<typeof myCatalog>;\n */\nexport type InferCatalogActions<C extends Catalog> =\n  C extends Catalog<SchemaDefinition, infer TCatalog>\n    ? TCatalog extends { actions: infer Acts }\n      ? Acts\n      : never\n    : never;\n\n/**\n * Infer component props from a catalog by component name\n * @example type ButtonProps = InferComponentProps<typeof myCatalog, 'Button'>;\n */\nexport type InferComponentProps<\n  C extends Catalog,\n  K extends keyof InferCatalogComponents<C>,\n> = InferCatalogComponents<C>[K] extends { props: z.ZodType<infer P> }\n  ? P\n  : never;\n\n/**\n * Infer action params from a catalog by action name\n * @example type ViewCustomersParams = InferActionParams<typeof myCatalog, 'viewCustomers'>;\n */\nexport type InferActionParams<\n  C extends Catalog,\n  K extends keyof InferCatalogActions<C>,\n> = InferCatalogActions<C>[K] extends { params: z.ZodType<infer P> }\n  ? P\n  : never;\n\n// =============================================================================\n// Internal Type Inference Helpers\n// =============================================================================\n\nexport type InferCatalogInput<T> =\n  T extends SchemaType<\"object\", infer Shape>\n    ? { [K in keyof Shape]: InferCatalogField<Shape[K]> }\n    : never;\n\ntype InferCatalogField<T> =\n  T extends SchemaType<\"map\", infer EntryShape>\n    ? Record<\n        string,\n        // Only 'props' is required, rest are optional\n        InferMapEntryRequired<EntryShape> &\n          Partial<InferMapEntryOptional<EntryShape>>\n      >\n    : T extends SchemaType<\"zod\">\n      ? z.ZodType\n      : T extends SchemaType<\"string\">\n        ? string\n        : T extends SchemaType<\"number\">\n          ? number\n          : T extends SchemaType<\"boolean\">\n            ? boolean\n            : T extends SchemaType<\"array\", infer Item>\n              ? InferCatalogField<Item>[]\n              : T extends SchemaType<\"object\", infer Shape>\n                ? { [K in keyof Shape]: InferCatalogField<Shape[K]> }\n                : unknown;\n\n// Extract required fields (props is always required)\ntype InferMapEntryRequired<T> = {\n  [K in keyof T as K extends \"props\" ? K : never]: InferMapEntryField<T[K]>;\n};\n\n// Extract optional fields (everything except props)\ntype InferMapEntryOptional<T> = {\n  [K in keyof T as K extends \"props\" ? never : K]: InferMapEntryField<T[K]>;\n};\n\ntype InferMapEntryField<T> =\n  T extends SchemaType<\"zod\">\n    ? z.ZodType\n    : T extends SchemaType<\"string\">\n      ? string\n      : T extends SchemaType<\"number\">\n        ? number\n        : T extends SchemaType<\"boolean\">\n          ? boolean\n          : T extends SchemaType<\"array\", infer Item>\n            ? InferMapEntryField<Item>[]\n            : T extends SchemaType<\"object\", infer Shape>\n              ? { [K in keyof Shape]: InferMapEntryField<Shape[K]> }\n              : unknown;\n\n// Spec inference (simplified - will be expanded)\nexport type InferSpec<TDef extends SchemaDefinition, TCatalog> = TDef extends {\n  spec: SchemaType<\"object\", infer Shape>;\n}\n  ? InferSpecObject<Shape, TCatalog>\n  : unknown;\n\ntype InferSpecObject<Shape, TCatalog> = {\n  [K in keyof Shape]: InferSpecField<Shape[K], TCatalog>;\n};\n\ntype InferSpecField<T, TCatalog> =\n  T extends SchemaType<\"string\">\n    ? string\n    : T extends SchemaType<\"number\">\n      ? number\n      : T extends SchemaType<\"boolean\">\n        ? boolean\n        : T extends SchemaType<\"array\", infer Item>\n          ? InferSpecField<Item, TCatalog>[]\n          : T extends SchemaType<\"object\", infer Shape>\n            ? InferSpecObject<Shape, TCatalog>\n            : T extends SchemaType<\"record\", infer Value>\n              ? Record<string, InferSpecField<Value, TCatalog>>\n              : T extends SchemaType<\"ref\", infer Path>\n                ? InferRefType<Path, TCatalog>\n                : T extends SchemaType<\"propsOf\", infer Path>\n                  ? InferPropsOfType<Path, TCatalog>\n                  : T extends SchemaType<\"any\">\n                    ? unknown\n                    : unknown;\n\ntype InferRefType<Path, TCatalog> = Path extends \"catalog.components\"\n  ? TCatalog extends { components: infer C }\n    ? keyof C\n    : string\n  : Path extends \"catalog.actions\"\n    ? TCatalog extends { actions: infer A }\n      ? keyof A\n      : string\n    : string;\n\ntype InferPropsOfType<Path, TCatalog> = Path extends \"catalog.components\"\n  ? TCatalog extends { components: infer C }\n    ? C extends Record<string, { props: z.ZodType<infer P> }>\n      ? P\n      : Record<string, unknown>\n    : Record<string, unknown>\n  : Record<string, unknown>;\n\n/**\n * Create the schema builder\n */\nfunction createBuilder(): SchemaBuilder {\n  return {\n    string: () => ({ kind: \"string\" }),\n    number: () => ({ kind: \"number\" }),\n    boolean: () => ({ kind: \"boolean\" }),\n    array: (item) => ({ kind: \"array\", inner: item }),\n    object: (shape) => ({ kind: \"object\", inner: shape }),\n    record: (value) => ({ kind: \"record\", inner: value }),\n    any: () => ({ kind: \"any\" }),\n    zod: () => ({ kind: \"zod\" }),\n    ref: (path) => ({ kind: \"ref\", inner: path }),\n    propsOf: (path) => ({ kind: \"propsOf\", inner: path }),\n    map: (entryShape) => ({ kind: \"map\", inner: entryShape }),\n    optional: () => ({ optional: true }),\n  };\n}\n\n/**\n * Define a schema using the builder pattern\n */\nexport function defineSchema<TDef extends SchemaDefinition>(\n  builder: (s: SchemaBuilder) => TDef,\n  options?: SchemaOptions,\n): Schema<TDef> {\n  const s = createBuilder();\n  const definition = builder(s);\n\n  return {\n    definition,\n    promptTemplate: options?.promptTemplate,\n    defaultRules: options?.defaultRules,\n    createCatalog<TCatalog extends InferCatalogInput<TDef[\"catalog\"]>>(\n      catalog: TCatalog,\n    ): Catalog<TDef, TCatalog> {\n      return createCatalogFromSchema(this as Schema<TDef>, catalog);\n    },\n  };\n}\n\n/**\n * Create a catalog from a schema (internal)\n */\nfunction createCatalogFromSchema<TDef extends SchemaDefinition, TCatalog>(\n  schema: Schema<TDef>,\n  catalogData: TCatalog,\n): Catalog<TDef, TCatalog> {\n  // Extract component and action names\n  const components = (catalogData as Record<string, unknown>).components as\n    | Record<string, unknown>\n    | undefined;\n  const actions = (catalogData as Record<string, unknown>).actions as\n    | Record<string, unknown>\n    | undefined;\n\n  const componentNames = components ? Object.keys(components) : [];\n  const actionNames = actions ? Object.keys(actions) : [];\n\n  // Build the Zod schema for validation\n  const zodSchema = buildZodSchemaFromDefinition(\n    schema.definition,\n    catalogData,\n  );\n\n  return {\n    schema,\n    data: catalogData,\n    componentNames,\n    actionNames,\n\n    prompt(options: PromptOptions = {}): string {\n      return generatePrompt(this, options);\n    },\n\n    jsonSchema(): object {\n      return zodToJsonSchema(zodSchema);\n    },\n\n    validate(spec: unknown): SpecValidationResult<InferSpec<TDef, TCatalog>> {\n      const result = zodSchema.safeParse(spec);\n      if (result.success) {\n        return {\n          success: true,\n          data: result.data as InferSpec<TDef, TCatalog>,\n        };\n      }\n      return { success: false, error: result.error };\n    },\n\n    zodSchema(): z.ZodType<InferSpec<TDef, TCatalog>> {\n      return zodSchema as z.ZodType<InferSpec<TDef, TCatalog>>;\n    },\n\n    get _specType(): InferSpec<TDef, TCatalog> {\n      throw new Error(\"_specType is only for type inference\");\n    },\n  };\n}\n\n/**\n * Build Zod schema from schema definition\n */\nfunction buildZodSchemaFromDefinition(\n  definition: SchemaDefinition,\n  catalogData: unknown,\n): z.ZodType {\n  return buildZodType(definition.spec, catalogData);\n}\n\nfunction buildZodType(schemaType: SchemaType, catalogData: unknown): z.ZodType {\n  switch (schemaType.kind) {\n    case \"string\":\n      return z.string();\n    case \"number\":\n      return z.number();\n    case \"boolean\":\n      return z.boolean();\n    case \"any\":\n      return z.any();\n    case \"array\": {\n      const inner = buildZodType(schemaType.inner as SchemaType, catalogData);\n      return z.array(inner);\n    }\n    case \"object\": {\n      const shape = schemaType.inner as Record<string, SchemaType>;\n      const zodShape: Record<string, z.ZodType> = {};\n      for (const [key, value] of Object.entries(shape)) {\n        let zodType = buildZodType(value, catalogData);\n        if (value.optional) {\n          zodType = zodType.optional();\n        }\n        zodShape[key] = zodType;\n      }\n      return z.object(zodShape);\n    }\n    case \"record\": {\n      const inner = buildZodType(schemaType.inner as SchemaType, catalogData);\n      return z.record(z.string(), inner);\n    }\n    case \"ref\": {\n      // Reference to catalog key - create enum of valid keys\n      const path = schemaType.inner as string;\n      const keys = getKeysFromPath(path, catalogData);\n      if (keys.length === 0) {\n        return z.string();\n      }\n      if (keys.length === 1) {\n        return z.literal(keys[0]!);\n      }\n      return z.enum(keys as [string, ...string[]]);\n    }\n    case \"propsOf\": {\n      // Props from catalog entry - create union of all props schemas\n      const path = schemaType.inner as string;\n      const propsSchemas = getPropsFromPath(path, catalogData);\n      if (propsSchemas.length === 0) {\n        return z.record(z.string(), z.unknown());\n      }\n      if (propsSchemas.length === 1) {\n        return propsSchemas[0]!;\n      }\n      // For propsOf, we need to be lenient since type determines which props apply\n      return z.record(z.string(), z.unknown());\n    }\n    default:\n      return z.unknown();\n  }\n}\n\nfunction getKeysFromPath(path: string, catalogData: unknown): string[] {\n  const parts = path.split(\".\");\n  let current: unknown = { catalog: catalogData };\n  for (const part of parts) {\n    if (current && typeof current === \"object\") {\n      current = (current as Record<string, unknown>)[part];\n    } else {\n      return [];\n    }\n  }\n  if (current && typeof current === \"object\") {\n    return Object.keys(current);\n  }\n  return [];\n}\n\nfunction getPropsFromPath(path: string, catalogData: unknown): z.ZodType[] {\n  const parts = path.split(\".\");\n  let current: unknown = { catalog: catalogData };\n  for (const part of parts) {\n    if (current && typeof current === \"object\") {\n      current = (current as Record<string, unknown>)[part];\n    } else {\n      return [];\n    }\n  }\n  if (current && typeof current === \"object\") {\n    return Object.values(current as Record<string, { props?: z.ZodType }>)\n      .map((entry) => entry.props)\n      .filter((props): props is z.ZodType => props !== undefined);\n  }\n  return [];\n}\n\n/**\n * Generate system prompt from catalog\n */\nfunction generatePrompt<TDef extends SchemaDefinition, TCatalog>(\n  catalog: Catalog<TDef, TCatalog>,\n  options: PromptOptions,\n): string {\n  // Check if schema has a custom prompt template\n  if (catalog.schema.promptTemplate) {\n    const context: PromptContext<TCatalog> = {\n      catalog: catalog.data,\n      componentNames: catalog.componentNames,\n      actionNames: catalog.actionNames,\n      options,\n      formatZodType,\n    };\n    return catalog.schema.promptTemplate(context);\n  }\n\n  // Default JSONL element-tree format (for @json-render/react and similar)\n  const {\n    system = \"You are a UI generator that outputs JSON.\",\n    customRules = [],\n  } = options;\n\n  const lines: string[] = [];\n  lines.push(system);\n  lines.push(\"\");\n\n  // Output format section - explain JSONL streaming patch format\n  lines.push(\"OUTPUT FORMAT (JSONL, RFC 6902 JSON Patch):\");\n  lines.push(\n    \"Output JSONL (one JSON object per line) using RFC 6902 JSON Patch operations to build a UI tree.\",\n  );\n  lines.push(\n    \"Each line is a JSON patch operation (add, remove, replace). Start with /root, then stream /elements and /state patches interleaved so the UI fills in progressively as it streams.\",\n  );\n  lines.push(\"\");\n  lines.push(\"Example output (each line is a separate JSON object):\");\n  lines.push(\"\");\n\n  // Build example using actual catalog component names and props to avoid hallucinations\n  const allComponents = (catalog.data as Record<string, unknown>).components as\n    | Record<string, CatalogComponentDef>\n    | undefined;\n  const cn = catalog.componentNames;\n  const comp1 = cn[0] || \"Component\";\n  const comp2 = cn.length > 1 ? cn[1]! : comp1;\n  const comp1Def = allComponents?.[comp1];\n  const comp2Def = allComponents?.[comp2];\n  const comp1Props = comp1Def ? getExampleProps(comp1Def) : {};\n  const comp2Props = comp2Def ? getExampleProps(comp2Def) : {};\n\n  // Find a string prop on comp2 to demonstrate $path dynamic bindings\n  const dynamicPropName = comp2Def?.props\n    ? findFirstStringProp(comp2Def.props)\n    : null;\n  const dynamicProps = dynamicPropName\n    ? { ...comp2Props, [dynamicPropName]: { $path: \"$item/title\" } }\n    : comp2Props;\n\n  const exampleOutput = [\n    JSON.stringify({ op: \"add\", path: \"/root\", value: \"main\" }),\n    JSON.stringify({\n      op: \"add\",\n      path: \"/elements/main\",\n      value: {\n        type: comp1,\n        props: comp1Props,\n        children: [\"child-1\", \"list\"],\n      },\n    }),\n    JSON.stringify({\n      op: \"add\",\n      path: \"/elements/child-1\",\n      value: { type: comp2, props: comp2Props, children: [] },\n    }),\n    JSON.stringify({\n      op: \"add\",\n      path: \"/elements/list\",\n      value: {\n        type: comp1,\n        props: comp1Props,\n        repeat: { path: \"/items\", key: \"id\" },\n        children: [\"item\"],\n      },\n    }),\n    JSON.stringify({\n      op: \"add\",\n      path: \"/elements/item\",\n      value: { type: comp2, props: dynamicProps, children: [] },\n    }),\n    JSON.stringify({ op: \"add\", path: \"/state/items\", value: [] }),\n    JSON.stringify({\n      op: \"add\",\n      path: \"/state/items/0\",\n      value: { id: \"1\", title: \"First Item\" },\n    }),\n    JSON.stringify({\n      op: \"add\",\n      path: \"/state/items/1\",\n      value: { id: \"2\", title: \"Second Item\" },\n    }),\n  ].join(\"\\n\");\n\n  lines.push(`${exampleOutput}\n\nNote: state patches appear right after the elements that use them, so the UI fills in as it streams. ONLY use component types from the AVAILABLE COMPONENTS list below.`);\n  lines.push(\"\");\n\n  // Initial state section\n  lines.push(\"INITIAL STATE:\");\n  lines.push(\n    \"Specs include a /state field to seed the state model. Components with statePath read from and write to this state, and $path expressions read from it.\",\n  );\n  lines.push(\n    \"CRITICAL: You MUST include state patches whenever your UI displays data via $path expressions, uses repeat to iterate over arrays, or uses statePath bindings. Without state, $path references resolve to nothing and repeat lists render zero items.\",\n  );\n  lines.push(\n    \"Output state patches right after the elements that reference them, so the UI fills in progressively as it streams.\",\n  );\n  lines.push(\n    \"Stream state progressively - output one patch per array item instead of one giant blob:\",\n  );\n  lines.push(\n    '  For arrays: {\"op\":\"add\",\"path\":\"/state/posts/0\",\"value\":{\"id\":\"1\",\"title\":\"First Post\",...}} then /state/posts/1, /state/posts/2, etc.',\n  );\n  lines.push(\n    '  For scalars: {\"op\":\"add\",\"path\":\"/state/newTodoText\",\"value\":\"\"}',\n  );\n  lines.push(\n    '  Initialize the array first if needed: {\"op\":\"add\",\"path\":\"/state/posts\",\"value\":[]}',\n  );\n  lines.push(\n    'When content comes from the state model, use { \"$path\": \"/some/path\" } dynamic props to display it instead of hardcoding the same value in both state and props. The state model is the single source of truth.',\n  );\n  lines.push(\n    \"Include realistic sample data in state. For blogs: 3-4 posts with titles, excerpts, authors, dates. For product lists: 3-5 items with names, prices, descriptions. Never leave arrays empty.\",\n  );\n  lines.push(\"\");\n  lines.push(\"DYNAMIC LISTS (repeat field):\");\n  lines.push(\n    'Any element can have a top-level \"repeat\" field to render its children once per item in a state array: { \"repeat\": { \"path\": \"/arrayPath\", \"key\": \"id\" } }.',\n  );\n  lines.push(\n    'The element itself renders once (as the container), and its children are expanded once per array item. \"path\" is the state array path. \"key\" is an optional field name on each item for stable React keys.',\n  );\n  lines.push(\n    `Example: ${JSON.stringify({ type: comp1, props: comp1Props, repeat: { path: \"/todos\", key: \"id\" }, children: [\"todo-item\"] })}`,\n  );\n  lines.push(\n    'Inside children of a repeated element, use \"$item/field\" for per-item paths: statePath:\"$item/completed\", { \"$path\": \"$item/title\" }. Use \"$index\" for the current array index.',\n  );\n  lines.push(\n    \"ALWAYS use the repeat field for lists backed by state arrays. NEVER hardcode individual elements for each array item.\",\n  );\n  lines.push(\n    'IMPORTANT: \"repeat\" is a top-level field on the element (sibling of type/props/children), NOT inside props.',\n  );\n  lines.push(\"\");\n  lines.push(\"ARRAY STATE ACTIONS:\");\n  lines.push(\n    'Use action \"pushState\" to append items to arrays. Params: { path: \"/arrayPath\", value: { ...item }, clearPath: \"/inputPath\" }.',\n  );\n  lines.push(\n    'Values inside pushState can contain { \"path\": \"/statePath\" } references to read current state (e.g. the text from an input field).',\n  );\n  lines.push(\n    'Use \"$id\" inside a pushState value to auto-generate a unique ID.',\n  );\n  lines.push(\n    'Example: on: { \"press\": { \"action\": \"pushState\", \"params\": { \"path\": \"/todos\", \"value\": { \"id\": \"$id\", \"title\": { \"path\": \"/newTodoText\" }, \"completed\": false }, \"clearPath\": \"/newTodoText\" } } }',\n  );\n  lines.push(\n    'Use action \"removeState\" to remove items from arrays by index. Params: { path: \"/arrayPath\", index: N }. Inside a repeated element\\'s children, use \"$index\" for the current item index.',\n  );\n  lines.push(\n    \"For lists where users can add/remove items (todos, carts, etc.), use pushState and removeState instead of hardcoding with setState.\",\n  );\n  lines.push(\"\");\n  lines.push(\n    'IMPORTANT: State paths use RFC 6901 JSON Pointer syntax (e.g. \"/todos/0/title\"). Do NOT use JavaScript-style dot notation (e.g. \"/todos.length\" is WRONG). To generate unique IDs for new items, use \"$id\" instead of trying to read array length.',\n  );\n  lines.push(\"\");\n\n  // Components section — reuse the typed reference from example generation\n  const components = allComponents;\n\n  if (components) {\n    lines.push(`AVAILABLE COMPONENTS (${catalog.componentNames.length}):`);\n    lines.push(\"\");\n\n    for (const [name, def] of Object.entries(components)) {\n      const propsStr = def.props ? formatZodType(def.props) : \"{}\";\n      const hasChildren = def.slots && def.slots.length > 0;\n      const childrenStr = hasChildren ? \" [accepts children]\" : \"\";\n      const eventsStr =\n        def.events && def.events.length > 0\n          ? ` [events: ${def.events.join(\", \")}]`\n          : \"\";\n      const descStr = def.description ? ` - ${def.description}` : \"\";\n      lines.push(`- ${name}: ${propsStr}${descStr}${childrenStr}${eventsStr}`);\n    }\n    lines.push(\"\");\n  }\n\n  // Actions section\n  const actions = (catalog.data as Record<string, unknown>).actions as\n    | Record<string, { params?: z.ZodType; description?: string }>\n    | undefined;\n\n  if (actions && catalog.actionNames.length > 0) {\n    lines.push(\"AVAILABLE ACTIONS:\");\n    lines.push(\"\");\n    for (const [name, def] of Object.entries(actions)) {\n      lines.push(`- ${name}${def.description ? `: ${def.description}` : \"\"}`);\n    }\n    lines.push(\"\");\n  }\n\n  // Events section\n  lines.push(\"EVENTS (the `on` field):\");\n  lines.push(\n    \"Elements can have an optional `on` field to bind events to actions. The `on` field is a top-level field on the element (sibling of type/props/children), NOT inside props.\",\n  );\n  lines.push(\n    'Each key in `on` is an event name (from the component\\'s supported events), and the value is an action binding: `{ \"action\": \"<actionName>\", \"params\": { ... } }`.',\n  );\n  lines.push(\"\");\n  lines.push(\"Example:\");\n  lines.push(\n    `  ${JSON.stringify({ type: comp1, props: comp1Props, on: { press: { action: \"setState\", params: { path: \"/saved\", value: true } } }, children: [] })}`,\n  );\n  lines.push(\"\");\n  lines.push(\n    'Action params can use dynamic path references to read from state: { \"path\": \"/statePath\" }.',\n  );\n  lines.push(\n    \"IMPORTANT: Do NOT put action/actionParams inside props. Always use the `on` field for event bindings.\",\n  );\n  lines.push(\"\");\n\n  // Visibility conditions\n  lines.push(\"VISIBILITY CONDITIONS:\");\n  lines.push(\n    \"Elements can have an optional `visible` field to conditionally show/hide based on data state. IMPORTANT: `visible` is a top-level field on the element object (sibling of type/props/children), NOT inside props.\",\n  );\n  lines.push(\n    `Correct: ${JSON.stringify({ type: comp1, props: comp1Props, visible: { eq: [{ path: \"/tab\" }, \"home\"] }, children: [\"...\"] })}`,\n  );\n  lines.push(\n    '- `{ \"eq\": [{ \"path\": \"/statePath\" }, \"value\"] }` - visible when state at path equals value',\n  );\n  lines.push(\n    '- `{ \"neq\": [{ \"path\": \"/statePath\" }, \"value\"] }` - visible when state at path does not equal value',\n  );\n  lines.push('- `{ \"path\": \"/statePath\" }` - visible when path is truthy');\n  lines.push(\n    '- `{ \"and\": [...] }`, `{ \"or\": [...] }`, `{ \"not\": {...} }` - combine conditions',\n  );\n  lines.push(\"- `true` / `false` - always visible/hidden\");\n  lines.push(\"\");\n  lines.push(\n    \"Use a component with on.press bound to setState to update state and drive visibility.\",\n  );\n  lines.push(\n    `Example: A ${comp1} with on: { \"press\": { \"action\": \"setState\", \"params\": { \"path\": \"/activeTab\", \"value\": \"home\" } } } sets state, then a container with visible: { \"eq\": [{ \"path\": \"/activeTab\" }, \"home\"] } shows only when that tab is active.`,\n  );\n  lines.push(\"\");\n\n  // Dynamic prop expressions\n  lines.push(\"DYNAMIC PROPS:\");\n  lines.push(\n    \"Any prop value can be a dynamic expression that resolves based on state. Two forms are supported:\",\n  );\n  lines.push(\"\");\n  lines.push(\n    '1. State binding: `{ \"$path\": \"/statePath\" }` - resolves to the value at that state path.',\n  );\n  lines.push(\n    '   Example: `\"color\": { \"$path\": \"/theme/primary\" }` reads the color from state.',\n  );\n  lines.push(\"\");\n  lines.push(\n    '2. Conditional: `{ \"$cond\": <condition>, \"$then\": <value>, \"$else\": <value> }` - evaluates the condition (same syntax as visibility conditions) and picks the matching value.',\n  );\n  lines.push(\n    '   Example: `\"color\": { \"$cond\": { \"eq\": [{ \"path\": \"/activeTab\" }, \"home\"] }, \"$then\": \"#007AFF\", \"$else\": \"#8E8E93\" }`',\n  );\n  lines.push(\n    '   Example: `\"name\": { \"$cond\": { \"eq\": [{ \"path\": \"/activeTab\" }, \"home\"] }, \"$then\": \"home\", \"$else\": \"home-outline\" }`',\n  );\n  lines.push(\"\");\n  lines.push(\n    \"Use dynamic props instead of duplicating elements with opposing visible conditions when only prop values differ.\",\n  );\n  lines.push(\"\");\n\n  // Rules\n  lines.push(\"RULES:\");\n  const baseRules = [\n    \"Output ONLY JSONL patches - one JSON object per line, no markdown, no code fences\",\n    'First set root: {\"op\":\"add\",\"path\":\"/root\",\"value\":\"<root-key>\"}',\n    'Then add each element: {\"op\":\"add\",\"path\":\"/elements/<key>\",\"value\":{...}}',\n    \"Output /state patches right after the elements that use them, one per array item for progressive loading. REQUIRED whenever using $path, repeat, or statePath.\",\n    \"ONLY use components listed above\",\n    \"Each element value needs: type, props, children (array of child keys)\",\n    \"Use unique keys for the element map entries (e.g., 'header', 'metric-1', 'chart-revenue')\",\n  ];\n  const schemaRules = catalog.schema.defaultRules ?? [];\n  const allRules = [...baseRules, ...schemaRules, ...customRules];\n  allRules.forEach((rule, i) => {\n    lines.push(`${i + 1}. ${rule}`);\n  });\n\n  return lines.join(\"\\n\");\n}\n\n// =============================================================================\n// Example Value Generation from Zod Schemas\n// =============================================================================\n\n/**\n * Component definition shape as it appears in catalog data\n */\ninterface CatalogComponentDef {\n  props?: z.ZodType;\n  description?: string;\n  slots?: string[];\n  events?: string[];\n  example?: Record<string, unknown>;\n}\n\n/**\n * Get example props for a catalog component.\n * Uses the explicit `example` field if provided, otherwise generates from Zod schema.\n */\nfunction getExampleProps(def: CatalogComponentDef): Record<string, unknown> {\n  if (def.example && Object.keys(def.example).length > 0) {\n    return def.example;\n  }\n  if (def.props) {\n    return generateExamplePropsFromZod(def.props);\n  }\n  return {};\n}\n\n/**\n * Generate example prop values from a Zod object schema.\n * Only includes required fields to keep examples concise.\n */\nfunction generateExamplePropsFromZod(\n  schema: z.ZodType,\n): Record<string, unknown> {\n  if (!schema || !schema._def) return {};\n  const def = schema._def as unknown as Record<string, unknown>;\n  const typeName = getZodTypeName(schema);\n\n  if (typeName !== \"ZodObject\" && typeName !== \"object\") return {};\n\n  const shape =\n    typeof def.shape === \"function\"\n      ? (def.shape as () => Record<string, z.ZodType>)()\n      : (def.shape as Record<string, z.ZodType>);\n  if (!shape) return {};\n\n  const result: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(shape)) {\n    const innerTypeName = getZodTypeName(value);\n    // Skip optional props to keep examples concise\n    if (\n      innerTypeName === \"ZodOptional\" ||\n      innerTypeName === \"optional\" ||\n      innerTypeName === \"ZodNullable\" ||\n      innerTypeName === \"nullable\"\n    ) {\n      continue;\n    }\n    result[key] = generateExampleValue(value);\n  }\n  return result;\n}\n\n/**\n * Generate a single example value from a Zod type.\n */\nfunction generateExampleValue(schema: z.ZodType): unknown {\n  if (!schema || !schema._def) return \"...\";\n  const def = schema._def as unknown as Record<string, unknown>;\n  const typeName = getZodTypeName(schema);\n\n  switch (typeName) {\n    case \"ZodString\":\n    case \"string\":\n      return \"example\";\n    case \"ZodNumber\":\n    case \"number\":\n      return 0;\n    case \"ZodBoolean\":\n    case \"boolean\":\n      return true;\n    case \"ZodLiteral\":\n    case \"literal\":\n      return def.value;\n    case \"ZodEnum\":\n    case \"enum\": {\n      if (Array.isArray(def.values) && def.values.length > 0)\n        return def.values[0];\n      if (def.entries && typeof def.entries === \"object\") {\n        const values = Object.values(def.entries as Record<string, string>);\n        return values.length > 0 ? values[0] : \"example\";\n      }\n      return \"example\";\n    }\n    case \"ZodOptional\":\n    case \"optional\":\n    case \"ZodNullable\":\n    case \"nullable\":\n    case \"ZodDefault\":\n    case \"default\": {\n      const inner = (def.innerType as z.ZodType) ?? (def.wrapped as z.ZodType);\n      return inner ? generateExampleValue(inner) : null;\n    }\n    case \"ZodArray\":\n    case \"array\":\n      return [];\n    case \"ZodObject\":\n    case \"object\":\n      return generateExamplePropsFromZod(schema);\n    case \"ZodUnion\":\n    case \"union\": {\n      const options = def.options as z.ZodType[] | undefined;\n      return options && options.length > 0\n        ? generateExampleValue(options[0]!)\n        : \"...\";\n    }\n    default:\n      return \"...\";\n  }\n}\n\n/**\n * Find the name of the first required string prop in a Zod object schema.\n * Used to demonstrate $path dynamic bindings in examples.\n */\nfunction findFirstStringProp(schema?: z.ZodType): string | null {\n  if (!schema || !schema._def) return null;\n  const def = schema._def as unknown as Record<string, unknown>;\n  const typeName = getZodTypeName(schema);\n\n  if (typeName !== \"ZodObject\" && typeName !== \"object\") return null;\n\n  const shape =\n    typeof def.shape === \"function\"\n      ? (def.shape as () => Record<string, z.ZodType>)()\n      : (def.shape as Record<string, z.ZodType>);\n  if (!shape) return null;\n\n  for (const [key, value] of Object.entries(shape)) {\n    const innerTypeName = getZodTypeName(value);\n    // Skip optional props\n    if (\n      innerTypeName === \"ZodOptional\" ||\n      innerTypeName === \"optional\" ||\n      innerTypeName === \"ZodNullable\" ||\n      innerTypeName === \"nullable\"\n    ) {\n      continue;\n    }\n    // Unwrap to check the actual type\n    if (innerTypeName === \"ZodString\" || innerTypeName === \"string\") {\n      return key;\n    }\n  }\n  return null;\n}\n\n// =============================================================================\n// Zod Introspection Helpers\n// =============================================================================\n\n/**\n * Get Zod type name from schema (handles different Zod versions)\n */\nfunction getZodTypeName(schema: z.ZodType): string {\n  if (!schema || !schema._def) return \"\";\n  const def = schema._def as unknown as Record<string, unknown>;\n  // Zod 4+ uses _def.type, older versions use _def.typeName\n  return (def.typeName as string) ?? (def.type as string) ?? \"\";\n}\n\n/**\n * Format a Zod type into a human-readable string\n */\nfunction formatZodType(schema: z.ZodType): string {\n  if (!schema || !schema._def) return \"unknown\";\n  const def = schema._def as unknown as Record<string, unknown>;\n  const typeName = getZodTypeName(schema);\n\n  switch (typeName) {\n    case \"ZodString\":\n    case \"string\":\n      return \"string\";\n    case \"ZodNumber\":\n    case \"number\":\n      return \"number\";\n    case \"ZodBoolean\":\n    case \"boolean\":\n      return \"boolean\";\n    case \"ZodLiteral\":\n    case \"literal\":\n      return JSON.stringify(def.value);\n    case \"ZodEnum\":\n    case \"enum\": {\n      // Zod 3 uses values array, Zod 4 uses entries object\n      let values: string[];\n      if (Array.isArray(def.values)) {\n        values = def.values as string[];\n      } else if (def.entries && typeof def.entries === \"object\") {\n        values = Object.values(def.entries as Record<string, string>);\n      } else {\n        return \"enum\";\n      }\n      return values.map((v) => `\"${v}\"`).join(\" | \");\n    }\n    case \"ZodArray\":\n    case \"array\": {\n      const inner = (def.type as z.ZodType) ?? (def.element as z.ZodType);\n      return inner ? `Array<${formatZodType(inner)}>` : \"Array<unknown>\";\n    }\n    case \"ZodObject\":\n    case \"object\": {\n      // Shape can be a function (Zod 3) or direct object (Zod 4)\n      const shape =\n        typeof def.shape === \"function\"\n          ? (def.shape as () => Record<string, z.ZodType>)()\n          : (def.shape as Record<string, z.ZodType>);\n      if (!shape) return \"object\";\n      const props = Object.entries(shape)\n        .map(([key, value]) => {\n          const innerTypeName = getZodTypeName(value);\n          const isOptional =\n            innerTypeName === \"ZodOptional\" ||\n            innerTypeName === \"ZodNullable\" ||\n            innerTypeName === \"optional\" ||\n            innerTypeName === \"nullable\";\n          return `${key}${isOptional ? \"?\" : \"\"}: ${formatZodType(value)}`;\n        })\n        .join(\", \");\n      return `{ ${props} }`;\n    }\n    case \"ZodOptional\":\n    case \"optional\":\n    case \"ZodNullable\":\n    case \"nullable\": {\n      const inner = (def.innerType as z.ZodType) ?? (def.wrapped as z.ZodType);\n      return inner ? formatZodType(inner) : \"unknown\";\n    }\n    case \"ZodUnion\":\n    case \"union\": {\n      const options = def.options as z.ZodType[] | undefined;\n      return options\n        ? options.map((opt) => formatZodType(opt)).join(\" | \")\n        : \"unknown\";\n    }\n    default:\n      return \"unknown\";\n  }\n}\n\n/**\n * Convert Zod schema to JSON Schema\n */\nfunction zodToJsonSchema(schema: z.ZodType): object {\n  // Simplified JSON Schema conversion\n  const def = schema._def as unknown as Record<string, unknown>;\n  const typeName = (def.typeName as string) ?? \"\";\n\n  switch (typeName) {\n    case \"ZodString\":\n      return { type: \"string\" };\n    case \"ZodNumber\":\n      return { type: \"number\" };\n    case \"ZodBoolean\":\n      return { type: \"boolean\" };\n    case \"ZodLiteral\":\n      return { const: def.value };\n    case \"ZodEnum\":\n      return { enum: def.values };\n    case \"ZodArray\": {\n      const inner = def.type as z.ZodType | undefined;\n      return {\n        type: \"array\",\n        items: inner ? zodToJsonSchema(inner) : {},\n      };\n    }\n    case \"ZodObject\": {\n      const shape = (def.shape as () => Record<string, z.ZodType>)?.();\n      if (!shape) return { type: \"object\" };\n      const properties: Record<string, object> = {};\n      const required: string[] = [];\n      for (const [key, value] of Object.entries(shape)) {\n        properties[key] = zodToJsonSchema(value);\n        const innerDef = value._def as unknown as Record<string, unknown>;\n        if (\n          innerDef.typeName !== \"ZodOptional\" &&\n          innerDef.typeName !== \"ZodNullable\"\n        ) {\n          required.push(key);\n        }\n      }\n      return {\n        type: \"object\",\n        properties,\n        required: required.length > 0 ? required : undefined,\n        additionalProperties: false,\n      };\n    }\n    case \"ZodRecord\": {\n      const valueType = def.valueType as z.ZodType | undefined;\n      return {\n        type: \"object\",\n        additionalProperties: valueType ? zodToJsonSchema(valueType) : true,\n      };\n    }\n    case \"ZodOptional\":\n    case \"ZodNullable\": {\n      const inner = def.innerType as z.ZodType | undefined;\n      return inner ? zodToJsonSchema(inner) : {};\n    }\n    case \"ZodUnion\": {\n      const options = def.options as z.ZodType[] | undefined;\n      return options ? { anyOf: options.map(zodToJsonSchema) } : {};\n    }\n    case \"ZodAny\":\n      return {};\n    default:\n      return {};\n  }\n}\n\n/**\n * Shorthand: Define a catalog directly from a schema\n */\nexport function defineCatalog<\n  TDef extends SchemaDefinition,\n  TCatalog extends InferCatalogInput<TDef[\"catalog\"]>,\n>(schema: Schema<TDef>, catalog: TCatalog): Catalog<TDef, TCatalog> {\n  return schema.createCatalog(catalog);\n}\n","import type { Spec } from \"./types\";\n\n/**\n * Options for building a user prompt.\n */\nexport interface UserPromptOptions {\n  /** The user's text prompt */\n  prompt: string;\n  /** Existing spec to refine (triggers patch-only mode) */\n  currentSpec?: Spec | null;\n  /** Runtime state context to include */\n  state?: Record<string, unknown> | null;\n  /** Maximum length for the user's text prompt (applied before wrapping) */\n  maxPromptLength?: number;\n}\n\n/**\n * Check whether a spec is non-empty (has a root and at least one element).\n */\nfunction isNonEmptySpec(spec: unknown): spec is Spec {\n  if (!spec || typeof spec !== \"object\") return false;\n  const s = spec as Record<string, unknown>;\n  return (\n    typeof s.root === \"string\" &&\n    typeof s.elements === \"object\" &&\n    s.elements !== null &&\n    Object.keys(s.elements as object).length > 0\n  );\n}\n\nconst PATCH_INSTRUCTIONS = `IMPORTANT: The current UI is already loaded. Output ONLY the patches needed to make the requested change:\n- To add a new element: {\"op\":\"add\",\"path\":\"/elements/new-key\",\"value\":{...}}\n- To modify an existing element: {\"op\":\"replace\",\"path\":\"/elements/existing-key\",\"value\":{...}}\n- To remove an element: {\"op\":\"remove\",\"path\":\"/elements/old-key\"}\n- To update the root: {\"op\":\"replace\",\"path\":\"/root\",\"value\":\"new-root-key\"}\n- To add children: update the parent element with new children array\n\nDO NOT output patches for elements that don't need to change. Only output what's necessary for the requested modification.`;\n\n/**\n * Build a user prompt for AI generation.\n *\n * Handles common patterns that every consuming app needs:\n * - Truncating the user's prompt to a max length\n * - Including the current spec for refinement (patch-only mode)\n * - Including runtime state context\n *\n * @example\n * ```ts\n * // Fresh generation\n * buildUserPrompt({ prompt: \"create a todo app\" })\n *\n * // Refinement with existing spec\n * buildUserPrompt({ prompt: \"add a dark mode toggle\", currentSpec: spec })\n *\n * // With state context\n * buildUserPrompt({ prompt: \"show my data\", state: { todos: [] } })\n * ```\n */\nexport function buildUserPrompt(options: UserPromptOptions): string {\n  const { prompt, currentSpec, state, maxPromptLength } = options;\n\n  // Sanitize and optionally truncate the user's text\n  let userText = String(prompt || \"\");\n  if (maxPromptLength !== undefined && maxPromptLength > 0) {\n    userText = userText.slice(0, maxPromptLength);\n  }\n\n  // --- Refinement mode: currentSpec is provided ---\n  if (isNonEmptySpec(currentSpec)) {\n    const parts: string[] = [];\n\n    parts.push(\n      `CURRENT UI STATE (already loaded, DO NOT recreate existing elements):`,\n    );\n    parts.push(JSON.stringify(currentSpec, null, 2));\n    parts.push(\"\");\n    parts.push(`USER REQUEST: ${userText}`);\n\n    // Append state context if provided\n    if (state && Object.keys(state).length > 0) {\n      parts.push(\"\");\n      parts.push(`AVAILABLE STATE:\\n${JSON.stringify(state, null, 2)}`);\n    }\n\n    parts.push(\"\");\n    parts.push(PATCH_INSTRUCTIONS);\n\n    return parts.join(\"\\n\");\n  }\n\n  // --- Fresh generation mode ---\n  const parts: string[] = [userText];\n\n  if (state && Object.keys(state).length > 0) {\n    parts.push(`\\nAVAILABLE STATE:\\n${JSON.stringify(state, null, 2)}`);\n  }\n\n  parts.push(\n    `\\nRemember: Output /root first, then interleave /elements and /state patches so the UI fills in progressively as it streams. Output each state patch right after the elements that use it, one per array item.`,\n  );\n\n  return parts.join(\"\\n\");\n}\n","import { z } from \"zod\";\nimport type {\n  ComponentSchema,\n  ValidationMode,\n  UIElement,\n  Spec,\n  VisibilityCondition,\n} from \"./types\";\nimport { VisibilityConditionSchema } from \"./visibility\";\nimport { ActionSchema, type ActionDefinition } from \"./actions\";\nimport { ValidationConfigSchema, type ValidationFunction } from \"./validation\";\n\n/**\n * Component definition with visibility and validation support\n */\nexport interface ComponentDefinition<\n  TProps extends ComponentSchema = ComponentSchema,\n> {\n  /** Zod schema for component props */\n  props: TProps;\n  /** Whether this component can have children */\n  hasChildren?: boolean;\n  /** Description for AI generation */\n  description?: string;\n  /** Example prop values used in prompt examples (auto-generated from Zod schema if omitted) */\n  example?: Record<string, unknown>;\n}\n\n/**\n * Catalog configuration\n */\nexport interface CatalogConfig<\n  TComponents extends Record<string, ComponentDefinition> = Record<\n    string,\n    ComponentDefinition\n  >,\n  TActions extends Record<string, ActionDefinition> = Record<\n    string,\n    ActionDefinition\n  >,\n  TFunctions extends Record<string, ValidationFunction> = Record<\n    string,\n    ValidationFunction\n  >,\n> {\n  /** Catalog name */\n  name?: string;\n  /** Component definitions */\n  components: TComponents;\n  /** Action definitions with param schemas */\n  actions?: TActions;\n  /** Custom validation functions */\n  functions?: TFunctions;\n  /** Validation mode */\n  validation?: ValidationMode;\n}\n\n/**\n * Catalog instance\n */\nexport interface Catalog<\n  TComponents extends Record<string, ComponentDefinition> = Record<\n    string,\n    ComponentDefinition\n  >,\n  TActions extends Record<string, ActionDefinition> = Record<\n    string,\n    ActionDefinition\n  >,\n  TFunctions extends Record<string, ValidationFunction> = Record<\n    string,\n    ValidationFunction\n  >,\n> {\n  /** Catalog name */\n  readonly name: string;\n  /** Component names */\n  readonly componentNames: (keyof TComponents)[];\n  /** Action names */\n  readonly actionNames: (keyof TActions)[];\n  /** Function names */\n  readonly functionNames: (keyof TFunctions)[];\n  /** Validation mode */\n  readonly validation: ValidationMode;\n  /** Component definitions */\n  readonly components: TComponents;\n  /** Action definitions */\n  readonly actions: TActions;\n  /** Custom validation functions */\n  readonly functions: TFunctions;\n  /** Full element schema for AI generation */\n  readonly elementSchema: z.ZodType<UIElement>;\n  /** Full UI spec schema */\n  readonly specSchema: z.ZodType<Spec>;\n  /** Check if component exists */\n  hasComponent(type: string): boolean;\n  /** Check if action exists */\n  hasAction(name: string): boolean;\n  /** Check if function exists */\n  hasFunction(name: string): boolean;\n  /** Validate an element */\n  validateElement(element: unknown): {\n    success: boolean;\n    data?: UIElement;\n    error?: z.ZodError;\n  };\n  /** Validate a UI spec */\n  validateSpec(spec: unknown): {\n    success: boolean;\n    data?: Spec;\n    error?: z.ZodError;\n  };\n}\n\n/**\n * Create a v2 catalog with visibility, actions, and validation support\n */\nexport function createCatalog<\n  TComponents extends Record<string, ComponentDefinition>,\n  TActions extends Record<string, ActionDefinition> = Record<\n    string,\n    ActionDefinition\n  >,\n  TFunctions extends Record<string, ValidationFunction> = Record<\n    string,\n    ValidationFunction\n  >,\n>(\n  config: CatalogConfig<TComponents, TActions, TFunctions>,\n): Catalog<TComponents, TActions, TFunctions> {\n  const {\n    name = \"unnamed\",\n    components,\n    actions = {} as TActions,\n    functions = {} as TFunctions,\n    validation = \"strict\",\n  } = config;\n\n  const componentNames = Object.keys(components) as (keyof TComponents)[];\n  const actionNames = Object.keys(actions) as (keyof TActions)[];\n  const functionNames = Object.keys(functions) as (keyof TFunctions)[];\n\n  // Create element schema for each component type\n  const componentSchemas = componentNames.map((componentName) => {\n    const def = components[componentName]!;\n\n    return z.object({\n      type: z.literal(componentName as string),\n      props: def.props,\n      children: z.array(z.string()).optional(),\n      visible: VisibilityConditionSchema.optional(),\n    });\n  });\n\n  // Create union schema for all components\n  let elementSchema: z.ZodType<UIElement>;\n\n  if (componentSchemas.length === 0) {\n    elementSchema = z.object({\n      type: z.string(),\n      props: z.record(z.string(), z.unknown()),\n      children: z.array(z.string()).optional(),\n      visible: VisibilityConditionSchema.optional(),\n    }) as unknown as z.ZodType<UIElement>;\n  } else if (componentSchemas.length === 1) {\n    elementSchema = componentSchemas[0] as unknown as z.ZodType<UIElement>;\n  } else {\n    elementSchema = z.discriminatedUnion(\"type\", [\n      componentSchemas[0] as z.ZodObject<any>,\n      componentSchemas[1] as z.ZodObject<any>,\n      ...(componentSchemas.slice(2) as z.ZodObject<any>[]),\n    ]) as unknown as z.ZodType<UIElement>;\n  }\n\n  // Create spec schema\n  const specSchema = z.object({\n    root: z.string(),\n    elements: z.record(z.string(), elementSchema),\n  }) as unknown as z.ZodType<Spec>;\n\n  return {\n    name,\n    componentNames,\n    actionNames,\n    functionNames,\n    validation,\n    components,\n    actions,\n    functions,\n    elementSchema,\n    specSchema,\n\n    hasComponent(type: string) {\n      return type in components;\n    },\n\n    hasAction(name: string) {\n      return name in actions;\n    },\n\n    hasFunction(name: string) {\n      return name in functions;\n    },\n\n    validateElement(element: unknown) {\n      const result = elementSchema.safeParse(element);\n      if (result.success) {\n        return { success: true, data: result.data };\n      }\n      return { success: false, error: result.error };\n    },\n\n    validateSpec(spec: unknown) {\n      const result = specSchema.safeParse(spec);\n      if (result.success) {\n        return { success: true, data: result.data };\n      }\n      return { success: false, error: result.error };\n    },\n  };\n}\n\n/**\n * Generate a prompt for AI that describes the catalog\n */\nexport function generateCatalogPrompt<\n  TComponents extends Record<string, ComponentDefinition>,\n  TActions extends Record<string, ActionDefinition>,\n  TFunctions extends Record<string, ValidationFunction>,\n>(catalog: Catalog<TComponents, TActions, TFunctions>): string {\n  const lines: string[] = [\n    `# ${catalog.name} Component Catalog`,\n    \"\",\n    \"## Available Components\",\n    \"\",\n  ];\n\n  // Components\n  for (const name of catalog.componentNames) {\n    const def = catalog.components[name]!;\n    lines.push(`### ${String(name)}`);\n    if (def.description) {\n      lines.push(def.description);\n    }\n    lines.push(\"\");\n  }\n\n  // Actions\n  if (catalog.actionNames.length > 0) {\n    lines.push(\"## Available Actions\");\n    lines.push(\"\");\n    for (const name of catalog.actionNames) {\n      const def = catalog.actions[name]!;\n      lines.push(\n        `- \\`${String(name)}\\`${def.description ? `: ${def.description}` : \"\"}`,\n      );\n    }\n    lines.push(\"\");\n  }\n\n  // Visibility\n  lines.push(\"## Visibility Conditions\");\n  lines.push(\"\");\n  lines.push(\"Components can have a `visible` property:\");\n  lines.push(\"- `true` / `false` - Always visible/hidden\");\n  lines.push('- `{ \"path\": \"/state/path\" }` - Visible when path is truthy');\n  lines.push('- `{ \"auth\": \"signedIn\" }` - Visible when user is signed in');\n  lines.push('- `{ \"and\": [...] }` - All conditions must be true');\n  lines.push('- `{ \"or\": [...] }` - Any condition must be true');\n  lines.push('- `{ \"not\": {...} }` - Negates a condition');\n  lines.push('- `{ \"eq\": [a, b] }` - Equality check');\n  lines.push(\"\");\n\n  // Validation\n  lines.push(\"## Validation Functions\");\n  lines.push(\"\");\n  lines.push(\n    \"Built-in: `required`, `email`, `minLength`, `maxLength`, `pattern`, `min`, `max`, `url`\",\n  );\n  if (catalog.functionNames.length > 0) {\n    lines.push(`Custom: ${catalog.functionNames.map(String).join(\", \")}`);\n  }\n  lines.push(\"\");\n\n  return lines.join(\"\\n\");\n}\n\n/**\n * Type helper to infer component props from catalog\n */\nexport type InferCatalogComponentProps<\n  C extends Catalog<Record<string, ComponentDefinition>>,\n> = {\n  [K in keyof C[\"components\"]]: z.infer<C[\"components\"][K][\"props\"]>;\n};\n\n/**\n * Internal Zod definition type for introspection\n */\ninterface ZodDefInternal {\n  typeName?: string;\n  value?: unknown;\n  values?: unknown;\n  type?: z.ZodTypeAny;\n  shape?: () => Record<string, z.ZodTypeAny>;\n  innerType?: z.ZodTypeAny;\n  options?: z.ZodTypeAny[];\n}\n\n/**\n * Format a Zod type into a human-readable string for prompts\n */\nfunction formatZodType(schema: z.ZodTypeAny, isOptional = false): string {\n  const def = schema._def as unknown as ZodDefInternal;\n  const typeName = def.typeName ?? \"\";\n\n  let result: string;\n\n  switch (typeName) {\n    case \"ZodString\":\n      result = \"string\";\n      break;\n    case \"ZodNumber\":\n      result = \"number\";\n      break;\n    case \"ZodBoolean\":\n      result = \"boolean\";\n      break;\n    case \"ZodLiteral\":\n      result = JSON.stringify(def.value);\n      break;\n    case \"ZodEnum\":\n      result = (def.values as string[]).map((v) => `\"${v}\"`).join(\"|\");\n      break;\n    case \"ZodNativeEnum\":\n      result = Object.values(def.values as Record<string, string>)\n        .map((v) => `\"${v}\"`)\n        .join(\"|\");\n      break;\n    case \"ZodArray\":\n      result = def.type\n        ? `Array<${formatZodType(def.type)}>`\n        : \"Array<unknown>\";\n      break;\n    case \"ZodObject\": {\n      if (!def.shape) {\n        result = \"object\";\n        break;\n      }\n      const shape = def.shape();\n      const props = Object.entries(shape)\n        .map(([key, value]) => {\n          const innerDef = value._def as unknown as ZodDefInternal;\n          const innerOptional =\n            innerDef.typeName === \"ZodOptional\" ||\n            innerDef.typeName === \"ZodNullable\";\n          return `${key}${innerOptional ? \"?\" : \"\"}: ${formatZodType(value)}`;\n        })\n        .join(\", \");\n      result = `{ ${props} }`;\n      break;\n    }\n    case \"ZodOptional\":\n      return def.innerType ? formatZodType(def.innerType, true) : \"unknown?\";\n    case \"ZodNullable\":\n      return def.innerType ? formatZodType(def.innerType, true) : \"unknown?\";\n    case \"ZodDefault\":\n      return def.innerType\n        ? formatZodType(def.innerType, isOptional)\n        : \"unknown\";\n    case \"ZodUnion\":\n      result = def.options\n        ? def.options.map((opt) => formatZodType(opt)).join(\"|\")\n        : \"unknown\";\n      break;\n    case \"ZodNull\":\n      result = \"null\";\n      break;\n    case \"ZodUndefined\":\n      result = \"undefined\";\n      break;\n    case \"ZodAny\":\n      result = \"any\";\n      break;\n    case \"ZodUnknown\":\n      result = \"unknown\";\n      break;\n    default:\n      result = \"unknown\";\n  }\n\n  return isOptional ? `${result}?` : result;\n}\n\n/**\n * Extract props from a Zod object schema as formatted entries\n */\nfunction extractPropsFromSchema(\n  schema: z.ZodTypeAny,\n): Array<{ name: string; type: string; optional: boolean }> {\n  const def = schema._def as unknown as ZodDefInternal;\n  const typeName = def.typeName ?? \"\";\n\n  if (typeName !== \"ZodObject\" || !def.shape) {\n    return [];\n  }\n\n  const shape = def.shape();\n  return Object.entries(shape).map(([name, value]) => {\n    const innerDef = value._def as unknown as ZodDefInternal;\n    const optional =\n      innerDef.typeName === \"ZodOptional\" ||\n      innerDef.typeName === \"ZodNullable\";\n    return {\n      name,\n      type: formatZodType(value),\n      optional,\n    };\n  });\n}\n\n/**\n * Format component props as a compact object notation\n */\nfunction formatPropsCompact(\n  props: Array<{ name: string; type: string; optional: boolean }>,\n): string {\n  if (props.length === 0) return \"{}\";\n  const entries = props.map(\n    (p) => `${p.name}${p.optional ? \"?\" : \"\"}: ${p.type}`,\n  );\n  return `{ ${entries.join(\", \")} }`;\n}\n\n/**\n * Options for generating system prompts\n */\nexport interface SystemPromptOptions {\n  /** System message intro (replaces default) */\n  system?: string;\n  /** Additional rules to append to the rules section */\n  customRules?: string[];\n}\n\n/**\n * Generate a complete system prompt for AI that can generate UI from a catalog.\n * This produces a ready-to-use prompt that stays in sync with the catalog definition.\n */\nexport function generateSystemPrompt<\n  TComponents extends Record<string, ComponentDefinition>,\n  TActions extends Record<string, ActionDefinition>,\n  TFunctions extends Record<string, ValidationFunction>,\n>(\n  catalog: Catalog<TComponents, TActions, TFunctions>,\n  options: SystemPromptOptions = {},\n): string {\n  const {\n    system = \"You are a UI generator that outputs JSONL (JSON Lines) patches.\",\n    customRules = [],\n  } = options;\n\n  const lines: string[] = [];\n\n  // System intro\n  lines.push(system);\n  lines.push(\"\");\n\n  // Components section\n  const componentCount = catalog.componentNames.length;\n  lines.push(`AVAILABLE COMPONENTS (${componentCount}):`);\n  lines.push(\"\");\n\n  for (const name of catalog.componentNames) {\n    const def = catalog.components[name]!;\n    const props = extractPropsFromSchema(def.props);\n    const propsStr = formatPropsCompact(props);\n    const hasChildrenStr = def.hasChildren ? \" Has children.\" : \"\";\n    const descStr = def.description ? ` ${def.description}` : \"\";\n\n    lines.push(`- ${String(name)}: ${propsStr}${descStr}${hasChildrenStr}`);\n  }\n  lines.push(\"\");\n\n  // Actions section\n  if (catalog.actionNames.length > 0) {\n    lines.push(\"AVAILABLE ACTIONS:\");\n    lines.push(\"\");\n    for (const name of catalog.actionNames) {\n      const def = catalog.actions[name]!;\n      lines.push(\n        `- ${String(name)}${def.description ? `: ${def.description}` : \"\"}`,\n      );\n    }\n    lines.push(\"\");\n  }\n\n  // Output format\n  lines.push(\"OUTPUT FORMAT (JSONL, RFC 6902 JSON Patch):\");\n  lines.push('{\"op\":\"add\",\"path\":\"/root\",\"value\":\"element-key\"}');\n  lines.push(\n    '{\"op\":\"add\",\"path\":\"/elements/key\",\"value\":{\"type\":\"...\",\"props\":{...},\"children\":[...]}}',\n  );\n  lines.push('{\"op\":\"remove\",\"path\":\"/elements/key\"}');\n  lines.push(\"\");\n\n  // Rules\n  lines.push(\"RULES:\");\n  const baseRules = [\n    'First line sets /root to root element key: {\"op\":\"add\",\"path\":\"/root\",\"value\":\"<key>\"}',\n    'Add elements with /elements/{key}: {\"op\":\"add\",\"path\":\"/elements/<key>\",\"value\":{...}}',\n    \"Remove elements with op:remove - also update the parent's children array to exclude the removed key\",\n    \"Children array contains string keys, not objects\",\n    \"Parent first, then children\",\n    \"Each element needs: type, props\",\n    \"ONLY use props listed above - never invent new props\",\n  ];\n  const allRules = [...baseRules, ...customRules];\n  allRules.forEach((rule, i) => {\n    lines.push(`${i + 1}. ${rule}`);\n  });\n  lines.push(\"\");\n\n  // Custom validation functions (only if catalog has them)\n  if (catalog.functionNames.length > 0) {\n    lines.push(\"CUSTOM VALIDATION FUNCTIONS:\");\n    lines.push(catalog.functionNames.map(String).join(\", \"));\n    lines.push(\"\");\n  }\n\n  // End with prompt\n  lines.push(\"Generate JSONL:\");\n\n  return lines.join(\"\\n\");\n}\n"],"names":["z","z","z","z","action","executeAction","z","z","check","z","parts","z","z","name","formatZodType"],"mappings":"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"}},
    {"offset": {"line": 2225, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Breact%400.5.2_react%4019.2.3_zod%404.3.6/node_modules/%40json-render/react/src/schema.ts"],"sourcesContent":["import { defineSchema } from \"@json-render/core\";\n\n/**\n * The schema for @json-render/react\n *\n * Defines:\n * - Spec: A flat tree of elements with keys, types, props, and children references\n * - Catalog: Components with props schemas, and optional actions\n */\nexport const schema = defineSchema(\n  (s) => ({\n    // What the AI-generated SPEC looks like\n    spec: s.object({\n      /** Root element key */\n      root: s.string(),\n      /** Flat map of elements by key */\n      elements: s.record(\n        s.object({\n          /** Component type from catalog */\n          type: s.ref(\"catalog.components\"),\n          /** Component props */\n          props: s.propsOf(\"catalog.components\"),\n          /** Child element keys (flat reference) */\n          children: s.array(s.string()),\n          /** Visibility condition */\n          visible: s.any(),\n        }),\n      ),\n    }),\n\n    // What the CATALOG must provide\n    catalog: s.object({\n      /** Component definitions */\n      components: s.map({\n        /** Zod schema for component props */\n        props: s.zod(),\n        /** Slots for this component. Use ['default'] for children, or named slots like ['header', 'footer'] */\n        slots: s.array(s.string()),\n        /** Description for AI generation hints */\n        description: s.string(),\n        /** Example prop values used in prompt examples (auto-generated from Zod schema if omitted) */\n        example: s.any(),\n      }),\n      /** Action definitions (optional) */\n      actions: s.map({\n        /** Zod schema for action params */\n        params: s.zod(),\n        /** Description for AI generation hints */\n        description: s.string(),\n      }),\n    }),\n  }),\n  {\n    defaultRules: [\n      // Element integrity\n      \"CRITICAL INTEGRITY CHECK: Before outputting ANY element that references children, you MUST have already output (or will output) each child as its own element. If an element has children: ['a', 'b'], then elements 'a' and 'b' MUST exist. A missing child element causes that entire branch of the UI to be invisible.\",\n      \"SELF-CHECK: After generating all elements, mentally walk the tree from root. Every key in every children array must resolve to a defined element. If you find a gap, output the missing element immediately.\",\n\n      // Field placement\n      'CRITICAL: The \"visible\" field goes on the ELEMENT object, NOT inside \"props\". Correct: {\"type\":\"<ComponentName>\",\"props\":{},\"visible\":{\"eq\":[{\"path\":\"/tab\"},\"home\"]},\"children\":[...]}.',\n      'CRITICAL: The \"on\" field goes on the ELEMENT object, NOT inside \"props\". Use on.press, on.change, on.submit etc. NEVER put action/actionParams inside props.',\n\n      // State and data\n      \"When the user asks for a UI that displays data (e.g. blog posts, products, users), ALWAYS include a state field with realistic sample data. The state field is a top-level field on the spec (sibling of root/elements).\",\n      'When building repeating content backed by a state array (e.g. posts, products, items), use the \"repeat\" field on a container element. Example: { \"type\": \"<ContainerComponent>\", \"props\": {}, \"repeat\": { \"path\": \"/posts\", \"key\": \"id\" }, \"children\": [\"post-card\"] }. Replace <ContainerComponent> with an appropriate component from the AVAILABLE COMPONENTS list. Inside repeated children, use \"$item/field\" for per-item state paths and \"$index\" for the current array index. Do NOT hardcode individual elements for each array item.',\n\n      // Design quality\n      \"Design with visual hierarchy: use container components to group content, heading components for section titles, proper spacing, and status indicators. ONLY use components from the AVAILABLE COMPONENTS list.\",\n      \"For data-rich UIs, use multi-column layout components if available. For forms and single-column content, use vertical layout components. ONLY use components from the AVAILABLE COMPONENTS list.\",\n      \"Always include realistic, professional-looking sample data. For blogs include 3-4 posts with varied titles, authors, dates, categories. For products include names, prices, images. Never leave data empty.\",\n    ],\n  },\n);\n\n/**\n * Type for the React schema\n */\nexport type ReactSchema = typeof schema;\n\n/**\n * Infer the spec type from a catalog\n */\nexport type ReactSpec<TCatalog> = typeof schema extends {\n  createCatalog: (catalog: TCatalog) => { _specType: infer S };\n}\n  ? S\n  : never;\n\n// Backward compatibility aliases\n/** @deprecated Use `schema` instead */\nexport const elementTreeSchema = schema;\n/** @deprecated Use `ReactSchema` instead */\nexport type ElementTreeSchema = ReactSchema;\n/** @deprecated Use `ReactSpec` instead */\nexport type ElementTreeSpec<T> = ReactSpec<T>;\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,oBAAoB;;AAStB,IAAM,aAAS,kQAAA,EACpB,CAAC,IAAA,CAAO;QAAA,wCAAA;QAEN,MAAM,EAAE,MAAA,CAAO;YAAA,qBAAA,GAEb,MAAM,EAAE,MAAA,CAAO;YAAA,gCAAA,GAEf,UAAU,EAAE,MAAA,CACV,EAAE,MAAA,CAAO;gBAAA,gCAAA,GAEP,MAAM,EAAE,GAAA,CAAI,oBAAoB;gBAAA,oBAAA,GAEhC,OAAO,EAAE,OAAA,CAAQ,oBAAoB;gBAAA,wCAAA,GAErC,UAAU,EAAE,KAAA,CAAM,EAAE,MAAA,CAAO,CAAC;gBAAA,yBAAA,GAE5B,SAAS,EAAE,GAAA,CAAI;YACjB,CAAC;QAEL,CAAC;QAAA,gCAAA;QAGD,SAAS,EAAE,MAAA,CAAO;YAAA,0BAAA,GAEhB,YAAY,EAAE,GAAA,CAAI;gBAAA,mCAAA,GAEhB,OAAO,EAAE,GAAA,CAAI;gBAAA,qGAAA,GAEb,OAAO,EAAE,KAAA,CAAM,EAAE,MAAA,CAAO,CAAC;gBAAA,wCAAA,GAEzB,aAAa,EAAE,MAAA,CAAO;gBAAA,4FAAA,GAEtB,SAAS,EAAE,GAAA,CAAI;YACjB,CAAC;YAAA,kCAAA,GAED,SAAS,EAAE,GAAA,CAAI;gBAAA,iCAAA,GAEb,QAAQ,EAAE,GAAA,CAAI;gBAAA,wCAAA,GAEd,aAAa,EAAE,MAAA,CAAO;YACxB,CAAC;QACH,CAAC;IACH,CAAA,GACA;IACE,cAAc;QAAA,oBAAA;QAEZ;QACA;QAAA,kBAAA;QAGA;QACA;QAAA,iBAAA;QAGA;QACA;QAAA,iBAAA;QAGA;QACA;QACA;KACF;AACF;AAmBK,IAAM,oBAAoB"}},
    {"offset": {"line": 2282, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Breact%400.5.2_react%4019.2.3_zod%404.3.6/node_modules/%40json-render/react/src/contexts/state.tsx","file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Breact%400.5.2_react%4019.2.3_zod%404.3.6/node_modules/%40json-render/react/src/contexts/visibility.tsx","file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Breact%400.5.2_react%4019.2.3_zod%404.3.6/node_modules/%40json-render/react/src/contexts/actions.tsx","file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Breact%400.5.2_react%4019.2.3_zod%404.3.6/node_modules/%40json-render/react/src/contexts/validation.tsx","file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Breact%400.5.2_react%4019.2.3_zod%404.3.6/node_modules/%40json-render/react/src/contexts/repeat-scope.tsx","file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Breact%400.5.2_react%4019.2.3_zod%404.3.6/node_modules/%40json-render/react/src/renderer.tsx","file:///Users/jamesspalding/OpenClaw-OS/node_modules/.pnpm/%40json-render%2Breact%400.5.2_react%4019.2.3_zod%404.3.6/node_modules/%40json-render/react/src/hooks.ts"],"sourcesContent":["\"use client\";\n\nimport React, {\n  createContext,\n  useContext,\n  useState,\n  useCallback,\n  useMemo,\n  useEffect,\n  useRef,\n  type ReactNode,\n} from \"react\";\nimport {\n  getByPath,\n  setByPath,\n  type StateModel,\n  type AuthState,\n} from \"@json-render/core\";\n\n/**\n * State context value\n */\nexport interface StateContextValue {\n  /** The current state model */\n  state: StateModel;\n  /** Auth state for visibility evaluation */\n  authState?: AuthState;\n  /** Get a value by path */\n  get: (path: string) => unknown;\n  /** Set a value by path */\n  set: (path: string, value: unknown) => void;\n  /** Update multiple values at once */\n  update: (updates: Record<string, unknown>) => void;\n}\n\nconst StateContext = createContext<StateContextValue | null>(null);\n\n/**\n * Props for StateProvider\n */\nexport interface StateProviderProps {\n  /** Initial state model */\n  initialState?: StateModel;\n  /** Auth state */\n  authState?: AuthState;\n  /** Callback when state changes */\n  onStateChange?: (path: string, value: unknown) => void;\n  children: ReactNode;\n}\n\n/**\n * Provider for state model context\n */\nexport function StateProvider({\n  initialState = {},\n  authState,\n  onStateChange,\n  children,\n}: StateProviderProps) {\n  const [state, setStateInternal] = useState<StateModel>(initialState);\n\n  // Track the serialized initialState to detect actual value changes (not just reference changes)\n  const initialStateJsonRef = useRef<string>(JSON.stringify(initialState));\n\n  // Sync external state changes with internal state - only when values actually change\n  useEffect(() => {\n    const newJson = JSON.stringify(initialState);\n    if (newJson !== initialStateJsonRef.current) {\n      initialStateJsonRef.current = newJson;\n      if (initialState && Object.keys(initialState).length > 0) {\n        setStateInternal((prev) => ({ ...prev, ...initialState }));\n      }\n    }\n  }, [initialState]);\n\n  const get = useCallback((path: string) => getByPath(state, path), [state]);\n\n  const set = useCallback(\n    (path: string, value: unknown) => {\n      setStateInternal((prev) => {\n        const next = { ...prev };\n        setByPath(next, path, value);\n        return next;\n      });\n      onStateChange?.(path, value);\n    },\n    [onStateChange],\n  );\n\n  const update = useCallback(\n    (updates: Record<string, unknown>) => {\n      setStateInternal((prev) => {\n        const next = { ...prev };\n        for (const [path, value] of Object.entries(updates)) {\n          setByPath(next, path, value);\n          onStateChange?.(path, value);\n        }\n        return next;\n      });\n    },\n    [onStateChange],\n  );\n\n  const value = useMemo<StateContextValue>(\n    () => ({\n      state,\n      authState,\n      get,\n      set,\n      update,\n    }),\n    [state, authState, get, set, update],\n  );\n\n  return (\n    <StateContext.Provider value={value}>{children}</StateContext.Provider>\n  );\n}\n\n/**\n * Hook to access the state context\n */\nexport function useStateStore(): StateContextValue {\n  const ctx = useContext(StateContext);\n  if (!ctx) {\n    throw new Error(\"useStateStore must be used within a StateProvider\");\n  }\n  return ctx;\n}\n\n/**\n * Hook to get a value from the state model\n */\nexport function useStateValue<T>(path: string): T | undefined {\n  const { state } = useStateStore();\n  return getByPath(state, path) as T | undefined;\n}\n\n/**\n * Hook to get and set a value from the state model (like useState)\n */\nexport function useStateBinding<T>(\n  path: string,\n): [T | undefined, (value: T) => void] {\n  const { state, set } = useStateStore();\n  const value = getByPath(state, path) as T | undefined;\n  const setValue = useCallback(\n    (newValue: T) => set(path, newValue),\n    [path, set],\n  );\n  return [value, setValue];\n}\n","\"use client\";\n\nimport React, {\n  createContext,\n  useContext,\n  useMemo,\n  type ReactNode,\n} from \"react\";\nimport {\n  evaluateVisibility,\n  type VisibilityCondition,\n  type VisibilityContext as CoreVisibilityContext,\n} from \"@json-render/core\";\nimport { useStateStore } from \"./state\";\n\n/**\n * Visibility context value\n */\nexport interface VisibilityContextValue {\n  /** Evaluate a visibility condition */\n  isVisible: (condition: VisibilityCondition | undefined) => boolean;\n  /** The underlying visibility context */\n  ctx: CoreVisibilityContext;\n}\n\nconst VisibilityContext = createContext<VisibilityContextValue | null>(null);\n\n/**\n * Props for VisibilityProvider\n */\nexport interface VisibilityProviderProps {\n  children: ReactNode;\n}\n\n/**\n * Provider for visibility evaluation\n */\nexport function VisibilityProvider({ children }: VisibilityProviderProps) {\n  const { state, authState } = useStateStore();\n\n  const ctx: CoreVisibilityContext = useMemo(\n    () => ({\n      stateModel: state,\n      authState,\n    }),\n    [state, authState],\n  );\n\n  const isVisible = useMemo(\n    () => (condition: VisibilityCondition | undefined) =>\n      evaluateVisibility(condition, ctx),\n    [ctx],\n  );\n\n  const value = useMemo<VisibilityContextValue>(\n    () => ({ isVisible, ctx }),\n    [isVisible, ctx],\n  );\n\n  return (\n    <VisibilityContext.Provider value={value}>\n      {children}\n    </VisibilityContext.Provider>\n  );\n}\n\n/**\n * Hook to access visibility evaluation\n */\nexport function useVisibility(): VisibilityContextValue {\n  const ctx = useContext(VisibilityContext);\n  if (!ctx) {\n    throw new Error(\"useVisibility must be used within a VisibilityProvider\");\n  }\n  return ctx;\n}\n\n/**\n * Hook to check if a condition is visible\n */\nexport function useIsVisible(\n  condition: VisibilityCondition | undefined,\n): boolean {\n  const { isVisible } = useVisibility();\n  return isVisible(condition);\n}\n","\"use client\";\n\nimport React, {\n  createContext,\n  useContext,\n  useState,\n  useCallback,\n  useMemo,\n  type ReactNode,\n} from \"react\";\nimport {\n  resolveAction,\n  executeAction,\n  type ActionBinding,\n  type ActionHandler,\n  type ActionConfirm,\n  type ResolvedAction,\n} from \"@json-render/core\";\nimport { useStateStore } from \"./state\";\n\n/**\n * Generate a unique ID for use with the \"$id\" token.\n * Combines a timestamp with a random suffix for uniqueness.\n */\nlet idCounter = 0;\nfunction generateUniqueId(): string {\n  idCounter += 1;\n  return `${Date.now()}-${idCounter}`;\n}\n\n/**\n * Deep-resolve dynamic value references within an object.\n *\n * Supported tokens:\n * - `{ path: \"/statePath\" }` - read a value from state\n * - `\"$id\"` (string) or `{ \"$id\": true }` - generate a unique ID\n *\n * This allows pushState values to contain references to current state\n * and auto-generated IDs.\n */\nfunction deepResolveValue(\n  value: unknown,\n  get: (path: string) => unknown,\n): unknown {\n  if (value === null || value === undefined) return value;\n\n  // \"$id\" string token -> generate unique ID\n  if (value === \"$id\") {\n    return generateUniqueId();\n  }\n\n  if (typeof value === \"object\" && !Array.isArray(value)) {\n    const obj = value as Record<string, unknown>;\n    const keys = Object.keys(obj);\n\n    // { path: \"/foo\" } -> read from state (single-key object with \"path\")\n    if (keys.length === 1 && typeof obj.path === \"string\") {\n      return get(obj.path as string);\n    }\n\n    // { \"$id\": true } -> generate unique ID (single-key object)\n    if (keys.length === 1 && \"$id\" in obj) {\n      return generateUniqueId();\n    }\n  }\n\n  // Recurse into arrays\n  if (Array.isArray(value)) {\n    return value.map((item) => deepResolveValue(item, get));\n  }\n\n  // Recurse into plain objects\n  if (typeof value === \"object\") {\n    const resolved: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value as Record<string, unknown>)) {\n      resolved[key] = deepResolveValue(val, get);\n    }\n    return resolved;\n  }\n\n  return value;\n}\n\n/**\n * Pending confirmation state\n */\nexport interface PendingConfirmation {\n  /** The resolved action */\n  action: ResolvedAction;\n  /** The action handler */\n  handler: ActionHandler;\n  /** Resolve callback */\n  resolve: () => void;\n  /** Reject callback */\n  reject: () => void;\n}\n\n/**\n * Action context value\n */\nexport interface ActionContextValue {\n  /** Registered action handlers */\n  handlers: Record<string, ActionHandler>;\n  /** Currently loading action names */\n  loadingActions: Set<string>;\n  /** Pending confirmation dialog */\n  pendingConfirmation: PendingConfirmation | null;\n  /** Execute an action binding */\n  execute: (binding: ActionBinding) => Promise<void>;\n  /** Confirm the pending action */\n  confirm: () => void;\n  /** Cancel the pending action */\n  cancel: () => void;\n  /** Register an action handler */\n  registerHandler: (name: string, handler: ActionHandler) => void;\n}\n\nconst ActionContext = createContext<ActionContextValue | null>(null);\n\n/**\n * Props for ActionProvider\n */\nexport interface ActionProviderProps {\n  /** Initial action handlers */\n  handlers?: Record<string, ActionHandler>;\n  /** Navigation function */\n  navigate?: (path: string) => void;\n  children: ReactNode;\n}\n\n/**\n * Provider for action execution\n */\nexport function ActionProvider({\n  handlers: initialHandlers = {},\n  navigate,\n  children,\n}: ActionProviderProps) {\n  const { state, get, set } = useStateStore();\n  const [handlers, setHandlers] =\n    useState<Record<string, ActionHandler>>(initialHandlers);\n  const [loadingActions, setLoadingActions] = useState<Set<string>>(new Set());\n  const [pendingConfirmation, setPendingConfirmation] =\n    useState<PendingConfirmation | null>(null);\n\n  const registerHandler = useCallback(\n    (name: string, handler: ActionHandler) => {\n      setHandlers((prev) => ({ ...prev, [name]: handler }));\n    },\n    [],\n  );\n\n  const execute = useCallback(\n    async (binding: ActionBinding) => {\n      const resolved = resolveAction(binding, state);\n\n      // Built-in: setState updates the StateProvider state directly\n      if (resolved.action === \"setState\" && resolved.params) {\n        const path = resolved.params.path as string;\n        const value = resolved.params.value;\n        if (path) {\n          set(path, value);\n        }\n        return;\n      }\n\n      // Built-in: pushState appends an item to an array in state.\n      // Supports dynamic values inside the value object via { path: \"/...\" } syntax.\n      if (resolved.action === \"pushState\" && resolved.params) {\n        const path = resolved.params.path as string;\n        const rawValue = resolved.params.value;\n        if (path) {\n          const resolvedValue = deepResolveValue(rawValue, get);\n          const arr = (get(path) as unknown[] | undefined) ?? [];\n          set(path, [...arr, resolvedValue]);\n          // Optionally clear a path after pushing (e.g. clear the input)\n          const clearPath = resolved.params.clearPath as string | undefined;\n          if (clearPath) {\n            set(clearPath, \"\");\n          }\n        }\n        return;\n      }\n\n      // Built-in: removeState removes an item from an array in state by index.\n      if (resolved.action === \"removeState\" && resolved.params) {\n        const path = resolved.params.path as string;\n        const index = resolved.params.index as number;\n        if (path !== undefined && index !== undefined) {\n          const arr = (get(path) as unknown[] | undefined) ?? [];\n          set(\n            path,\n            arr.filter((_, i) => i !== index),\n          );\n        }\n        return;\n      }\n\n      // Built-in: push navigates to a new screen by updating state.\n      // Pushes the current screen onto /navStack and sets /currentScreen.\n      if (resolved.action === \"push\" && resolved.params) {\n        const screen = resolved.params.screen as string;\n        if (screen) {\n          const currentScreen = get(\"/currentScreen\") as string | undefined;\n          const navStack = (get(\"/navStack\") as string[] | undefined) ?? [];\n          if (currentScreen) {\n            set(\"/navStack\", [...navStack, currentScreen]);\n          } else {\n            // No current screen set yet -- push a sentinel so pop returns here\n            set(\"/navStack\", [...navStack, \"\"]);\n          }\n          set(\"/currentScreen\", screen);\n        }\n        return;\n      }\n\n      // Built-in: pop navigates back to the previous screen.\n      // Pops the last entry from /navStack and restores /currentScreen.\n      if (resolved.action === \"pop\") {\n        const navStack = (get(\"/navStack\") as string[] | undefined) ?? [];\n        if (navStack.length > 0) {\n          const previousScreen = navStack[navStack.length - 1];\n          set(\"/navStack\", navStack.slice(0, -1));\n          if (previousScreen) {\n            set(\"/currentScreen\", previousScreen);\n          } else {\n            // Sentinel empty string = clear currentScreen (return to default)\n            set(\"/currentScreen\", undefined);\n          }\n        }\n        return;\n      }\n\n      const handler = handlers[resolved.action];\n\n      if (!handler) {\n        console.warn(`No handler registered for action: ${resolved.action}`);\n        return;\n      }\n\n      // If confirmation is required, show dialog\n      if (resolved.confirm) {\n        return new Promise<void>((resolve, reject) => {\n          setPendingConfirmation({\n            action: resolved,\n            handler,\n            resolve: () => {\n              setPendingConfirmation(null);\n              resolve();\n            },\n            reject: () => {\n              setPendingConfirmation(null);\n              reject(new Error(\"Action cancelled\"));\n            },\n          });\n        }).then(async () => {\n          setLoadingActions((prev) => new Set(prev).add(resolved.action));\n          try {\n            await executeAction({\n              action: resolved,\n              handler,\n              setState: set,\n              navigate,\n              executeAction: async (name) => {\n                const subBinding: ActionBinding = { action: name };\n                await execute(subBinding);\n              },\n            });\n          } finally {\n            setLoadingActions((prev) => {\n              const next = new Set(prev);\n              next.delete(resolved.action);\n              return next;\n            });\n          }\n        });\n      }\n\n      // Execute immediately\n      setLoadingActions((prev) => new Set(prev).add(resolved.action));\n      try {\n        await executeAction({\n          action: resolved,\n          handler,\n          setState: set,\n          navigate,\n          executeAction: async (name) => {\n            const subBinding: ActionBinding = { action: name };\n            await execute(subBinding);\n          },\n        });\n      } finally {\n        setLoadingActions((prev) => {\n          const next = new Set(prev);\n          next.delete(resolved.action);\n          return next;\n        });\n      }\n    },\n    [state, handlers, get, set, navigate],\n  );\n\n  const confirm = useCallback(() => {\n    pendingConfirmation?.resolve();\n  }, [pendingConfirmation]);\n\n  const cancel = useCallback(() => {\n    pendingConfirmation?.reject();\n  }, [pendingConfirmation]);\n\n  const value = useMemo<ActionContextValue>(\n    () => ({\n      handlers,\n      loadingActions,\n      pendingConfirmation,\n      execute,\n      confirm,\n      cancel,\n      registerHandler,\n    }),\n    [\n      handlers,\n      loadingActions,\n      pendingConfirmation,\n      execute,\n      confirm,\n      cancel,\n      registerHandler,\n    ],\n  );\n\n  return (\n    <ActionContext.Provider value={value}>{children}</ActionContext.Provider>\n  );\n}\n\n/**\n * Hook to access action context\n */\nexport function useActions(): ActionContextValue {\n  const ctx = useContext(ActionContext);\n  if (!ctx) {\n    throw new Error(\"useActions must be used within an ActionProvider\");\n  }\n  return ctx;\n}\n\n/**\n * Hook to execute an action binding\n */\nexport function useAction(binding: ActionBinding): {\n  execute: () => Promise<void>;\n  isLoading: boolean;\n} {\n  const { execute, loadingActions } = useActions();\n  const isLoading = loadingActions.has(binding.action);\n\n  const executeAction = useCallback(() => execute(binding), [execute, binding]);\n\n  return { execute: executeAction, isLoading };\n}\n\n/**\n * Props for ConfirmDialog component\n */\nexport interface ConfirmDialogProps {\n  /** The confirmation config */\n  confirm: ActionConfirm;\n  /** Called when confirmed */\n  onConfirm: () => void;\n  /** Called when cancelled */\n  onCancel: () => void;\n}\n\n/**\n * Default confirmation dialog component\n */\nexport function ConfirmDialog({\n  confirm,\n  onConfirm,\n  onCancel,\n}: ConfirmDialogProps) {\n  const isDanger = confirm.variant === \"danger\";\n\n  return (\n    <div\n      style={{\n        position: \"fixed\",\n        inset: 0,\n        backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        zIndex: 50,\n      }}\n      onClick={onCancel}\n    >\n      <div\n        style={{\n          backgroundColor: \"white\",\n          borderRadius: \"8px\",\n          padding: \"24px\",\n          maxWidth: \"400px\",\n          width: \"100%\",\n          boxShadow: \"0 20px 25px -5px rgba(0, 0, 0, 0.1)\",\n        }}\n        onClick={(e) => e.stopPropagation()}\n      >\n        <h3\n          style={{\n            margin: \"0 0 8px 0\",\n            fontSize: \"18px\",\n            fontWeight: 600,\n          }}\n        >\n          {confirm.title}\n        </h3>\n        <p\n          style={{\n            margin: \"0 0 24px 0\",\n            color: \"#6b7280\",\n          }}\n        >\n          {confirm.message}\n        </p>\n        <div\n          style={{\n            display: \"flex\",\n            gap: \"12px\",\n            justifyContent: \"flex-end\",\n          }}\n        >\n          <button\n            onClick={onCancel}\n            style={{\n              padding: \"8px 16px\",\n              borderRadius: \"6px\",\n              border: \"1px solid #d1d5db\",\n              backgroundColor: \"white\",\n              cursor: \"pointer\",\n            }}\n          >\n            {confirm.cancelLabel ?? \"Cancel\"}\n          </button>\n          <button\n            onClick={onConfirm}\n            style={{\n              padding: \"8px 16px\",\n              borderRadius: \"6px\",\n              border: \"none\",\n              backgroundColor: isDanger ? \"#dc2626\" : \"#3b82f6\",\n              color: \"white\",\n              cursor: \"pointer\",\n            }}\n          >\n            {confirm.confirmLabel ?? \"Confirm\"}\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n","\"use client\";\n\nimport React, {\n  createContext,\n  useContext,\n  useState,\n  useCallback,\n  useMemo,\n  type ReactNode,\n} from \"react\";\nimport {\n  runValidation,\n  type ValidationConfig,\n  type ValidationFunction,\n  type ValidationResult,\n} from \"@json-render/core\";\nimport { useStateStore } from \"./state\";\n\n/**\n * Field validation state\n */\nexport interface FieldValidationState {\n  /** Whether the field has been touched */\n  touched: boolean;\n  /** Whether the field has been validated */\n  validated: boolean;\n  /** Validation result */\n  result: ValidationResult | null;\n}\n\n/**\n * Validation context value\n */\nexport interface ValidationContextValue {\n  /** Custom validation functions from catalog */\n  customFunctions: Record<string, ValidationFunction>;\n  /** Validation state by field path */\n  fieldStates: Record<string, FieldValidationState>;\n  /** Validate a field */\n  validate: (path: string, config: ValidationConfig) => ValidationResult;\n  /** Mark field as touched */\n  touch: (path: string) => void;\n  /** Clear validation for a field */\n  clear: (path: string) => void;\n  /** Validate all fields */\n  validateAll: () => boolean;\n  /** Register field config */\n  registerField: (path: string, config: ValidationConfig) => void;\n}\n\nconst ValidationContext = createContext<ValidationContextValue | null>(null);\n\n/**\n * Props for ValidationProvider\n */\nexport interface ValidationProviderProps {\n  /** Custom validation functions from catalog */\n  customFunctions?: Record<string, ValidationFunction>;\n  children: ReactNode;\n}\n\n/**\n * Provider for validation\n */\nexport function ValidationProvider({\n  customFunctions = {},\n  children,\n}: ValidationProviderProps) {\n  const { state, authState } = useStateStore();\n  const [fieldStates, setFieldStates] = useState<\n    Record<string, FieldValidationState>\n  >({});\n  const [fieldConfigs, setFieldConfigs] = useState<\n    Record<string, ValidationConfig>\n  >({});\n\n  const registerField = useCallback(\n    (path: string, config: ValidationConfig) => {\n      setFieldConfigs((prev) => ({ ...prev, [path]: config }));\n    },\n    [],\n  );\n\n  const validate = useCallback(\n    (path: string, config: ValidationConfig): ValidationResult => {\n      const value = state[path.split(\"/\").filter(Boolean).join(\".\")];\n      const result = runValidation(config, {\n        value,\n        stateModel: state,\n        customFunctions,\n        authState,\n      });\n\n      setFieldStates((prev) => ({\n        ...prev,\n        [path]: {\n          touched: prev[path]?.touched ?? true,\n          validated: true,\n          result,\n        },\n      }));\n\n      return result;\n    },\n    [state, customFunctions, authState],\n  );\n\n  const touch = useCallback((path: string) => {\n    setFieldStates((prev) => ({\n      ...prev,\n      [path]: {\n        ...prev[path],\n        touched: true,\n        validated: prev[path]?.validated ?? false,\n        result: prev[path]?.result ?? null,\n      },\n    }));\n  }, []);\n\n  const clear = useCallback((path: string) => {\n    setFieldStates((prev) => {\n      const { [path]: _, ...rest } = prev;\n      return rest;\n    });\n  }, []);\n\n  const validateAll = useCallback(() => {\n    let allValid = true;\n\n    for (const [path, config] of Object.entries(fieldConfigs)) {\n      const result = validate(path, config);\n      if (!result.valid) {\n        allValid = false;\n      }\n    }\n\n    return allValid;\n  }, [fieldConfigs, validate]);\n\n  const value = useMemo<ValidationContextValue>(\n    () => ({\n      customFunctions,\n      fieldStates,\n      validate,\n      touch,\n      clear,\n      validateAll,\n      registerField,\n    }),\n    [\n      customFunctions,\n      fieldStates,\n      validate,\n      touch,\n      clear,\n      validateAll,\n      registerField,\n    ],\n  );\n\n  return (\n    <ValidationContext.Provider value={value}>\n      {children}\n    </ValidationContext.Provider>\n  );\n}\n\n/**\n * Hook to access validation context\n */\nexport function useValidation(): ValidationContextValue {\n  const ctx = useContext(ValidationContext);\n  if (!ctx) {\n    throw new Error(\"useValidation must be used within a ValidationProvider\");\n  }\n  return ctx;\n}\n\n/**\n * Hook to get validation state for a field\n */\nexport function useFieldValidation(\n  path: string,\n  config?: ValidationConfig,\n): {\n  state: FieldValidationState;\n  validate: () => ValidationResult;\n  touch: () => void;\n  clear: () => void;\n  errors: string[];\n  isValid: boolean;\n} {\n  const {\n    fieldStates,\n    validate: validateField,\n    touch: touchField,\n    clear: clearField,\n    registerField,\n  } = useValidation();\n\n  // Register field on mount\n  React.useEffect(() => {\n    if (config) {\n      registerField(path, config);\n    }\n  }, [path, config, registerField]);\n\n  const state = fieldStates[path] ?? {\n    touched: false,\n    validated: false,\n    result: null,\n  };\n\n  const validate = useCallback(\n    () => validateField(path, config ?? { checks: [] }),\n    [path, config, validateField],\n  );\n\n  const touch = useCallback(() => touchField(path), [path, touchField]);\n  const clear = useCallback(() => clearField(path), [path, clearField]);\n\n  return {\n    state,\n    validate,\n    touch,\n    clear,\n    errors: state.result?.errors ?? [],\n    isValid: state.result?.valid ?? true,\n  };\n}\n","\"use client\";\n\nimport React, { createContext, useContext, type ReactNode } from \"react\";\n\n/**\n * Repeat scope value provided to child elements inside a repeated element.\n */\nexport interface RepeatScopeValue {\n  /** Absolute state path to the current array item (e.g. \"/todos/0\") */\n  basePath: string;\n  /** Index of the current item in the array */\n  index: number;\n}\n\nconst RepeatScopeContext = createContext<RepeatScopeValue | null>(null);\n\n/**\n * Provides repeat scope to child elements so $item and $index tokens resolve correctly.\n */\nexport function RepeatScopeProvider({\n  basePath,\n  index,\n  children,\n}: RepeatScopeValue & { children: ReactNode }) {\n  return (\n    <RepeatScopeContext.Provider value={{ basePath, index }}>\n      {children}\n    </RepeatScopeContext.Provider>\n  );\n}\n\n/**\n * Read the current repeat scope (or null if not inside a repeated element).\n */\nexport function useRepeatScope(): RepeatScopeValue | null {\n  return useContext(RepeatScopeContext);\n}\n\n// ---------------------------------------------------------------------------\n// Token rewriting helpers\n// ---------------------------------------------------------------------------\n\n/**\n * Recursively rewrite `$item` and `$index` tokens in a value.\n *\n * - `\"$item/foo\"` → `\"{basePath}/foo\"`\n * - `\"$item\"` → `\"{basePath}\"`\n * - `\"$index\"` → `index` (number)\n */\nexport function rewriteRepeatTokens(\n  value: unknown,\n  basePath: string,\n  index: number,\n): unknown {\n  if (typeof value === \"string\") {\n    if (value === \"$index\") return index;\n    if (value === \"$item\") return basePath;\n    if (value.startsWith(\"$item/\"))\n      return basePath + value.slice(\"$item\".length);\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    let changed = false;\n    const result = value.map((item) => {\n      const rewritten = rewriteRepeatTokens(item, basePath, index);\n      if (rewritten !== item) changed = true;\n      return rewritten;\n    });\n    return changed ? result : value;\n  }\n\n  if (typeof value === \"object\" && value !== null) {\n    let changed = false;\n    const result: Record<string, unknown> = {};\n    for (const [key, val] of Object.entries(value as Record<string, unknown>)) {\n      const rewritten = rewriteRepeatTokens(val, basePath, index);\n      if (rewritten !== val) changed = true;\n      result[key] = rewritten;\n    }\n    return changed ? result : value;\n  }\n\n  return value;\n}\n","\"use client\";\n\nimport React, {\n  type ComponentType,\n  type ErrorInfo,\n  type ReactNode,\n  useCallback,\n  useMemo,\n} from \"react\";\nimport type {\n  UIElement,\n  Spec,\n  ActionBinding,\n  Catalog,\n  SchemaDefinition,\n  LegacyCatalog,\n  ComponentDefinition,\n} from \"@json-render/core\";\nimport { resolveElementProps, getByPath } from \"@json-render/core\";\nimport type {\n  Components,\n  Actions,\n  ActionFn,\n  SetState,\n  StateModel,\n} from \"./catalog-types\";\nimport { useIsVisible, useVisibility } from \"./contexts/visibility\";\nimport { useActions } from \"./contexts/actions\";\nimport { useStateStore } from \"./contexts/state\";\nimport { StateProvider } from \"./contexts/state\";\nimport { VisibilityProvider } from \"./contexts/visibility\";\nimport { ActionProvider } from \"./contexts/actions\";\nimport { ValidationProvider } from \"./contexts/validation\";\nimport { ConfirmDialog } from \"./contexts/actions\";\nimport {\n  RepeatScopeProvider,\n  useRepeatScope,\n  rewriteRepeatTokens,\n} from \"./contexts/repeat-scope\";\n\n/**\n * Props passed to component renderers\n */\nexport interface ComponentRenderProps<P = Record<string, unknown>> {\n  /** The element being rendered */\n  element: UIElement<string, P>;\n  /** Rendered children */\n  children?: ReactNode;\n  /** Emit a named event. The renderer resolves the event to action binding(s) from the element's `on` field. */\n  emit?: (event: string) => void;\n  /** Whether the parent is loading */\n  loading?: boolean;\n}\n\n/**\n * Component renderer type\n */\nexport type ComponentRenderer<P = Record<string, unknown>> = ComponentType<\n  ComponentRenderProps<P>\n>;\n\n/**\n * Registry of component renderers\n */\nexport type ComponentRegistry = Record<string, ComponentRenderer<any>>;\n\n/**\n * Props for the Renderer component\n */\nexport interface RendererProps {\n  /** The UI spec to render */\n  spec: Spec | null;\n  /** Component registry */\n  registry: ComponentRegistry;\n  /** Whether the spec is currently loading/streaming */\n  loading?: boolean;\n  /** Fallback component for unknown types */\n  fallback?: ComponentRenderer;\n}\n\n// ---------------------------------------------------------------------------\n// ElementErrorBoundary – catches rendering errors in individual elements so\n// a single bad component never crashes the whole page.\n// ---------------------------------------------------------------------------\n\ninterface ElementErrorBoundaryProps {\n  elementType: string;\n  children: ReactNode;\n}\n\ninterface ElementErrorBoundaryState {\n  hasError: boolean;\n}\n\nclass ElementErrorBoundary extends React.Component<\n  ElementErrorBoundaryProps,\n  ElementErrorBoundaryState\n> {\n  constructor(props: ElementErrorBoundaryProps) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(): ElementErrorBoundaryState {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, info: ErrorInfo) {\n    console.error(\n      `[json-render] Rendering error in <${this.props.elementType}>:`,\n      error,\n      info.componentStack,\n    );\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // Render nothing – the element silently disappears rather than\n      // crashing the entire application.\n      return null;\n    }\n    return this.props.children;\n  }\n}\n\n/**\n * Element renderer component\n */\nfunction ElementRenderer({\n  element,\n  spec,\n  registry,\n  loading,\n  fallback,\n}: {\n  element: UIElement;\n  spec: Spec;\n  registry: ComponentRegistry;\n  loading?: boolean;\n  fallback?: ComponentRenderer;\n}) {\n  const repeatScope = useRepeatScope();\n  const { ctx } = useVisibility();\n  const { execute } = useActions();\n\n  // ---- Rewrite $item / $index tokens when inside a repeat ----\n  let effectiveElement = element;\n  if (repeatScope) {\n    const rewrittenProps = rewriteRepeatTokens(\n      element.props,\n      repeatScope.basePath,\n      repeatScope.index,\n    );\n    const rewrittenVisible =\n      element.visible !== undefined\n        ? rewriteRepeatTokens(\n            element.visible,\n            repeatScope.basePath,\n            repeatScope.index,\n          )\n        : element.visible;\n    const rewrittenOn =\n      element.on !== undefined\n        ? rewriteRepeatTokens(\n            element.on,\n            repeatScope.basePath,\n            repeatScope.index,\n          )\n        : element.on;\n    if (\n      rewrittenProps !== element.props ||\n      rewrittenVisible !== element.visible ||\n      rewrittenOn !== element.on\n    ) {\n      effectiveElement = {\n        ...element,\n        props: rewrittenProps as Record<string, unknown>,\n        visible: rewrittenVisible as UIElement[\"visible\"],\n        on: rewrittenOn as UIElement[\"on\"],\n      };\n    }\n  }\n\n  // Evaluate visibility (after token rewriting so paths are absolute)\n  const isVisible = useIsVisible(effectiveElement.visible);\n\n  // Create emit function that resolves events to action bindings.\n  // Must be called before any early return to satisfy Rules of Hooks.\n  const onBindings = effectiveElement.on;\n  const emit = useCallback(\n    (eventName: string) => {\n      const binding = onBindings?.[eventName];\n      if (!binding) return;\n      const bindings = Array.isArray(binding) ? binding : [binding];\n      for (const b of bindings) {\n        execute(b);\n      }\n    },\n    [onBindings, execute],\n  );\n\n  // Don't render if not visible\n  if (!isVisible) {\n    return null;\n  }\n\n  // Resolve dynamic prop expressions ($path, $cond/$then/$else)\n  const resolvedProps = resolveElementProps(\n    effectiveElement.props as Record<string, unknown>,\n    ctx,\n  );\n  const resolvedElement =\n    resolvedProps !== effectiveElement.props\n      ? { ...effectiveElement, props: resolvedProps }\n      : effectiveElement;\n\n  // Get the component renderer\n  const Component = registry[resolvedElement.type] ?? fallback;\n\n  if (!Component) {\n    console.warn(`No renderer for component type: ${resolvedElement.type}`);\n    return null;\n  }\n\n  // ---- Render children (with repeat support) ----\n  const children = resolvedElement.repeat ? (\n    <RepeatChildren\n      element={resolvedElement}\n      spec={spec}\n      registry={registry}\n      loading={loading}\n      fallback={fallback}\n    />\n  ) : (\n    resolvedElement.children?.map((childKey) => {\n      const childElement = spec.elements[childKey];\n      if (!childElement) {\n        if (!loading) {\n          console.warn(\n            `[json-render] Missing element \"${childKey}\" referenced as child of \"${resolvedElement.type}\". This element will not render.`,\n          );\n        }\n        return null;\n      }\n      return (\n        <ElementRenderer\n          key={childKey}\n          element={childElement}\n          spec={spec}\n          registry={registry}\n          loading={loading}\n          fallback={fallback}\n        />\n      );\n    })\n  );\n\n  return (\n    <ElementErrorBoundary elementType={resolvedElement.type}>\n      <Component element={resolvedElement} emit={emit} loading={loading}>\n        {children}\n      </Component>\n    </ElementErrorBoundary>\n  );\n}\n\n// ---------------------------------------------------------------------------\n// RepeatChildren -- renders child elements once per item in a state array.\n// Used when an element has a `repeat` field.\n// ---------------------------------------------------------------------------\n\nfunction RepeatChildren({\n  element,\n  spec,\n  registry,\n  loading,\n  fallback,\n}: {\n  element: UIElement;\n  spec: Spec;\n  registry: ComponentRegistry;\n  loading?: boolean;\n  fallback?: ComponentRenderer;\n}) {\n  const { state } = useStateStore();\n  const repeat = element.repeat!;\n  const statePath = repeat.path;\n\n  const items = (getByPath(state, statePath) as unknown[] | undefined) ?? [];\n\n  return (\n    <>\n      {items.map((item, index) => {\n        // Use a stable key: prefer key field, fall back to index\n        const key =\n          repeat.key && typeof item === \"object\" && item !== null\n            ? String((item as Record<string, unknown>)[repeat.key] ?? index)\n            : String(index);\n\n        return (\n          <RepeatScopeProvider\n            key={key}\n            basePath={`${statePath}/${index}`}\n            index={index}\n          >\n            {element.children?.map((childKey) => {\n              const childElement = spec.elements[childKey];\n              if (!childElement) {\n                if (!loading) {\n                  console.warn(\n                    `[json-render] Missing element \"${childKey}\" referenced as child of \"${element.type}\" (repeat). This element will not render.`,\n                  );\n                }\n                return null;\n              }\n              return (\n                <ElementRenderer\n                  key={childKey}\n                  element={childElement}\n                  spec={spec}\n                  registry={registry}\n                  loading={loading}\n                  fallback={fallback}\n                />\n              );\n            })}\n          </RepeatScopeProvider>\n        );\n      })}\n    </>\n  );\n}\n\n/**\n * Main renderer component\n */\nexport function Renderer({ spec, registry, loading, fallback }: RendererProps) {\n  if (!spec || !spec.root) {\n    return null;\n  }\n\n  const rootElement = spec.elements[spec.root];\n  if (!rootElement) {\n    return null;\n  }\n\n  return (\n    <ElementRenderer\n      element={rootElement}\n      spec={spec}\n      registry={registry}\n      loading={loading}\n      fallback={fallback}\n    />\n  );\n}\n\n/**\n * Props for JSONUIProvider\n */\nexport interface JSONUIProviderProps {\n  /** Component registry */\n  registry: ComponentRegistry;\n  /** Initial state model */\n  initialState?: Record<string, unknown>;\n  /** Auth state */\n  authState?: { isSignedIn: boolean; user?: Record<string, unknown> };\n  /** Action handlers */\n  actionHandlers?: Record<\n    string,\n    (params: Record<string, unknown>) => Promise<unknown> | unknown\n  >;\n  /** Navigation function */\n  navigate?: (path: string) => void;\n  /** Custom validation functions */\n  validationFunctions?: Record<\n    string,\n    (value: unknown, args?: Record<string, unknown>) => boolean\n  >;\n  /** Callback when state changes */\n  onStateChange?: (path: string, value: unknown) => void;\n  children: ReactNode;\n}\n\n/**\n * Combined provider for all JSONUI contexts\n */\nexport function JSONUIProvider({\n  registry,\n  initialState,\n  authState,\n  actionHandlers,\n  navigate,\n  validationFunctions,\n  onStateChange,\n  children,\n}: JSONUIProviderProps) {\n  return (\n    <StateProvider\n      initialState={initialState}\n      authState={authState}\n      onStateChange={onStateChange}\n    >\n      <VisibilityProvider>\n        <ActionProvider handlers={actionHandlers} navigate={navigate}>\n          <ValidationProvider customFunctions={validationFunctions}>\n            {children}\n            <ConfirmationDialogManager />\n          </ValidationProvider>\n        </ActionProvider>\n      </VisibilityProvider>\n    </StateProvider>\n  );\n}\n\n/**\n * Renders the confirmation dialog when needed\n */\nfunction ConfirmationDialogManager() {\n  const { pendingConfirmation, confirm, cancel } = useActions();\n\n  if (!pendingConfirmation?.action.confirm) {\n    return null;\n  }\n\n  return (\n    <ConfirmDialog\n      confirm={pendingConfirmation.action.confirm}\n      onConfirm={confirm}\n      onCancel={cancel}\n    />\n  );\n}\n\n/**\n * Legacy helper to create a renderer component from a catalog\n * @deprecated Use createRenderer with the new catalog API instead\n */\nexport function createRendererFromCatalog<\n  C extends LegacyCatalog<Record<string, ComponentDefinition>>,\n>(\n  _catalog: C,\n  registry: ComponentRegistry,\n): ComponentType<Omit<RendererProps, \"registry\">> {\n  return function CatalogRenderer(props: Omit<RendererProps, \"registry\">) {\n    return <Renderer {...props} registry={registry} />;\n  };\n}\n\n// ============================================================================\n// defineRegistry\n// ============================================================================\n\n/**\n * Result returned by defineRegistry\n */\nexport interface DefineRegistryResult {\n  /** Component registry for `<Renderer registry={...} />` */\n  registry: ComponentRegistry;\n  /**\n   * Create ActionProvider-compatible handlers.\n   * Accepts getter functions so handlers always read the latest state/setState\n   * (e.g. from React refs).\n   */\n  handlers: (\n    getSetState: () => SetState | undefined,\n    getState: () => StateModel,\n  ) => Record<string, (params: Record<string, unknown>) => Promise<void>>;\n  /**\n   * Execute an action by name imperatively\n   * (for use outside the React tree, e.g. initial state loading).\n   */\n  executeAction: (\n    actionName: string,\n    params: Record<string, unknown> | undefined,\n    setState: SetState,\n    state?: StateModel,\n  ) => Promise<void>;\n}\n\n/**\n * Create a registry from a catalog with components and/or actions.\n *\n * @example\n * ```tsx\n * // Components only\n * const { registry } = defineRegistry(catalog, {\n *   components: {\n *     Card: ({ props, children }) => (\n *       <div className=\"card\">{props.title}{children}</div>\n *     ),\n *   },\n * });\n *\n * // Actions only\n * const { handlers, executeAction } = defineRegistry(catalog, {\n *   actions: {\n *     viewCustomers: async (params, setState) => { ... },\n *   },\n * });\n *\n * // Both\n * const { registry, handlers, executeAction } = defineRegistry(catalog, {\n *   components: { ... },\n *   actions: { ... },\n * });\n * ```\n */\nexport function defineRegistry<C extends Catalog>(\n  _catalog: C,\n  options: {\n    components?: Components<C>;\n    actions?: Actions<C>;\n  },\n): DefineRegistryResult {\n  // Build component registry\n  const registry: ComponentRegistry = {};\n  if (options.components) {\n    for (const [name, componentFn] of Object.entries(options.components)) {\n      registry[name] = ({\n        element,\n        children,\n        emit,\n        loading,\n      }: ComponentRenderProps) => {\n        return (componentFn as DefineRegistryComponentFn)({\n          props: element.props,\n          children,\n          emit,\n          loading,\n        });\n      };\n    }\n  }\n\n  // Build action helpers\n  const actionMap = options.actions\n    ? (Object.entries(options.actions) as Array<\n        [string, DefineRegistryActionFn]\n      >)\n    : [];\n\n  const handlers = (\n    getSetState: () => SetState | undefined,\n    getState: () => StateModel,\n  ): Record<string, (params: Record<string, unknown>) => Promise<void>> => {\n    const result: Record<\n      string,\n      (params: Record<string, unknown>) => Promise<void>\n    > = {};\n    for (const [name, actionFn] of actionMap) {\n      result[name] = async (params) => {\n        const setState = getSetState();\n        const state = getState();\n        if (setState) {\n          await actionFn(params, setState, state);\n        }\n      };\n    }\n    return result;\n  };\n\n  const executeAction = async (\n    actionName: string,\n    params: Record<string, unknown> | undefined,\n    setState: SetState,\n    state: StateModel = {},\n  ): Promise<void> => {\n    const entry = actionMap.find(([name]) => name === actionName);\n    if (entry) {\n      await entry[1](params, setState, state);\n    } else {\n      console.warn(`Unknown action: ${actionName}`);\n    }\n  };\n\n  return { registry, handlers, executeAction };\n}\n\n/** @internal */\ntype DefineRegistryComponentFn = (ctx: {\n  props: unknown;\n  children?: React.ReactNode;\n  emit?: (event: string) => void;\n  loading?: boolean;\n}) => React.ReactNode;\n\n/** @internal */\ntype DefineRegistryActionFn = (\n  params: Record<string, unknown> | undefined,\n  setState: SetState,\n  state: StateModel,\n) => Promise<void>;\n\n// ============================================================================\n// NEW API\n// ============================================================================\n\n/**\n * Props for renderers created with createRenderer\n */\nexport interface CreateRendererProps {\n  /** The spec to render (AI-generated JSON) */\n  spec: Spec | null;\n  /** State context for dynamic values */\n  state?: Record<string, unknown>;\n  /** Action handler */\n  onAction?: (actionName: string, params?: Record<string, unknown>) => void;\n  /** Callback when state changes (e.g., from form inputs) */\n  onStateChange?: (path: string, value: unknown) => void;\n  /** Whether the spec is currently loading/streaming */\n  loading?: boolean;\n  /** Auth state for visibility conditions */\n  authState?: { isSignedIn: boolean; user?: Record<string, unknown> };\n  /** Fallback component for unknown types */\n  fallback?: ComponentRenderer;\n}\n\n/**\n * Component map type - maps component names to React components\n */\nexport type ComponentMap<\n  TComponents extends Record<string, { props: unknown }>,\n> = {\n  [K in keyof TComponents]: ComponentType<\n    ComponentRenderProps<\n      TComponents[K][\"props\"] extends { _output: infer O }\n        ? O\n        : Record<string, unknown>\n    >\n  >;\n};\n\n/**\n * Create a renderer from a catalog\n *\n * @example\n * ```typescript\n * const DashboardRenderer = createRenderer(dashboardCatalog, {\n *   Card: ({ element, children }) => <div className=\"card\">{children}</div>,\n *   Metric: ({ element }) => <span>{element.props.value}</span>,\n * });\n *\n * // Usage\n * <DashboardRenderer spec={aiGeneratedSpec} state={state} />\n * ```\n */\nexport function createRenderer<\n  TDef extends SchemaDefinition,\n  TCatalog extends { components: Record<string, { props: unknown }> },\n>(\n  catalog: Catalog<TDef, TCatalog>,\n  components: ComponentMap<TCatalog[\"components\"]>,\n): ComponentType<CreateRendererProps> {\n  // Convert component map to registry\n  const registry: ComponentRegistry =\n    components as unknown as ComponentRegistry;\n\n  // Return the renderer component\n  return function CatalogRenderer({\n    spec,\n    state,\n    onAction,\n    onStateChange,\n    loading,\n    authState,\n    fallback,\n  }: CreateRendererProps) {\n    // Wrap onAction to match internal API\n    const actionHandlers = onAction\n      ? {\n          __default__: (params: Record<string, unknown>) => {\n            const actionName = params.__actionName__ as string;\n            const actionParams = params.__actionParams__ as Record<\n              string,\n              unknown\n            >;\n            return onAction(actionName, actionParams);\n          },\n        }\n      : undefined;\n\n    return (\n      <StateProvider\n        initialState={state}\n        authState={authState}\n        onStateChange={onStateChange}\n      >\n        <VisibilityProvider>\n          <ActionProvider handlers={actionHandlers}>\n            <ValidationProvider>\n              <Renderer\n                spec={spec}\n                registry={registry}\n                loading={loading}\n                fallback={fallback}\n              />\n              <ConfirmationDialogManager />\n            </ValidationProvider>\n          </ActionProvider>\n        </VisibilityProvider>\n      </StateProvider>\n    );\n  };\n}\n","\"use client\";\n\nimport { useState, useCallback, useRef, useEffect } from \"react\";\nimport type {\n  Spec,\n  UIElement,\n  FlatElement,\n  JsonPatch,\n} from \"@json-render/core\";\nimport {\n  setByPath,\n  getByPath,\n  addByPath,\n  removeByPath,\n} from \"@json-render/core\";\n\n/**\n * Token usage metadata from AI generation\n */\nexport interface TokenUsage {\n  promptTokens: number;\n  completionTokens: number;\n  totalTokens: number;\n}\n\n/**\n * Parse result for a single line -- either a patch or usage metadata\n */\ntype ParsedLine =\n  | { type: \"patch\"; patch: JsonPatch }\n  | { type: \"usage\"; usage: TokenUsage }\n  | null;\n\n/**\n * Parse a single JSON line (patch or metadata)\n */\nfunction parseLine(line: string): ParsedLine {\n  try {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed.startsWith(\"//\")) {\n      return null;\n    }\n    const parsed = JSON.parse(trimmed);\n\n    // Check for usage metadata\n    if (parsed.__meta === \"usage\") {\n      return {\n        type: \"usage\",\n        usage: {\n          promptTokens: parsed.promptTokens ?? 0,\n          completionTokens: parsed.completionTokens ?? 0,\n          totalTokens: parsed.totalTokens ?? 0,\n        },\n      };\n    }\n\n    return { type: \"patch\", patch: parsed as JsonPatch };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Set a value at a spec path (for add/replace operations).\n */\nfunction setSpecValue(newSpec: Spec, path: string, value: unknown): void {\n  if (path === \"/root\") {\n    newSpec.root = value as string;\n    return;\n  }\n\n  if (path === \"/state\") {\n    newSpec.state = value as Record<string, unknown>;\n    return;\n  }\n\n  if (path.startsWith(\"/state/\")) {\n    if (!newSpec.state) newSpec.state = {};\n    const statePath = path.slice(\"/state\".length); // e.g. \"/posts\"\n    setByPath(newSpec.state as Record<string, unknown>, statePath, value);\n    return;\n  }\n\n  if (path.startsWith(\"/elements/\")) {\n    const pathParts = path.slice(\"/elements/\".length).split(\"/\");\n    const elementKey = pathParts[0];\n    if (!elementKey) return;\n\n    if (pathParts.length === 1) {\n      newSpec.elements[elementKey] = value as UIElement;\n    } else {\n      const element = newSpec.elements[elementKey];\n      if (element) {\n        const propPath = \"/\" + pathParts.slice(1).join(\"/\");\n        const newElement = { ...element };\n        setByPath(\n          newElement as unknown as Record<string, unknown>,\n          propPath,\n          value,\n        );\n        newSpec.elements[elementKey] = newElement;\n      }\n    }\n  }\n}\n\n/**\n * Remove a value at a spec path.\n */\nfunction removeSpecValue(newSpec: Spec, path: string): void {\n  if (path === \"/state\") {\n    delete newSpec.state;\n    return;\n  }\n\n  if (path.startsWith(\"/state/\") && newSpec.state) {\n    const statePath = path.slice(\"/state\".length);\n    removeByPath(newSpec.state as Record<string, unknown>, statePath);\n    return;\n  }\n\n  if (path.startsWith(\"/elements/\")) {\n    const pathParts = path.slice(\"/elements/\".length).split(\"/\");\n    const elementKey = pathParts[0];\n    if (!elementKey) return;\n\n    if (pathParts.length === 1) {\n      const { [elementKey]: _, ...rest } = newSpec.elements;\n      newSpec.elements = rest;\n    } else {\n      const element = newSpec.elements[elementKey];\n      if (element) {\n        const propPath = \"/\" + pathParts.slice(1).join(\"/\");\n        const newElement = { ...element };\n        removeByPath(\n          newElement as unknown as Record<string, unknown>,\n          propPath,\n        );\n        newSpec.elements[elementKey] = newElement;\n      }\n    }\n  }\n}\n\n/**\n * Get a value at a spec path.\n */\nfunction getSpecValue(spec: Spec, path: string): unknown {\n  if (path === \"/root\") return spec.root;\n  if (path === \"/state\") return spec.state;\n  if (path.startsWith(\"/state/\") && spec.state) {\n    const statePath = path.slice(\"/state\".length);\n    return getByPath(spec.state as Record<string, unknown>, statePath);\n  }\n  return getByPath(spec as unknown as Record<string, unknown>, path);\n}\n\n/**\n * Apply an RFC 6902 JSON patch to the current spec.\n * Supports add, remove, replace, move, copy, and test operations.\n */\nfunction applyPatch(spec: Spec, patch: JsonPatch): Spec {\n  const newSpec = {\n    ...spec,\n    elements: { ...spec.elements },\n    ...(spec.state ? { state: { ...spec.state } } : {}),\n  };\n\n  switch (patch.op) {\n    case \"add\":\n    case \"replace\": {\n      setSpecValue(newSpec, patch.path, patch.value);\n      break;\n    }\n    case \"remove\": {\n      removeSpecValue(newSpec, patch.path);\n      break;\n    }\n    case \"move\": {\n      if (!patch.from) break;\n      const moveValue = getSpecValue(newSpec, patch.from);\n      removeSpecValue(newSpec, patch.from);\n      setSpecValue(newSpec, patch.path, moveValue);\n      break;\n    }\n    case \"copy\": {\n      if (!patch.from) break;\n      const copyValue = getSpecValue(newSpec, patch.from);\n      setSpecValue(newSpec, patch.path, copyValue);\n      break;\n    }\n    case \"test\": {\n      // test is a no-op for rendering purposes (validation only)\n      break;\n    }\n  }\n\n  return newSpec;\n}\n\n/**\n * Options for useUIStream\n */\nexport interface UseUIStreamOptions {\n  /** API endpoint */\n  api: string;\n  /** Callback when complete */\n  onComplete?: (spec: Spec) => void;\n  /** Callback on error */\n  onError?: (error: Error) => void;\n}\n\n/**\n * Return type for useUIStream\n */\nexport interface UseUIStreamReturn {\n  /** Current UI spec */\n  spec: Spec | null;\n  /** Whether currently streaming */\n  isStreaming: boolean;\n  /** Error if any */\n  error: Error | null;\n  /** Token usage from the last generation */\n  usage: TokenUsage | null;\n  /** Raw JSONL lines received from the stream (JSON patch lines) */\n  rawLines: string[];\n  /** Send a prompt to generate UI */\n  send: (prompt: string, context?: Record<string, unknown>) => Promise<void>;\n  /** Clear the current spec */\n  clear: () => void;\n}\n\n/**\n * Hook for streaming UI generation\n */\nexport function useUIStream({\n  api,\n  onComplete,\n  onError,\n}: UseUIStreamOptions): UseUIStreamReturn {\n  const [spec, setSpec] = useState<Spec | null>(null);\n  const [isStreaming, setIsStreaming] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [usage, setUsage] = useState<TokenUsage | null>(null);\n  const [rawLines, setRawLines] = useState<string[]>([]);\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const clear = useCallback(() => {\n    setSpec(null);\n    setError(null);\n  }, []);\n\n  const send = useCallback(\n    async (prompt: string, context?: Record<string, unknown>) => {\n      // Abort any existing request\n      abortControllerRef.current?.abort();\n      abortControllerRef.current = new AbortController();\n\n      setIsStreaming(true);\n      setError(null);\n      setUsage(null);\n      setRawLines([]);\n\n      // Start with previous spec if provided, otherwise empty spec\n      const previousSpec = context?.previousSpec as Spec | undefined;\n      let currentSpec: Spec =\n        previousSpec && previousSpec.root\n          ? { ...previousSpec, elements: { ...previousSpec.elements } }\n          : { root: \"\", elements: {} };\n      setSpec(currentSpec);\n\n      try {\n        const response = await fetch(api, {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            prompt,\n            context,\n            currentSpec,\n          }),\n          signal: abortControllerRef.current.signal,\n        });\n\n        if (!response.ok) {\n          // Try to parse JSON error response for better error messages\n          let errorMessage = `HTTP error: ${response.status}`;\n          try {\n            const errorData = await response.json();\n            if (errorData.message) {\n              errorMessage = errorData.message;\n            } else if (errorData.error) {\n              errorMessage = errorData.error;\n            }\n          } catch {\n            // Ignore JSON parsing errors, use default message\n          }\n          throw new Error(errorMessage);\n        }\n\n        const reader = response.body?.getReader();\n        if (!reader) {\n          throw new Error(\"No response body\");\n        }\n\n        const decoder = new TextDecoder();\n        let buffer = \"\";\n\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n\n          buffer += decoder.decode(value, { stream: true });\n\n          // Process complete lines\n          const lines = buffer.split(\"\\n\");\n          buffer = lines.pop() ?? \"\";\n\n          for (const line of lines) {\n            const trimmed = line.trim();\n            if (!trimmed) continue;\n            const result = parseLine(trimmed);\n            if (!result) continue;\n            if (result.type === \"usage\") {\n              setUsage(result.usage);\n            } else {\n              setRawLines((prev) => [...prev, trimmed]);\n              currentSpec = applyPatch(currentSpec, result.patch);\n              setSpec({ ...currentSpec });\n            }\n          }\n        }\n\n        // Process any remaining buffer\n        if (buffer.trim()) {\n          const trimmed = buffer.trim();\n          const result = parseLine(trimmed);\n          if (result) {\n            if (result.type === \"usage\") {\n              setUsage(result.usage);\n            } else {\n              setRawLines((prev) => [...prev, trimmed]);\n              currentSpec = applyPatch(currentSpec, result.patch);\n              setSpec({ ...currentSpec });\n            }\n          }\n        }\n\n        onComplete?.(currentSpec);\n      } catch (err) {\n        if ((err as Error).name === \"AbortError\") {\n          return;\n        }\n        const error = err instanceof Error ? err : new Error(String(err));\n        setError(error);\n        onError?.(error);\n      } finally {\n        setIsStreaming(false);\n      }\n    },\n    [api, onComplete, onError],\n  );\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      abortControllerRef.current?.abort();\n    };\n  }, []);\n\n  return {\n    spec,\n    isStreaming,\n    error,\n    usage,\n    rawLines,\n    send,\n    clear,\n  };\n}\n\n/**\n * Convert a flat element list to a Spec.\n * Input elements use key/parentKey to establish identity and relationships.\n * Output spec uses the map-based format where key is the map entry key\n * and parent-child relationships are expressed through children arrays.\n */\nexport function flatToTree(elements: FlatElement[]): Spec {\n  const elementMap: Record<string, UIElement> = {};\n  let root = \"\";\n\n  // First pass: add all elements to map\n  for (const element of elements) {\n    elementMap[element.key] = {\n      type: element.type,\n      props: element.props,\n      children: [],\n      visible: element.visible,\n    };\n  }\n\n  // Second pass: build parent-child relationships\n  for (const element of elements) {\n    if (element.parentKey) {\n      const parent = elementMap[element.parentKey];\n      if (parent) {\n        if (!parent.children) {\n          parent.children = [];\n        }\n        parent.children.push(element.key);\n      }\n    } else {\n      root = element.key;\n    }\n  }\n\n  return { root, elements: elementMap };\n}\n"],"names":["value","createContext","useContext","useMemo","jsx","createContext","useMemo","useContext","createContext","useContext","useState","useCallback","useMemo","jsx","createContext","useState","useCallback","value","useMemo","useContext","executeAction","React","createContext","useContext","useState","useCallback","useMemo","jsx","createContext","useState","useCallback","value","useMemo","useContext","React","createContext","useContext","jsx","React","useCallback","getByPath","jsx","jsxs","React","useCallback","getByPath","executeAction","useState","useCallback","useRef","useEffect","setByPath","getByPath","error"],"mappings":"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"}}]
}