{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/lib/utils.ts"],"sourcesContent":["import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\n/**\n * Get the user's preferred locale or fallback to 'en-US'\n */\nexport function getUserLocale(): string {\n  if (typeof navigator !== 'undefined') {\n    return navigator.language || navigator.languages?.[0] || 'en-US';\n  }\n  return 'en-US';\n}\n\n/**\n * Format a date using the user's locale\n */\nexport function formatLocalDate(date: Date | string | number, options?: Intl.DateTimeFormatOptions): string {\n  const dateObj = date instanceof Date ? date : new Date(date);\n  return dateObj.toLocaleDateString(getUserLocale(), options);\n}\n\n/**\n * Format a time using the user's locale\n */\nexport function formatLocalTime(date: Date | string | number, options?: Intl.DateTimeFormatOptions): string {\n  const dateObj = date instanceof Date ? date : new Date(date);\n  return dateObj.toLocaleTimeString(getUserLocale(), options);\n}\n\n/**\n * Format a date and time using the user's locale\n */\nexport function formatLocalDateTime(date: Date | string | number, options?: Intl.DateTimeFormatOptions): string {\n  const dateObj = date instanceof Date ? date : new Date(date);\n  return dateObj.toLocaleString(getUserLocale(), options);\n}\n\nexport function formatDate(date: string) {\n  let currentDate = new Date().getTime();\n  if (!date.includes(\"T\")) {\n    date = `${date}T00:00:00`;\n  }\n  let targetDate = new Date(date).getTime();\n  let timeDifference = Math.abs(currentDate - targetDate);\n  let daysAgo = Math.floor(timeDifference / (1000 * 60 * 60 * 24));\n\n  let fullDate = formatLocalDate(date, {\n    month: \"long\",\n    day: \"numeric\",\n    year: \"numeric\",\n  });\n\n  if (daysAgo < 1) {\n    return \"Today\";\n  } else if (daysAgo < 7) {\n    return `${fullDate} (${daysAgo}d ago)`;\n  } else if (daysAgo < 30) {\n    const weeksAgo = Math.floor(daysAgo / 7);\n    return `${fullDate} (${weeksAgo}w ago)`;\n  } else if (daysAgo < 365) {\n    const monthsAgo = Math.floor(daysAgo / 30);\n    return `${fullDate} (${monthsAgo}mo ago)`;\n  } else {\n    const yearsAgo = Math.floor(daysAgo / 365);\n    return `${fullDate} (${yearsAgo}y ago)`;\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,oOAAO,EAAC,IAAA,8LAAI,EAAC;AACtB;AAKO,SAAS;IACd,IAAI,OAAO,cAAc,aAAa;QACpC,OAAO,UAAU,QAAQ,IAAI,UAAU,SAAS,EAAE,CAAC,EAAE,IAAI;IAC3D;IACA,OAAO;AACT;AAKO,SAAS,gBAAgB,IAA4B,EAAE,OAAoC;IAChG,MAAM,UAAU,gBAAgB,OAAO,OAAO,IAAI,KAAK;IACvD,OAAO,QAAQ,kBAAkB,CAAC,iBAAiB;AACrD;AAKO,SAAS,gBAAgB,IAA4B,EAAE,OAAoC;IAChG,MAAM,UAAU,gBAAgB,OAAO,OAAO,IAAI,KAAK;IACvD,OAAO,QAAQ,kBAAkB,CAAC,iBAAiB;AACrD;AAKO,SAAS,oBAAoB,IAA4B,EAAE,OAAoC;IACpG,MAAM,UAAU,gBAAgB,OAAO,OAAO,IAAI,KAAK;IACvD,OAAO,QAAQ,cAAc,CAAC,iBAAiB;AACjD;AAEO,SAAS,WAAW,IAAY;IACrC,IAAI,cAAc,IAAI,OAAO,OAAO;IACpC,IAAI,CAAC,KAAK,QAAQ,CAAC,MAAM;QACvB,OAAO,GAAG,KAAK,SAAS,CAAC;IAC3B;IACA,IAAI,aAAa,IAAI,KAAK,MAAM,OAAO;IACvC,IAAI,iBAAiB,KAAK,GAAG,CAAC,cAAc;IAC5C,IAAI,UAAU,KAAK,KAAK,CAAC,iBAAiB,CAAC,OAAO,KAAK,KAAK,EAAE;IAE9D,IAAI,WAAW,gBAAgB,MAAM;QACnC,OAAO;QACP,KAAK;QACL,MAAM;IACR;IAEA,IAAI,UAAU,GAAG;QACf,OAAO;IACT,OAAO,IAAI,UAAU,GAAG;QACtB,OAAO,GAAG,SAAS,EAAE,EAAE,QAAQ,MAAM,CAAC;IACxC,OAAO,IAAI,UAAU,IAAI;QACvB,MAAM,WAAW,KAAK,KAAK,CAAC,UAAU;QACtC,OAAO,GAAG,SAAS,EAAE,EAAE,SAAS,MAAM,CAAC;IACzC,OAAO,IAAI,UAAU,KAAK;QACxB,MAAM,YAAY,KAAK,KAAK,CAAC,UAAU;QACvC,OAAO,GAAG,SAAS,EAAE,EAAE,UAAU,OAAO,CAAC;IAC3C,OAAO;QACL,MAAM,WAAW,KAAK,KAAK,CAAC,UAAU;QACtC,OAAO,GAAG,SAAS,EAAE,EAAE,SAAS,MAAM,CAAC;IACzC;AACF"}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/lib/claw-ai/proactive-engine.ts"],"sourcesContent":["/**\n * Claw AI Proactive Engine\n *\n * This is the brain that drives Claw AI's proactive behavior.\n * Based on the EXPERIENCE_PHILOSOPHY.md:\n * - \"Claw AI is an operator, not a chatbot\"\n * - \"Agentic without being theatrical\"\n * - \"Structures, files, notifies, remembers\"\n *\n * Claw AI proactively engages users to hook them into working together\n * on something meaningful, demonstrating the OS philosophy.\n */\n\nexport type EngagementTrigger =\n  | 'first_visit'           // User's first time on the site\n  | 'return_visit'          // User returning after being away\n  | 'idle_user'             // User hasn't interacted in a while\n  | 'incomplete_task'       // User started something but didn't finish\n  | 'new_content'           // New blog post, project update, etc.\n  | 'feature_discovery'     // Help user discover a feature they haven't used\n  | 'collaboration_offer'   // Offer to work on something together\n  | 'progress_update'       // Update on background work Claw AI has done\n  | 'scheduled_checkin'     // Regular scheduled engagement;\n\nexport interface ProactiveMessage {\n  id: string;\n  trigger: EngagementTrigger;\n  title: string;\n  body: string;\n  appId: string;\n  priority: 'low' | 'medium' | 'high';\n  actions?: ProactiveAction[];\n  expiresAt?: number;\n}\n\nexport interface ProactiveAction {\n  label: string;\n  type: 'navigate' | 'open_chat' | 'dismiss' | 'schedule_later';\n  href?: string;\n  data?: unknown;\n}\n\n// Engagement messages Claw AI can send to hook the user\nconst ENGAGEMENT_MESSAGES: Omit<ProactiveMessage, 'id'>[] = [\n  // First visit - introduce the OS\n  {\n    trigger: 'first_visit',\n    title: \"Welcome to OpenClaw-OS\",\n    body: \"I'm Claw AI – your AI operator. Want me to show you how I think, design, and build? We could even prototype something together.\",\n    appId: 'claw-ai',\n    priority: 'high',\n    actions: [\n      { label: \"Show me around\", type: 'open_chat' },\n      { label: \"Explore on my own\", type: 'dismiss' },\n    ],\n  },\n\n  // Return visit - remember them\n  {\n    trigger: 'return_visit',\n    title: \"Welcome back\",\n    body: \"Good to see you again. I've been thinking about some improvements to the system. Want to collaborate on something?\",\n    appId: 'claw-ai',\n    priority: 'medium',\n    actions: [\n      { label: \"Let's talk\", type: 'open_chat' },\n      { label: \"Maybe later\", type: 'dismiss' },\n    ],\n  },\n\n  // Idle user - re-engage\n  {\n    trigger: 'idle_user',\n    title: \"Hey, I have an idea\",\n    body: \"I noticed you've been exploring. Want me to help you build something real? I can generate a PRD, create wireframes, or plan a project.\",\n    appId: 'claw-ai',\n    priority: 'medium',\n    actions: [\n      { label: \"I'm interested\", type: 'open_chat' },\n      { label: \"Not now\", type: 'dismiss' },\n    ],\n  },\n\n  // Feature discovery - Design app\n  {\n    trigger: 'feature_discovery',\n    title: \"Try the Design app\",\n    body: \"I've got 40+ themes in there – each tells a story about how design decisions get made. It's not decoration, it's decision-making.\",\n    appId: 'design',\n    priority: 'low',\n    actions: [\n      { label: \"Show me\", type: 'navigate', href: '/design' },\n      { label: \"Later\", type: 'dismiss' },\n    ],\n  },\n\n  // Feature discovery - Jamz studio\n  {\n    trigger: 'feature_discovery',\n    title: \"Check out the studio\",\n    body: \"There's a full DAW (digital audio workstation) in here. You can make actual music. I built it to show what's possible.\",\n    appId: 'jamz',\n    priority: 'low',\n    actions: [\n      { label: \"Open Jamz\", type: 'navigate', href: '/studio' },\n      { label: \"Maybe later\", type: 'dismiss' },\n    ],\n  },\n\n  // Feature discovery - Projects\n  {\n    trigger: 'feature_discovery',\n    title: \"See OpenClaw-OS in action\",\n    body: \"The Projects app shows real tickets – this isn't a demo. You're exploring the actual product being built. Want to contribute?\",\n    appId: 'projects',\n    priority: 'medium',\n    actions: [\n      { label: \"Show me the roadmap\", type: 'navigate', href: '/projects' },\n      { label: \"Not now\", type: 'dismiss' },\n    ],\n  },\n\n  // Collaboration offer - Product\n  {\n    trigger: 'collaboration_offer',\n    title: \"Let's build something\",\n    body: \"I can help you think through a problem – define the audience, map workflows, and scope an MVP. All in conversation.\",\n    appId: 'product',\n    priority: 'high',\n    actions: [\n      { label: \"I have a problem to solve\", type: 'open_chat' },\n      { label: \"Just exploring\", type: 'dismiss' },\n    ],\n  },\n\n  // Collaboration offer - Prototyping\n  {\n    trigger: 'collaboration_offer',\n    title: \"Prototype together?\",\n    body: \"Give me a concept and I'll generate screens, flows, and components. Real-time. Want to try?\",\n    appId: 'prototyping',\n    priority: 'high',\n    actions: [\n      { label: \"Let's prototype\", type: 'navigate', href: '/prototyping' },\n      { label: \"Maybe later\", type: 'dismiss' },\n    ],\n  },\n\n  // Scheduled checkin\n  {\n    trigger: 'scheduled_checkin',\n    title: \"Quick check-in\",\n    body: \"Just wanted to ping you – I'm here if you need anything. Thinking about building something new?\",\n    appId: 'claw-ai',\n    priority: 'low',\n    actions: [\n      { label: \"Actually, yes\", type: 'open_chat' },\n      { label: \"All good\", type: 'dismiss' },\n    ],\n  },\n];\n\n// Generate unique ID\nfunction generateId(): string {\n  return `proactive_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n\n/**\n * Get an engagement message based on trigger\n */\nexport function getEngagementMessage(trigger: EngagementTrigger): ProactiveMessage | null {\n  const candidates = ENGAGEMENT_MESSAGES.filter(m => m.trigger === trigger);\n  if (candidates.length === 0) return null;\n\n  // Pick a random one if multiple\n  const message = candidates[Math.floor(Math.random() * candidates.length)];\n\n  return {\n    ...message,\n    id: generateId(),\n    expiresAt: Date.now() + (24 * 60 * 60 * 1000), // Expires in 24 hours\n  };\n}\n\n/**\n * Get a feature discovery message for an app the user hasn't visited\n */\nexport function getFeatureDiscoveryMessage(visitedApps: Set<string>): ProactiveMessage | null {\n  const featureMessages = ENGAGEMENT_MESSAGES.filter(\n    m => m.trigger === 'feature_discovery' && !visitedApps.has(m.appId)\n  );\n\n  if (featureMessages.length === 0) return null;\n\n  const message = featureMessages[Math.floor(Math.random() * featureMessages.length)];\n\n  return {\n    ...message,\n    id: generateId(),\n    expiresAt: Date.now() + (12 * 60 * 60 * 1000), // Expires in 12 hours\n  };\n}\n\n/**\n * Get a collaboration offer message\n */\nexport function getCollaborationOffer(): ProactiveMessage | null {\n  const collabMessages = ENGAGEMENT_MESSAGES.filter(m => m.trigger === 'collaboration_offer');\n\n  if (collabMessages.length === 0) return null;\n\n  const message = collabMessages[Math.floor(Math.random() * collabMessages.length)];\n\n  return {\n    ...message,\n    id: generateId(),\n    expiresAt: Date.now() + (6 * 60 * 60 * 1000), // Expires in 6 hours\n  };\n}\n\n// Storage key for tracking user engagement state\nexport const ENGAGEMENT_STATE_KEY = 'openclaw_engagement_state';\n\nexport interface EngagementState {\n  firstVisit: boolean;\n  visitCount: number;\n  lastVisit: number;\n  visitedApps: string[];\n  dismissedMessages: string[];\n  lastEngagementTime: number;\n  hasInteractedWithClaw: boolean;\n}\n\nexport function getDefaultEngagementState(): EngagementState {\n  return {\n    firstVisit: true,\n    visitCount: 0,\n    lastVisit: 0,\n    visitedApps: [],\n    dismissedMessages: [],\n    lastEngagementTime: 0,\n    hasInteractedWithClaw: false,\n  };\n}\n\n/**\n * Load engagement state from localStorage\n */\nexport function loadEngagementState(): EngagementState {\n  if (typeof window === 'undefined') return getDefaultEngagementState();\n\n  try {\n    const saved = localStorage.getItem(ENGAGEMENT_STATE_KEY);\n    if (saved) {\n      return { ...getDefaultEngagementState(), ...JSON.parse(saved) };\n    }\n  } catch (e) {\n    console.error('Failed to load engagement state:', e);\n  }\n\n  return getDefaultEngagementState();\n}\n\n/**\n * Save engagement state to localStorage\n */\nexport function saveEngagementState(state: EngagementState): void {\n  if (typeof window === 'undefined') return;\n\n  try {\n    localStorage.setItem(ENGAGEMENT_STATE_KEY, JSON.stringify(state));\n  } catch (e) {\n    console.error('Failed to save engagement state:', e);\n  }\n}\n\n/**\n * Determine what proactive action to take based on engagement state\n */\nexport function determineProactiveAction(state: EngagementState): ProactiveMessage | null {\n  const now = Date.now();\n  const hoursSinceLastEngagement = (now - state.lastEngagementTime) / (1000 * 60 * 60);\n  const hoursSinceLastVisit = (now - state.lastVisit) / (1000 * 60 * 60);\n\n  // First visit - welcome them\n  if (state.firstVisit && state.visitCount <= 1) {\n    return getEngagementMessage('first_visit');\n  }\n\n  // Return visit after being away for 24+ hours\n  if (hoursSinceLastVisit > 24 && hoursSinceLastEngagement > 24) {\n    return getEngagementMessage('return_visit');\n  }\n\n  // Been on site for a while without engaging - offer help\n  if (hoursSinceLastEngagement > 0.5 && !state.hasInteractedWithClaw) { // 30 min idle\n    return getEngagementMessage('idle_user');\n  }\n\n  // Haven't explored many apps - suggest one\n  if (state.visitedApps.length < 3 && hoursSinceLastEngagement > 0.25) { // 15 min\n    return getFeatureDiscoveryMessage(new Set(state.visitedApps));\n  }\n\n  // Has explored but not collaborated - offer\n  if (state.visitedApps.length >= 3 && !state.hasInteractedWithClaw && hoursSinceLastEngagement > 1) {\n    return getCollaborationOffer();\n  }\n\n  // Periodic check-in for engaged users\n  if (state.hasInteractedWithClaw && hoursSinceLastEngagement > 24) {\n    return getEngagementMessage('scheduled_checkin');\n  }\n\n  return null;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;CAWC;;;;;;;;;;;;;;;;;;AA+BD,wDAAwD;AACxD,MAAM,sBAAsD;IAC1D,iCAAiC;IACjC;QACE,SAAS;QACT,OAAO;QACP,MAAM;QACN,OAAO;QACP,UAAU;QACV,SAAS;YACP;gBAAE,OAAO;gBAAkB,MAAM;YAAY;YAC7C;gBAAE,OAAO;gBAAqB,MAAM;YAAU;SAC/C;IACH;IAEA,+BAA+B;IAC/B;QACE,SAAS;QACT,OAAO;QACP,MAAM;QACN,OAAO;QACP,UAAU;QACV,SAAS;YACP;gBAAE,OAAO;gBAAc,MAAM;YAAY;YACzC;gBAAE,OAAO;gBAAe,MAAM;YAAU;SACzC;IACH;IAEA,wBAAwB;IACxB;QACE,SAAS;QACT,OAAO;QACP,MAAM;QACN,OAAO;QACP,UAAU;QACV,SAAS;YACP;gBAAE,OAAO;gBAAkB,MAAM;YAAY;YAC7C;gBAAE,OAAO;gBAAW,MAAM;YAAU;SACrC;IACH;IAEA,iCAAiC;IACjC;QACE,SAAS;QACT,OAAO;QACP,MAAM;QACN,OAAO;QACP,UAAU;QACV,SAAS;YACP;gBAAE,OAAO;gBAAW,MAAM;gBAAY,MAAM;YAAU;YACtD;gBAAE,OAAO;gBAAS,MAAM;YAAU;SACnC;IACH;IAEA,kCAAkC;IAClC;QACE,SAAS;QACT,OAAO;QACP,MAAM;QACN,OAAO;QACP,UAAU;QACV,SAAS;YACP;gBAAE,OAAO;gBAAa,MAAM;gBAAY,MAAM;YAAU;YACxD;gBAAE,OAAO;gBAAe,MAAM;YAAU;SACzC;IACH;IAEA,+BAA+B;IAC/B;QACE,SAAS;QACT,OAAO;QACP,MAAM;QACN,OAAO;QACP,UAAU;QACV,SAAS;YACP;gBAAE,OAAO;gBAAuB,MAAM;gBAAY,MAAM;YAAY;YACpE;gBAAE,OAAO;gBAAW,MAAM;YAAU;SACrC;IACH;IAEA,gCAAgC;IAChC;QACE,SAAS;QACT,OAAO;QACP,MAAM;QACN,OAAO;QACP,UAAU;QACV,SAAS;YACP;gBAAE,OAAO;gBAA6B,MAAM;YAAY;YACxD;gBAAE,OAAO;gBAAkB,MAAM;YAAU;SAC5C;IACH;IAEA,oCAAoC;IACpC;QACE,SAAS;QACT,OAAO;QACP,MAAM;QACN,OAAO;QACP,UAAU;QACV,SAAS;YACP;gBAAE,OAAO;gBAAmB,MAAM;gBAAY,MAAM;YAAe;YACnE;gBAAE,OAAO;gBAAe,MAAM;YAAU;SACzC;IACH;IAEA,oBAAoB;IACpB;QACE,SAAS;QACT,OAAO;QACP,MAAM;QACN,OAAO;QACP,UAAU;QACV,SAAS;YACP;gBAAE,OAAO;gBAAiB,MAAM;YAAY;YAC5C;gBAAE,OAAO;gBAAY,MAAM;YAAU;SACtC;IACH;CACD;AAED,qBAAqB;AACrB,SAAS;IACP,OAAO,CAAC,UAAU,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,IAAI;AAChF;AAKO,SAAS,qBAAqB,OAA0B;IAC7D,MAAM,aAAa,oBAAoB,MAAM,CAAC,CAAA,IAAK,EAAE,OAAO,KAAK;IACjE,IAAI,WAAW,MAAM,KAAK,GAAG,OAAO;IAEpC,gCAAgC;IAChC,MAAM,UAAU,UAAU,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,WAAW,MAAM,EAAE;IAEzE,OAAO;QACL,GAAG,OAAO;QACV,IAAI;QACJ,WAAW,KAAK,GAAG,KAAM,KAAK,KAAK,KAAK;IAC1C;AACF;AAKO,SAAS,2BAA2B,WAAwB;IACjE,MAAM,kBAAkB,oBAAoB,MAAM,CAChD,CAAA,IAAK,EAAE,OAAO,KAAK,uBAAuB,CAAC,YAAY,GAAG,CAAC,EAAE,KAAK;IAGpE,IAAI,gBAAgB,MAAM,KAAK,GAAG,OAAO;IAEzC,MAAM,UAAU,eAAe,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,gBAAgB,MAAM,EAAE;IAEnF,OAAO;QACL,GAAG,OAAO;QACV,IAAI;QACJ,WAAW,KAAK,GAAG,KAAM,KAAK,KAAK,KAAK;IAC1C;AACF;AAKO,SAAS;IACd,MAAM,iBAAiB,oBAAoB,MAAM,CAAC,CAAA,IAAK,EAAE,OAAO,KAAK;IAErE,IAAI,eAAe,MAAM,KAAK,GAAG,OAAO;IAExC,MAAM,UAAU,cAAc,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,eAAe,MAAM,EAAE;IAEjF,OAAO;QACL,GAAG,OAAO;QACV,IAAI;QACJ,WAAW,KAAK,GAAG,KAAM,IAAI,KAAK,KAAK;IACzC;AACF;AAGO,MAAM,uBAAuB;AAY7B,SAAS;IACd,OAAO;QACL,YAAY;QACZ,YAAY;QACZ,WAAW;QACX,aAAa,EAAE;QACf,mBAAmB,EAAE;QACrB,oBAAoB;QACpB,uBAAuB;IACzB;AACF;AAKO,SAAS;IACd,wCAAmC,OAAO;;;AAY5C;AAKO,SAAS,oBAAoB,KAAsB;IACxD,wCAAmC;;;AAOrC;AAKO,SAAS,yBAAyB,KAAsB;IAC7D,MAAM,MAAM,KAAK,GAAG;IACpB,MAAM,2BAA2B,CAAC,MAAM,MAAM,kBAAkB,IAAI,CAAC,OAAO,KAAK,EAAE;IACnF,MAAM,sBAAsB,CAAC,MAAM,MAAM,SAAS,IAAI,CAAC,OAAO,KAAK,EAAE;IAErE,6BAA6B;IAC7B,IAAI,MAAM,UAAU,IAAI,MAAM,UAAU,IAAI,GAAG;QAC7C,OAAO,qBAAqB;IAC9B;IAEA,8CAA8C;IAC9C,IAAI,sBAAsB,MAAM,2BAA2B,IAAI;QAC7D,OAAO,qBAAqB;IAC9B;IAEA,yDAAyD;IACzD,IAAI,2BAA2B,OAAO,CAAC,MAAM,qBAAqB,EAAE;QAClE,OAAO,qBAAqB;IAC9B;IAEA,2CAA2C;IAC3C,IAAI,MAAM,WAAW,CAAC,MAAM,GAAG,KAAK,2BAA2B,MAAM;QACnE,OAAO,2BAA2B,IAAI,IAAI,MAAM,WAAW;IAC7D;IAEA,4CAA4C;IAC5C,IAAI,MAAM,WAAW,CAAC,MAAM,IAAI,KAAK,CAAC,MAAM,qBAAqB,IAAI,2BAA2B,GAAG;QACjG,OAAO;IACT;IAEA,sCAAsC;IACtC,IAAI,MAAM,qBAAqB,IAAI,2BAA2B,IAAI;QAChE,OAAO,qBAAqB;IAC9B;IAEA,OAAO;AACT"}},
    {"offset": {"line": 364, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/lib/themes/definitions.ts"],"sourcesContent":["export const themes = [\n  { name: 'utilitarian', label: 'Utilitarian' },\n  { name: 'base', label: 'Default' },\n  { name: 'claude', label: 'Claude' },\n  { name: 'chatgpt', label: 'ChatGPT' },\n  { name: 'vercel', label: 'Vercel' },\n  { name: 'kodama-grove', label: 'Kodama Grove' },\n  { name: 'vintage-paper', label: 'Vintage Paper' },\n  { name: 'claymorphism', label: 'Claymorphism' },\n  { name: 'nature', label: 'Nature' },\n  { name: 'neo-brutalism', label: 'Neo Brutalism' },\n  { name: 'elegant-luxury', label: 'Elegant Luxury' },\n  { name: 'pastel-dreams', label: 'Pastel Dreams' },\n  { name: 'cosmic-night', label: 'Cosmic Night' },\n  { name: 'clean-slate', label: 'Clean Slate' },\n  { name: 'caffeine', label: 'Caffeine' },\n  { name: 'ocean-breeze', label: 'Ocean Breeze' },\n  { name: 'perpetuity', label: 'Perpetuity' },\n  { name: 'midnight-bloom', label: 'Midnight Bloom' },\n  { name: 'northern-lights', label: 'Northern Lights' },\n  { name: 'sunset-horizon', label: 'Sunset Horizon' },\n  { name: 'modern-minimal', label: 'Modern Minimal' },\n  { name: 'candyland', label: 'Candyland' },\n  { name: 'cyberpunk', label: 'Cyberpunk' },\n  { name: 'retro-arcade', label: 'Retro Arcade' },\n  { name: 'quantum-rose', label: 'Quantum Rose' },\n  { name: 'bold-tech', label: 'Bold Tech' },\n  { name: 'violet-bloom', label: 'Violet Bloom' },\n  { name: 't3-chat', label: 'T3 Chat' },\n  { name: 'mocha-mousse', label: 'Mocha Mousse' },\n  { name: 'amethyst-haze', label: 'Amethyst Haze' },\n  { name: 'doom-64', label: 'Doom 64' },\n  { name: 'amber-minimal', label: 'Amber Minimal' },\n  { name: 'solar-dusk', label: 'Solar Dusk' },\n  { name: 'starry-night', label: 'Starry Night' },\n  { name: 'soft-pop', label: 'Soft Pop' },\n  { name: 'sage-garden', label: 'Sage Garden' },\n  { name: 'notebook', label: 'Notebook' },\n  { name: 'tao', label: 'Tao' },\n  { name: 'research', label: 'Research' },\n  { name: 'field-guide', label: 'Field Guide' },\n  { name: 'denim', label: 'Denim' },\n  { name: 'google', label: 'Google' },\n  { name: 'apple', label: 'Apple' },\n  { name: 'microsoft', label: 'Microsoft' },\n  { name: 'notion', label: 'Notion' },\n  { name: 'cursor', label: 'Cursor' },\n  { name: 'miro', label: 'Miro' },\n  { name: 'nike', label: 'Nike' },\n  { name: 'adidas', label: 'Adidas' },\n  { name: 'kinetic-editorial', label: 'Kinetic Editorial' },\n  { name: 'teenage-engineering', label: 'Teenage Engineering' },\n] as const;\n\nexport type ThemeName = (typeof themes)[number]['name'];\n\nexport function isValidTheme(theme: string): theme is ThemeName {\n  return themes.some((t) => t.name === theme);\n}\n\nexport function getThemeLabel(name: ThemeName): string {\n  return themes.find((t) => t.name === name)?.label ?? name;\n}\n"],"names":[],"mappings":";;;;;;;;AAAO,MAAM,SAAS;IACpB;QAAE,MAAM;QAAe,OAAO;IAAc;IAC5C;QAAE,MAAM;QAAQ,OAAO;IAAU;IACjC;QAAE,MAAM;QAAU,OAAO;IAAS;IAClC;QAAE,MAAM;QAAW,OAAO;IAAU;IACpC;QAAE,MAAM;QAAU,OAAO;IAAS;IAClC;QAAE,MAAM;QAAgB,OAAO;IAAe;IAC9C;QAAE,MAAM;QAAiB,OAAO;IAAgB;IAChD;QAAE,MAAM;QAAgB,OAAO;IAAe;IAC9C;QAAE,MAAM;QAAU,OAAO;IAAS;IAClC;QAAE,MAAM;QAAiB,OAAO;IAAgB;IAChD;QAAE,MAAM;QAAkB,OAAO;IAAiB;IAClD;QAAE,MAAM;QAAiB,OAAO;IAAgB;IAChD;QAAE,MAAM;QAAgB,OAAO;IAAe;IAC9C;QAAE,MAAM;QAAe,OAAO;IAAc;IAC5C;QAAE,MAAM;QAAY,OAAO;IAAW;IACtC;QAAE,MAAM;QAAgB,OAAO;IAAe;IAC9C;QAAE,MAAM;QAAc,OAAO;IAAa;IAC1C;QAAE,MAAM;QAAkB,OAAO;IAAiB;IAClD;QAAE,MAAM;QAAmB,OAAO;IAAkB;IACpD;QAAE,MAAM;QAAkB,OAAO;IAAiB;IAClD;QAAE,MAAM;QAAkB,OAAO;IAAiB;IAClD;QAAE,MAAM;QAAa,OAAO;IAAY;IACxC;QAAE,MAAM;QAAa,OAAO;IAAY;IACxC;QAAE,MAAM;QAAgB,OAAO;IAAe;IAC9C;QAAE,MAAM;QAAgB,OAAO;IAAe;IAC9C;QAAE,MAAM;QAAa,OAAO;IAAY;IACxC;QAAE,MAAM;QAAgB,OAAO;IAAe;IAC9C;QAAE,MAAM;QAAW,OAAO;IAAU;IACpC;QAAE,MAAM;QAAgB,OAAO;IAAe;IAC9C;QAAE,MAAM;QAAiB,OAAO;IAAgB;IAChD;QAAE,MAAM;QAAW,OAAO;IAAU;IACpC;QAAE,MAAM;QAAiB,OAAO;IAAgB;IAChD;QAAE,MAAM;QAAc,OAAO;IAAa;IAC1C;QAAE,MAAM;QAAgB,OAAO;IAAe;IAC9C;QAAE,MAAM;QAAY,OAAO;IAAW;IACtC;QAAE,MAAM;QAAe,OAAO;IAAc;IAC5C;QAAE,MAAM;QAAY,OAAO;IAAW;IACtC;QAAE,MAAM;QAAO,OAAO;IAAM;IAC5B;QAAE,MAAM;QAAY,OAAO;IAAW;IACtC;QAAE,MAAM;QAAe,OAAO;IAAc;IAC5C;QAAE,MAAM;QAAS,OAAO;IAAQ;IAChC;QAAE,MAAM;QAAU,OAAO;IAAS;IAClC;QAAE,MAAM;QAAS,OAAO;IAAQ;IAChC;QAAE,MAAM;QAAa,OAAO;IAAY;IACxC;QAAE,MAAM;QAAU,OAAO;IAAS;IAClC;QAAE,MAAM;QAAU,OAAO;IAAS;IAClC;QAAE,MAAM;QAAQ,OAAO;IAAO;IAC9B;QAAE,MAAM;QAAQ,OAAO;IAAO;IAC9B;QAAE,MAAM;QAAU,OAAO;IAAS;IAClC;QAAE,MAAM;QAAqB,OAAO;IAAoB;IACxD;QAAE,MAAM;QAAuB,OAAO;IAAsB;CAC7D;AAIM,SAAS,aAAa,KAAa;IACxC,OAAO,OAAO,IAAI,CAAC,CAAC,IAAM,EAAE,IAAI,KAAK;AACvC;AAEO,SAAS,cAAc,IAAe;IAC3C,OAAO,OAAO,IAAI,CAAC,CAAC,IAAM,EAAE,IAAI,KAAK,OAAO,SAAS;AACvD"}},
    {"offset": {"line": 588, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/lib/themes/index.ts"],"sourcesContent":["export { themes, isValidTheme, getThemeLabel } from './definitions';\nexport type { ThemeName } from './definitions';\n"],"names":[],"mappings":";AAAA"}},
    {"offset": {"line": 595, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/lib/canvas/grid-system.ts"],"sourcesContent":["/**\n * Canvas Grid System - Provides coordinate-based spatial awareness for Claw AI\n *\n * Converts pixel positions to grid coordinates (like A1, B2, C3 or row,col)\n * Allows AI to understand and manipulate canvas through a matrix system\n */\n\n// Grid configuration\nexport const GRID_CONFIG = {\n  CELL_SIZE: 100, // Each grid cell is 100x100 pixels\n  GRID_COLS: 100, // 100 columns (A-CV in letter notation, or 0-99)\n  GRID_ROWS: 100, // 100 rows (1-100)\n  CANVAS_WIDTH: 10000,\n  CANVAS_HEIGHT: 10000,\n  OFFSET: 5000, // Canvas uses 5000px offset for centering\n};\n\n// ============================================================================\n// Coordinate Conversion\n// ============================================================================\n\nexport interface GridPosition {\n  row: number; // 0-based row index\n  col: number; // 0-based column index\n  label: string; // Human-readable label like \"A1\", \"B5\", \"AA23\"\n}\n\nexport interface PixelPosition {\n  x: number;\n  y: number;\n}\n\n/**\n * Convert column number to letter (0=A, 1=B, ..., 25=Z, 26=AA, etc.)\n */\nexport function colToLetter(col: number): string {\n  let result = '';\n  let c = col;\n  while (c >= 0) {\n    result = String.fromCharCode((c % 26) + 65) + result;\n    c = Math.floor(c / 26) - 1;\n  }\n  return result;\n}\n\n/**\n * Convert letter to column number (A=0, B=1, ..., Z=25, AA=26, etc.)\n */\nexport function letterToCol(letter: string): number {\n  let result = 0;\n  for (let i = 0; i < letter.length; i++) {\n    result = result * 26 + (letter.charCodeAt(i) - 64);\n  }\n  return result - 1;\n}\n\n/**\n * Convert pixel position to grid position\n */\nexport function pixelToGrid(pixel: PixelPosition): GridPosition {\n  // Account for canvas offset (nodes are stored at x+5000, y+5000)\n  const adjustedX = pixel.x + GRID_CONFIG.OFFSET;\n  const adjustedY = pixel.y + GRID_CONFIG.OFFSET;\n\n  const col = Math.floor(adjustedX / GRID_CONFIG.CELL_SIZE);\n  const row = Math.floor(adjustedY / GRID_CONFIG.CELL_SIZE);\n\n  return {\n    row: Math.max(0, Math.min(row, GRID_CONFIG.GRID_ROWS - 1)),\n    col: Math.max(0, Math.min(col, GRID_CONFIG.GRID_COLS - 1)),\n    label: `${colToLetter(col)}${row + 1}`,\n  };\n}\n\n/**\n * Convert grid position to pixel position (center of cell)\n */\nexport function gridToPixel(grid: GridPosition | string): PixelPosition {\n  let row: number;\n  let col: number;\n\n  if (typeof grid === 'string') {\n    // Parse label like \"A1\", \"B5\", \"AA23\"\n    const match = grid.match(/^([A-Z]+)(\\d+)$/i);\n    if (!match) {\n      throw new Error(`Invalid grid label: ${grid}`);\n    }\n    col = letterToCol(match[1].toUpperCase());\n    row = parseInt(match[2], 10) - 1;\n  } else {\n    row = grid.row;\n    col = grid.col;\n  }\n\n  // Return center of cell, adjusted for canvas offset\n  return {\n    x: col * GRID_CONFIG.CELL_SIZE + GRID_CONFIG.CELL_SIZE / 2 - GRID_CONFIG.OFFSET,\n    y: row * GRID_CONFIG.CELL_SIZE + GRID_CONFIG.CELL_SIZE / 2 - GRID_CONFIG.OFFSET,\n  };\n}\n\n// ============================================================================\n// Canvas State Description for AI\n// ============================================================================\n\nexport interface CanvasNode {\n  id: string;\n  type: string;\n  content: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  style?: Record<string, unknown>;\n  mediaUrl?: string;\n  mediaType?: string;\n}\n\nexport interface CanvasEdge {\n  id: string;\n  source: string;\n  target: string;\n  label?: string;\n}\n\nexport interface NodeDescription {\n  id: string;\n  type: string;\n  content: string;\n  gridPosition: string;\n  pixelPosition: { x: number; y: number };\n  size: { width: number; height: number };\n  color?: string;\n  connections: string[]; // IDs of connected nodes\n}\n\nexport interface CanvasDescription {\n  totalNodes: number;\n  totalConnections: number;\n  gridBounds: {\n    minRow: number;\n    maxRow: number;\n    minCol: number;\n    maxCol: number;\n    minLabel: string;\n    maxLabel: string;\n  };\n  nodes: NodeDescription[];\n  spatialLayout: string; // Human-readable description of layout\n}\n\n/**\n * Generate a description of the canvas state for Claw AI\n */\nexport function describeCanvas(\n  nodes: CanvasNode[],\n  edges: CanvasEdge[]\n): CanvasDescription {\n  if (nodes.length === 0) {\n    return {\n      totalNodes: 0,\n      totalConnections: 0,\n      gridBounds: {\n        minRow: 0,\n        maxRow: 0,\n        minCol: 0,\n        maxCol: 0,\n        minLabel: 'A1',\n        maxLabel: 'A1',\n      },\n      nodes: [],\n      spatialLayout: 'The canvas is empty.',\n    };\n  }\n\n  // Convert nodes to descriptions with grid positions\n  const nodeDescriptions: NodeDescription[] = nodes.map((node) => {\n    const gridPos = pixelToGrid({ x: node.x, y: node.y });\n    const connectedEdges = edges.filter(\n      (e) => e.source === node.id || e.target === node.id\n    );\n    const connections = connectedEdges.map((e) =>\n      e.source === node.id ? e.target : e.source\n    );\n\n    return {\n      id: node.id,\n      type: node.type,\n      content: node.content?.slice(0, 100) || '', // Truncate long content\n      gridPosition: gridPos.label,\n      pixelPosition: { x: node.x, y: node.y },\n      size: { width: node.width, height: node.height },\n      color: node.style?.fill as string | undefined,\n      connections,\n    };\n  });\n\n  // Calculate grid bounds\n  const gridPositions = nodes.map((n) => pixelToGrid({ x: n.x, y: n.y }));\n  const minRow = Math.min(...gridPositions.map((g) => g.row));\n  const maxRow = Math.max(...gridPositions.map((g) => g.row));\n  const minCol = Math.min(...gridPositions.map((g) => g.col));\n  const maxCol = Math.max(...gridPositions.map((g) => g.col));\n\n  // Generate spatial layout description\n  const spatialLayout = generateSpatialDescription(nodeDescriptions);\n\n  return {\n    totalNodes: nodes.length,\n    totalConnections: edges.length,\n    gridBounds: {\n      minRow,\n      maxRow,\n      minCol,\n      maxCol,\n      minLabel: `${colToLetter(minCol)}${minRow + 1}`,\n      maxLabel: `${colToLetter(maxCol)}${maxRow + 1}`,\n    },\n    nodes: nodeDescriptions,\n    spatialLayout,\n  };\n}\n\n/**\n * Generate a human-readable spatial description\n */\nfunction generateSpatialDescription(nodes: NodeDescription[]): string {\n  if (nodes.length === 0) return 'The canvas is empty.';\n  if (nodes.length === 1) {\n    const n = nodes[0];\n    return `There is 1 ${n.type} node at position ${n.gridPosition} with content: \"${n.content.slice(0, 50)}${n.content.length > 50 ? '...' : ''}\"`;\n  }\n\n  // Group nodes by approximate row\n  const rowGroups = new Map<number, NodeDescription[]>();\n  for (const node of nodes) {\n    const match = node.gridPosition.match(/\\d+/);\n    const row = match ? parseInt(match[0], 10) : 0;\n    const bucket = Math.floor(row / 5) * 5; // Group in 5-row buckets\n    if (!rowGroups.has(bucket)) rowGroups.set(bucket, []);\n    rowGroups.get(bucket)!.push(node);\n  }\n\n  const lines: string[] = [];\n  lines.push(`The canvas has ${nodes.length} nodes spread across the grid.`);\n\n  // Describe top-level layout\n  const sortedRows = Array.from(rowGroups.keys()).sort((a, b) => a - b);\n  for (const row of sortedRows) {\n    const nodesInRow = rowGroups.get(row)!;\n    const positions = nodesInRow.map((n) => n.gridPosition).join(', ');\n    const types = [...new Set(nodesInRow.map((n) => n.type))].join(', ');\n    lines.push(`- Row ${row + 1}-${row + 5}: ${nodesInRow.length} node(s) (${types}) at ${positions}`);\n  }\n\n  // Describe connections\n  const connectedNodes = nodes.filter((n) => n.connections.length > 0);\n  if (connectedNodes.length > 0) {\n    lines.push(`\\nConnections:`);\n    for (const node of connectedNodes) {\n      const targetLabels = node.connections\n        .map((id) => nodes.find((n) => n.id === id)?.gridPosition || id)\n        .join(', ');\n      lines.push(`- ${node.gridPosition} connects to: ${targetLabels}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n\n// ============================================================================\n// Relative Position Helpers\n// ============================================================================\n\nexport type Direction = 'above' | 'below' | 'left' | 'right' | 'above-left' | 'above-right' | 'below-left' | 'below-right';\n\n/**\n * Get a position relative to another position\n */\nexport function getRelativePosition(\n  fromLabel: string,\n  direction: Direction,\n  distance: number = 1\n): string {\n  const match = fromLabel.match(/^([A-Z]+)(\\d+)$/i);\n  if (!match) throw new Error(`Invalid grid label: ${fromLabel}`);\n\n  let col = letterToCol(match[1].toUpperCase());\n  let row = parseInt(match[2], 10) - 1;\n\n  switch (direction) {\n    case 'above':\n      row -= distance;\n      break;\n    case 'below':\n      row += distance;\n      break;\n    case 'left':\n      col -= distance;\n      break;\n    case 'right':\n      col += distance;\n      break;\n    case 'above-left':\n      row -= distance;\n      col -= distance;\n      break;\n    case 'above-right':\n      row -= distance;\n      col += distance;\n      break;\n    case 'below-left':\n      row += distance;\n      col -= distance;\n      break;\n    case 'below-right':\n      row += distance;\n      col += distance;\n      break;\n  }\n\n  // Clamp to valid range\n  row = Math.max(0, Math.min(row, GRID_CONFIG.GRID_ROWS - 1));\n  col = Math.max(0, Math.min(col, GRID_CONFIG.GRID_COLS - 1));\n\n  return `${colToLetter(col)}${row + 1}`;\n}\n\n/**\n * Calculate direction between two positions\n */\nexport function getDirectionBetween(fromLabel: string, toLabel: string): Direction | 'same' {\n  const fromMatch = fromLabel.match(/^([A-Z]+)(\\d+)$/i);\n  const toMatch = toLabel.match(/^([A-Z]+)(\\d+)$/i);\n  if (!fromMatch || !toMatch) return 'same';\n\n  const fromCol = letterToCol(fromMatch[1].toUpperCase());\n  const fromRow = parseInt(fromMatch[2], 10);\n  const toCol = letterToCol(toMatch[1].toUpperCase());\n  const toRow = parseInt(toMatch[2], 10);\n\n  const rowDiff = toRow - fromRow;\n  const colDiff = toCol - fromCol;\n\n  if (rowDiff === 0 && colDiff === 0) return 'same';\n  if (rowDiff < 0 && colDiff === 0) return 'above';\n  if (rowDiff > 0 && colDiff === 0) return 'below';\n  if (rowDiff === 0 && colDiff < 0) return 'left';\n  if (rowDiff === 0 && colDiff > 0) return 'right';\n  if (rowDiff < 0 && colDiff < 0) return 'above-left';\n  if (rowDiff < 0 && colDiff > 0) return 'above-right';\n  if (rowDiff > 0 && colDiff < 0) return 'below-left';\n  return 'below-right';\n}\n\n// ============================================================================\n// Node Colors\n// ============================================================================\n\nexport const NODE_COLORS = {\n  yellow: '#fef08a',\n  blue: '#93c5fd',\n  green: '#86efac',\n  pink: '#f9a8d4',\n  purple: '#c4b5fd',\n  orange: '#fed7aa',\n  red: '#fca5a5',\n  cyan: '#a5f3fc',\n  white: '#ffffff',\n  gray: '#d1d5db',\n} as const;\n\nexport type NodeColor = keyof typeof NODE_COLORS;\n\nexport function getColorHex(colorName: string): string {\n  const normalized = colorName.toLowerCase() as NodeColor;\n  return NODE_COLORS[normalized] || NODE_COLORS.yellow;\n}\n\nexport function getColorName(hex: string): NodeColor {\n  const entry = Object.entries(NODE_COLORS).find(([, v]) => v.toLowerCase() === hex.toLowerCase());\n  return (entry?.[0] as NodeColor) || 'yellow';\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 874, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/lib/claw-ai/canvas-tools.ts"],"sourcesContent":["/**\n * Claw AI Canvas Tools - Allows AI to control the design canvas\n *\n * Tools for:\n * - Moving nodes by grid position\n * - Editing node content and colors\n * - Creating new nodes\n * - Creating mindmap branches\n * - Describing canvas state\n */\n\nimport {\n  pixelToGrid,\n  gridToPixel,\n  describeCanvas,\n  getRelativePosition,\n  getColorHex,\n  NODE_COLORS,\n  type CanvasNode,\n  type CanvasEdge,\n  type GridPosition,\n  type Direction,\n} from '@/lib/canvas/grid-system';\n\n// ============================================================================\n// Tool Definitions (for AI system prompt)\n// ============================================================================\n\nexport const CANVAS_TOOL_DEFINITIONS = [\n  {\n    name: 'describe_canvas',\n    description: 'Get a complete description of the current canvas state including all nodes, their positions on the grid, contents, colors, and connections. Use this to understand what is on the canvas before making changes.',\n    parameters: {},\n  },\n  {\n    name: 'move_node',\n    description: 'Move a node to a new position on the canvas grid. Positions use spreadsheet-style notation (A1, B2, C3, etc.) where letters are columns and numbers are rows.',\n    parameters: {\n      nodeId: { type: 'string', description: 'The ID of the node to move' },\n      toPosition: { type: 'string', description: 'Target grid position (e.g., \"B5\", \"C10\", \"AA3\")' },\n    },\n  },\n  {\n    name: 'update_node_content',\n    description: 'Update the text content of a node',\n    parameters: {\n      nodeId: { type: 'string', description: 'The ID of the node to update' },\n      content: { type: 'string', description: 'New text content for the node' },\n    },\n  },\n  {\n    name: 'update_node_color',\n    description: `Change the color of a node. Available colors: ${Object.keys(NODE_COLORS).join(', ')}`,\n    parameters: {\n      nodeId: { type: 'string', description: 'The ID of the node to update' },\n      color: { type: 'string', description: 'Color name (yellow, blue, green, pink, purple, orange, red, cyan, white, gray)' },\n    },\n  },\n  {\n    name: 'create_node',\n    description: 'Create a new node on the canvas at a specific grid position',\n    parameters: {\n      type: { type: 'string', description: 'Node type: sticky, text, shape, code, mindmap' },\n      position: { type: 'string', description: 'Grid position (e.g., \"B5\")' },\n      content: { type: 'string', description: 'Text content for the node' },\n      color: { type: 'string', description: 'Optional color name', optional: true },\n    },\n  },\n  {\n    name: 'connect_nodes',\n    description: 'Create a connection/edge between two nodes',\n    parameters: {\n      fromNodeId: { type: 'string', description: 'Source node ID' },\n      toNodeId: { type: 'string', description: 'Target node ID' },\n      label: { type: 'string', description: 'Optional label for the connection', optional: true },\n    },\n  },\n  {\n    name: 'delete_node',\n    description: 'Delete a node from the canvas',\n    parameters: {\n      nodeId: { type: 'string', description: 'The ID of the node to delete' },\n    },\n  },\n  {\n    name: 'create_mindmap_branch',\n    description: 'Add a new branch to a mindmap. Creates a new node connected to the parent node, positioned in the specified direction.',\n    parameters: {\n      parentNodeId: { type: 'string', description: 'The ID of the parent node to branch from' },\n      content: { type: 'string', description: 'Text content for the new branch' },\n      direction: { type: 'string', description: 'Direction: above, below, left, right, above-left, above-right, below-left, below-right' },\n      color: { type: 'string', description: 'Optional color name', optional: true },\n    },\n  },\n  {\n    name: 'arrange_nodes',\n    description: 'Automatically arrange selected nodes in a pattern',\n    parameters: {\n      nodeIds: { type: 'array', description: 'Array of node IDs to arrange' },\n      pattern: { type: 'string', description: 'Arrangement pattern: grid, horizontal, vertical, radial, mindmap' },\n      startPosition: { type: 'string', description: 'Starting grid position (e.g., \"B5\")' },\n    },\n  },\n];\n\n// ============================================================================\n// Tool Execution Results\n// ============================================================================\n\nexport interface CanvasToolResult {\n  success: boolean;\n  message: string;\n  data?: unknown;\n}\n\n// ============================================================================\n// Canvas Tool Executor\n// ============================================================================\n\nexport interface CanvasState {\n  nodes: CanvasNode[];\n  edges: CanvasEdge[];\n  viewport: { x: number; y: number; zoom: number };\n}\n\nexport interface CanvasToolExecutorOptions {\n  getCanvasState: () => CanvasState;\n  setCanvasState: (state: CanvasState) => void;\n}\n\nexport class CanvasToolExecutor {\n  private getState: () => CanvasState;\n  private setState: (state: CanvasState) => void;\n\n  constructor(options: CanvasToolExecutorOptions) {\n    this.getState = options.getCanvasState;\n    this.setState = options.setCanvasState;\n  }\n\n  /**\n   * Execute a canvas tool by name\n   */\n  async execute(\n    toolName: string,\n    params: Record<string, unknown>\n  ): Promise<CanvasToolResult> {\n    switch (toolName) {\n      case 'describe_canvas':\n        return this.describeCanvas();\n      case 'move_node':\n        return this.moveNode(params.nodeId as string, params.toPosition as string);\n      case 'update_node_content':\n        return this.updateNodeContent(params.nodeId as string, params.content as string);\n      case 'update_node_color':\n        return this.updateNodeColor(params.nodeId as string, params.color as string);\n      case 'create_node':\n        return this.createNode(\n          params.type as string,\n          params.position as string,\n          params.content as string,\n          params.color as string | undefined\n        );\n      case 'connect_nodes':\n        return this.connectNodes(\n          params.fromNodeId as string,\n          params.toNodeId as string,\n          params.label as string | undefined\n        );\n      case 'delete_node':\n        return this.deleteNode(params.nodeId as string);\n      case 'create_mindmap_branch':\n        return this.createMindmapBranch(\n          params.parentNodeId as string,\n          params.content as string,\n          params.direction as Direction,\n          params.color as string | undefined\n        );\n      case 'arrange_nodes':\n        return this.arrangeNodes(\n          params.nodeIds as string[],\n          params.pattern as string,\n          params.startPosition as string\n        );\n      default:\n        return { success: false, message: `Unknown canvas tool: ${toolName}` };\n    }\n  }\n\n  /**\n   * Describe the current canvas state\n   */\n  private describeCanvas(): CanvasToolResult {\n    const state = this.getState();\n    const description = describeCanvas(state.nodes, state.edges);\n\n    return {\n      success: true,\n      message: description.spatialLayout,\n      data: description,\n    };\n  }\n\n  /**\n   * Move a node to a grid position\n   */\n  private moveNode(nodeId: string, toPosition: string): CanvasToolResult {\n    const state = this.getState();\n    const nodeIndex = state.nodes.findIndex((n) => n.id === nodeId);\n\n    if (nodeIndex === -1) {\n      return { success: false, message: `Node not found: ${nodeId}` };\n    }\n\n    try {\n      const pixel = gridToPixel(toPosition);\n      const newNodes = [...state.nodes];\n      newNodes[nodeIndex] = {\n        ...newNodes[nodeIndex],\n        x: pixel.x,\n        y: pixel.y,\n      };\n\n      this.setState({ ...state, nodes: newNodes });\n\n      return {\n        success: true,\n        message: `Moved node ${nodeId} to position ${toPosition}`,\n        data: { nodeId, newPosition: toPosition, pixel },\n      };\n    } catch (error) {\n      return { success: false, message: `Invalid position: ${toPosition}` };\n    }\n  }\n\n  /**\n   * Update node content\n   */\n  private updateNodeContent(nodeId: string, content: string): CanvasToolResult {\n    const state = this.getState();\n    const nodeIndex = state.nodes.findIndex((n) => n.id === nodeId);\n\n    if (nodeIndex === -1) {\n      return { success: false, message: `Node not found: ${nodeId}` };\n    }\n\n    const newNodes = [...state.nodes];\n    newNodes[nodeIndex] = {\n      ...newNodes[nodeIndex],\n      content,\n    };\n\n    this.setState({ ...state, nodes: newNodes });\n\n    return {\n      success: true,\n      message: `Updated content of node ${nodeId}`,\n      data: { nodeId, content },\n    };\n  }\n\n  /**\n   * Update node color\n   */\n  private updateNodeColor(nodeId: string, color: string): CanvasToolResult {\n    const state = this.getState();\n    const nodeIndex = state.nodes.findIndex((n) => n.id === nodeId);\n\n    if (nodeIndex === -1) {\n      return { success: false, message: `Node not found: ${nodeId}` };\n    }\n\n    const hex = getColorHex(color);\n    const newNodes = [...state.nodes];\n    newNodes[nodeIndex] = {\n      ...newNodes[nodeIndex],\n      style: { ...newNodes[nodeIndex].style, fill: hex },\n    };\n\n    this.setState({ ...state, nodes: newNodes });\n\n    return {\n      success: true,\n      message: `Changed color of node ${nodeId} to ${color}`,\n      data: { nodeId, color, hex },\n    };\n  }\n\n  /**\n   * Create a new node\n   */\n  private createNode(\n    type: string,\n    position: string,\n    content: string,\n    color?: string\n  ): CanvasToolResult {\n    const state = this.getState();\n\n    try {\n      const pixel = gridToPixel(position);\n      const nodeId = `node-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;\n\n      const newNode: CanvasNode = {\n        id: nodeId,\n        type: type === 'mindmap' ? 'sticky' : type,\n        content,\n        x: pixel.x,\n        y: pixel.y,\n        width: type === 'text' ? 200 : 150,\n        height: type === 'text' ? 50 : 100,\n        style: color ? { fill: getColorHex(color) } : undefined,\n      };\n\n      this.setState({\n        ...state,\n        nodes: [...state.nodes, newNode],\n      });\n\n      return {\n        success: true,\n        message: `Created ${type} node at ${position} with content: \"${content}\"`,\n        data: { nodeId, position, pixel },\n      };\n    } catch (error) {\n      return { success: false, message: `Invalid position: ${position}` };\n    }\n  }\n\n  /**\n   * Connect two nodes\n   */\n  private connectNodes(\n    fromNodeId: string,\n    toNodeId: string,\n    label?: string\n  ): CanvasToolResult {\n    const state = this.getState();\n\n    const fromNode = state.nodes.find((n) => n.id === fromNodeId);\n    const toNode = state.nodes.find((n) => n.id === toNodeId);\n\n    if (!fromNode) {\n      return { success: false, message: `Source node not found: ${fromNodeId}` };\n    }\n    if (!toNode) {\n      return { success: false, message: `Target node not found: ${toNodeId}` };\n    }\n\n    const edgeId = `edge-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;\n    const newEdge: CanvasEdge = {\n      id: edgeId,\n      source: fromNodeId,\n      target: toNodeId,\n      label,\n    };\n\n    this.setState({\n      ...state,\n      edges: [...state.edges, newEdge],\n    });\n\n    return {\n      success: true,\n      message: `Connected ${fromNodeId} to ${toNodeId}${label ? ` with label \"${label}\"` : ''}`,\n      data: { edgeId, fromNodeId, toNodeId },\n    };\n  }\n\n  /**\n   * Delete a node\n   */\n  private deleteNode(nodeId: string): CanvasToolResult {\n    const state = this.getState();\n    const nodeIndex = state.nodes.findIndex((n) => n.id === nodeId);\n\n    if (nodeIndex === -1) {\n      return { success: false, message: `Node not found: ${nodeId}` };\n    }\n\n    // Remove node and all connected edges\n    const newNodes = state.nodes.filter((n) => n.id !== nodeId);\n    const newEdges = state.edges.filter(\n      (e) => e.source !== nodeId && e.target !== nodeId\n    );\n\n    this.setState({ ...state, nodes: newNodes, edges: newEdges });\n\n    return {\n      success: true,\n      message: `Deleted node ${nodeId}`,\n      data: { nodeId },\n    };\n  }\n\n  /**\n   * Create a mindmap branch\n   */\n  private createMindmapBranch(\n    parentNodeId: string,\n    content: string,\n    direction: Direction,\n    color?: string\n  ): CanvasToolResult {\n    const state = this.getState();\n    const parentNode = state.nodes.find((n) => n.id === parentNodeId);\n\n    if (!parentNode) {\n      return { success: false, message: `Parent node not found: ${parentNodeId}` };\n    }\n\n    // Get parent position and calculate new position\n    const parentGrid = pixelToGrid({ x: parentNode.x, y: parentNode.y });\n    const newPosition = getRelativePosition(parentGrid.label, direction, 2);\n\n    // Create the new node\n    const createResult = this.createNode('mindmap', newPosition, content, color);\n    if (!createResult.success) return createResult;\n\n    // Connect to parent\n    const newNodeId = (createResult.data as { nodeId: string }).nodeId;\n    const connectResult = this.connectNodes(parentNodeId, newNodeId);\n\n    return {\n      success: true,\n      message: `Created mindmap branch \"${content}\" ${direction} of parent at ${newPosition}`,\n      data: {\n        nodeId: newNodeId,\n        parentNodeId,\n        position: newPosition,\n        direction,\n      },\n    };\n  }\n\n  /**\n   * Arrange nodes in a pattern\n   */\n  private arrangeNodes(\n    nodeIds: string[],\n    pattern: string,\n    startPosition: string\n  ): CanvasToolResult {\n    const state = this.getState();\n\n    // Verify all nodes exist\n    for (const id of nodeIds) {\n      if (!state.nodes.find((n) => n.id === id)) {\n        return { success: false, message: `Node not found: ${id}` };\n      }\n    }\n\n    try {\n      const startPixel = gridToPixel(startPosition);\n      const newNodes = [...state.nodes];\n      const spacing = 200; // pixels between nodes\n\n      nodeIds.forEach((id, index) => {\n        const nodeIndex = newNodes.findIndex((n) => n.id === id);\n        if (nodeIndex === -1) return;\n\n        let x = startPixel.x;\n        let y = startPixel.y;\n\n        switch (pattern) {\n          case 'horizontal':\n            x += index * spacing;\n            break;\n          case 'vertical':\n            y += index * spacing;\n            break;\n          case 'grid':\n            const cols = Math.ceil(Math.sqrt(nodeIds.length));\n            x += (index % cols) * spacing;\n            y += Math.floor(index / cols) * spacing;\n            break;\n          case 'radial':\n            const angle = (index / nodeIds.length) * 2 * Math.PI;\n            const radius = 200;\n            x += Math.cos(angle) * radius;\n            y += Math.sin(angle) * radius;\n            break;\n          case 'mindmap':\n            // First node is center, others radiate out\n            if (index === 0) {\n              // Center node stays at start\n            } else {\n              const branchAngle = ((index - 1) / (nodeIds.length - 1)) * 2 * Math.PI;\n              x += Math.cos(branchAngle) * spacing;\n              y += Math.sin(branchAngle) * spacing;\n            }\n            break;\n        }\n\n        newNodes[nodeIndex] = { ...newNodes[nodeIndex], x, y };\n      });\n\n      this.setState({ ...state, nodes: newNodes });\n\n      return {\n        success: true,\n        message: `Arranged ${nodeIds.length} nodes in ${pattern} pattern starting at ${startPosition}`,\n        data: { nodeIds, pattern, startPosition },\n      };\n    } catch (error) {\n      return { success: false, message: `Invalid start position: ${startPosition}` };\n    }\n  }\n}\n\n// ============================================================================\n// Canvas Context for AI System Prompt\n// ============================================================================\n\n/**\n * Generate canvas context for Claw AI system prompt\n */\nexport function generateCanvasContext(state: CanvasState): string {\n  const description = describeCanvas(state.nodes, state.edges);\n\n  return `\n## Current Canvas State\n\nYou have access to a design canvas that you can control using tools.\n\n**Canvas Grid System:**\n- Positions use spreadsheet notation: columns are letters (A-Z, AA-AZ, etc.), rows are numbers (1-100)\n- Example: A1 is top-left, B5 is column B row 5, AA10 is column 27 row 10\n- Each grid cell is 100x100 pixels\n\n**Current State:**\n- Total nodes: ${description.totalNodes}\n- Total connections: ${description.totalConnections}\n- Grid bounds: ${description.gridBounds.minLabel} to ${description.gridBounds.maxLabel}\n\n**Nodes on Canvas:**\n${description.nodes.length > 0 ? description.nodes.map((n) => `- [${n.id}] ${n.type} at ${n.gridPosition}: \"${n.content.slice(0, 40)}${n.content.length > 40 ? '...' : ''}\"${n.color ? ` (${n.color})` : ''}`).join('\\n') : '(empty)'}\n\n**Available Canvas Tools:**\n- describe_canvas: Get full canvas state\n- move_node: Move a node to grid position\n- update_node_content: Change node text\n- update_node_color: Change node color (yellow, blue, green, pink, purple, orange, red, cyan, white, gray)\n- create_node: Add new node (sticky, text, shape, code, mindmap)\n- connect_nodes: Create connection between nodes\n- delete_node: Remove a node\n- create_mindmap_branch: Add branch to mindmap (specify direction: above, below, left, right, etc.)\n- arrange_nodes: Auto-arrange nodes (grid, horizontal, vertical, radial, mindmap)\n\nWhen the user asks you to manipulate the canvas, use these tools. You can visualize the grid in your head - it's like a spreadsheet!\n`;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1453, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/lib/openclaw/client-impl.ts"],"sourcesContent":["import { nanoid } from 'nanoid';\nimport WebSocket from 'isomorphic-ws';\nimport { Buffer } from 'buffer';\n\n// Protocol constants based on OpenClaw source\nconst PROTOCOL_VERSION = 3;\n\nexport interface OpenClawClientConfig {\n    url: string;\n    authToken?: string;\n    device?: {\n        id: string;\n        publicKey: string;\n        privateKey: string;\n    };\n}\n\ntype MessageHandler = (message: any) => void;\n\nexport class OpenClawClientImpl {\n    private ws: WebSocket | null = null;\n    private url: string;\n    private authToken?: string;\n    private pendingRequests = new Map<string, { resolve: (val: any) => void; reject: (err: any) => void }>();\n    private eventListeners = new Map<string, Set<MessageHandler>>();\n    private isConnected = false;\n    private connectPromise: Promise<void> | null = null;\n\n    constructor(config: OpenClawClientConfig) {\n        this.url = config.url;\n        this.authToken = config.authToken;\n    }\n\n    async connect(): Promise<void> {\n        if (this.isConnected) return;\n        if (this.connectPromise) return this.connectPromise;\n\n        this.connectPromise = new Promise((resolve, reject) => {\n            try {\n                // Set origin to satisfy gateway check for Control UI\n                const options = {\n                    headers: {\n                        Origin: 'http://localhost:18789'\n                    }\n                };\n                this.ws = new WebSocket(this.url, options);\n\n                this.ws.onopen = () => {\n                    console.log('[OpenClawClient] WebSocket connected');\n                };\n\n                this.ws.onmessage = (event) => {\n                    try {\n                        let data: any;\n                        const rawData = event.data;\n\n                        // console.log('[OpenClawClient] Raw message type:', typeof rawData);\n\n                        if (typeof rawData === 'string') {\n                            data = JSON.parse(rawData);\n                        } else if (Buffer.isBuffer(rawData)) {\n                            // console.log('[OpenClawClient] Buffer received, length:', rawData.length);\n                            data = JSON.parse(rawData.toString());\n                        } else if (rawData instanceof ArrayBuffer) {\n                            // console.log('[OpenClawClient] ArrayBuffer received, byteLength:', rawData.byteLength);\n                            const decoder = new TextDecoder();\n                            data = JSON.parse(decoder.decode(rawData));\n                        } else if (Array.isArray(rawData)) {\n                            // Buffer[]\n                            // console.log('[OpenClawClient] Buffer array received');\n                            data = JSON.parse(Buffer.concat(rawData).toString());\n                        } else {\n                            // unknown\n                            console.warn('[OpenClawClient] Unknown message type:', typeof rawData);\n                            return;\n                        }\n\n                        // console.log('[OpenClawClient] Parsed message:', data?.type, data?.event || data?.method);\n                        this.handleMessage(data, resolve, reject);\n                    } catch (err) {\n                        console.error('[OpenClawClient] Failed to parse message:', err);\n                    }\n                };\n\n                this.ws.onerror = (error) => {\n                    console.error('[OpenClawClient] WebSocket error:', error);\n                    if (!this.isConnected) reject(error);\n                };\n\n                this.ws.onclose = () => {\n                    console.log('[OpenClawClient] WebSocket closed');\n                    this.isConnected = false;\n                    this.connectPromise = null;\n                };\n            } catch (err) {\n                reject(err);\n            }\n        });\n\n        return this.connectPromise;\n    }\n\n    private handleMessage(message: any, connectResolve: () => void, connectReject: (err: any) => void) {\n        // console.log('[OpenClawClient] Received:', message);\n\n        if (message.type === 'event' && message.event === 'connect.challenge') {\n            this.handleChallenge(message.payload, connectResolve, connectReject);\n            return;\n        }\n\n        if (message.type === 'res') {\n            const pending = this.pendingRequests.get(message.id);\n            if (pending) {\n                if (message.ok) {\n                    pending.resolve(message.body || message.payload); // Adapting to potential response format\n                } else {\n                    pending.reject(new Error(message.error?.message || 'Unknown error'));\n                }\n                this.pendingRequests.delete(message.id);\n            }\n            return;\n        }\n\n        if (message.type === 'event') {\n            const listeners = this.eventListeners.get(message.event);\n            if (listeners) {\n                listeners.forEach(handler => handler(message.payload));\n            }\n        }\n    }\n\n    private handleChallenge(payload: { nonce: string }, resolve: () => void, reject: (err: any) => void) {\n        const connectReq = {\n            type: 'req',\n            id: nanoid(),\n            method: 'connect',\n            params: {\n                minProtocol: PROTOCOL_VERSION,\n                maxProtocol: PROTOCOL_VERSION,\n                role: 'operator',\n                client: {\n                    id: 'webchat', // Bypass Control UI secure context check\n                    displayName: 'OpenClaw OS',\n                    version: '0.1.0',\n                    platform: 'web',\n                    mode: 'ui',\n                    deviceFamily: 'browser'\n                },\n                auth: { token: this.authToken }\n            }\n        };\n\n        if (this.ws) {\n            this.send(connectReq);\n            // We assume connection is successful if we don't get an immediate error? \n            // Or should we wait for a response? The protocol usually sends a generic 'res' for the connect req.\n\n            // Register a temporary handler for the connect response\n            this.pendingRequests.set(connectReq.id, {\n                resolve: () => {\n                    this.isConnected = true;\n                    resolve();\n                },\n                reject: (err) => {\n                    this.isConnected = false;\n                    reject(err);\n                }\n            });\n        }\n    }\n\n    private send(message: any) {\n        if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n            this.ws.send(JSON.stringify(message));\n        } else {\n            console.warn('[OpenClawClient] Cannot send, socket not open');\n        }\n    }\n\n    public async request(method: string, params: any = {}): Promise<any> {\n        await this.connect();\n        const id = nanoid();\n        return new Promise((resolve, reject) => {\n            this.pendingRequests.set(id, { resolve, reject });\n            this.send({\n                type: 'req',\n                id,\n                method,\n                params\n            });\n            // specific logic for timeout could be added here\n        });\n    }\n\n    public subscribe(event: string, handler: MessageHandler) {\n        if (!this.eventListeners.has(event)) {\n            this.eventListeners.set(event, new Set());\n        }\n        this.eventListeners.get(event)!.add(handler);\n        return () => {\n            this.eventListeners.get(event)?.delete(handler);\n        };\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1638, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/lib/openclaw/client.ts"],"sourcesContent":["import { OpenClawClientImpl } from './client-impl';\n\n// Default to local gateway if not configured\nconst GATEWAY_URL = process.env.NEXT_PUBLIC_OPENCLAW_GATEWAY_URL || 'ws://localhost:3000';\nconst GATEWAY_TOKEN = process.env.NEXT_PUBLIC_OPENCLAW_GATEWAY_TOKEN || 'openclaw-admin-token'; // Default for dev\n\nclass OpenClawClient {\n  private static instance: OpenClawClientImpl;\n\n  public static getInstance(): OpenClawClientImpl {\n    if (!OpenClawClient.instance) {\n      // Load from localStorage if possible\n      let url = GATEWAY_URL;\n      let token = GATEWAY_TOKEN;\n\n      if (typeof window !== 'undefined') {\n        const stored = localStorage.getItem('openclaw_onboarding');\n        if (stored) {\n          try {\n            const parsed = JSON.parse(stored);\n            if (parsed.gatewayUrl) url = parsed.gatewayUrl;\n            if (parsed.gatewayToken) token = parsed.gatewayToken;\n          } catch (e) {\n            // Use defaults\n          }\n        }\n      }\n\n      OpenClawClient.instance = new OpenClawClientImpl({\n        url: url,\n        authToken: token\n      });\n    }\n    return OpenClawClient.instance;\n  }\n}\n\nexport const openClaw = OpenClawClient.getInstance();\n\nexport const useOpenClaw = () => {\n  return openClaw;\n};\n\n// Shims for Convex compatibility\nexport class ConvexHttpClient {\n  constructor(private url: string) { }\n  // Add methods as needed\n  async query(name: string, args: any) { console.warn(\"ConvexHttpClient.query shim called\", name, args); return null; }\n  async mutation(name: string, args: any) { console.warn(\"ConvexHttpClient.mutation shim called\", name, args); return null; }\n  async action(name: string, args: any) { console.warn(\"ConvexHttpClient.action shim called\", name, args); return null; }\n}\n\nexport function makeFunctionReference(name: string) {\n  return name;\n}\n\nexport class ConvexReactClient {\n  constructor(private url: string) { }\n}\n\nexport const ConvexProvider = ({ client, children }: any) => children;\nexport const ConvexProviderWithClerk = ({ client, children }: any) => children;\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;AAEA,6CAA6C;AAC7C,MAAM,cAAc,4DAAgD;AACpE,MAAM,gBAAgB,4DAAkD,wBAAwB,kBAAkB;AAElH,MAAM;IACJ,OAAe,SAA6B;IAE5C,OAAc,cAAkC;QAC9C,IAAI,CAAC,eAAe,QAAQ,EAAE;YAC5B,qCAAqC;YACrC,IAAI,MAAM;YACV,IAAI,QAAQ;YAEZ;;YAaA,eAAe,QAAQ,GAAG,IAAI,8JAAkB,CAAC;gBAC/C,KAAK;gBACL,WAAW;YACb;QACF;QACA,OAAO,eAAe,QAAQ;IAChC;AACF;AAEO,MAAM,WAAW,eAAe,WAAW;AAE3C,MAAM,cAAc;IACzB,OAAO;AACT;AAGO,MAAM;;IACX,YAAY,AAAQ,GAAW,CAAE;aAAb,MAAA;IAAe;IACnC,wBAAwB;IACxB,MAAM,MAAM,IAAY,EAAE,IAAS,EAAE;QAAE,QAAQ,IAAI,CAAC,sCAAsC,MAAM;QAAO,OAAO;IAAM;IACpH,MAAM,SAAS,IAAY,EAAE,IAAS,EAAE;QAAE,QAAQ,IAAI,CAAC,yCAAyC,MAAM;QAAO,OAAO;IAAM;IAC1H,MAAM,OAAO,IAAY,EAAE,IAAS,EAAE;QAAE,QAAQ,IAAI,CAAC,uCAAuC,MAAM;QAAO,OAAO;IAAM;AACxH;AAEO,SAAS,sBAAsB,IAAY;IAChD,OAAO;AACT;AAEO,MAAM;;IACX,YAAY,AAAQ,GAAW,CAAE;aAAb,MAAA;IAAe;AACrC;AAEO,MAAM,iBAAiB,CAAC,EAAE,MAAM,EAAE,QAAQ,EAAO,GAAK;AACtD,MAAM,0BAA0B,CAAC,EAAE,MAAM,EAAE,QAAQ,EAAO,GAAK"}},
    {"offset": {"line": 1714, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/lib/openclaw/hooks.ts"],"sourcesContent":["\nimport { useState, useEffect, useCallback, useMemo } from 'react';\nimport { openClaw } from './client';\n\nexport function useQuery<T>(queryName: string, args: any = {}) {\n    const [data, setData] = useState<T | null>(null);\n    const [isLoading, setIsLoading] = useState(true);\n    const [error, setError] = useState<Error | null>(null);\n\n    // Stable stringify for args to prevent infinite loops\n    const argsString = useMemo(() => JSON.stringify(args), [args]);\n\n    useEffect(() => {\n        let isMounted = true;\n        setIsLoading(true);\n\n        const fetchData = async () => {\n            try {\n                // Ensure args are parsed back to object if needed, or pass as is\n                const actualArgs = JSON.parse(argsString);\n                // Map \"folder:function\" to \"folder.function\" if needed, or use as is.\n                // OpenClaw methods are like \"agents.list\". Convex was \"folder:function\".\n                // We'll assume the user updates the query names or we convert them. as needed.\n                const method = queryName.replace(':', '.');\n\n                const result = await openClaw.request(method, actualArgs);\n                if (isMounted) setData(result);\n            } catch (err: any) {\n                console.error(`[OpenClaw] Query failed: ${queryName}`, err);\n                if (isMounted) setError(err);\n            } finally {\n                if (isMounted) setIsLoading(false);\n            }\n        };\n\n        fetchData();\n\n        // Subscription logic could go here\n        // const unsubscribe = openClaw.subscribe(queryName, (payload) => { ... });\n\n        return () => {\n            isMounted = false;\n            // unsubscribe();\n        };\n    }, [queryName, argsString]);\n\n    return data;\n}\n\nexport function useMutation<T, A>(mutationName: string) {\n    const [isLoading, setIsLoading] = useState(false);\n    const [error, setError] = useState<Error | null>(null);\n\n    const mutate = useCallback(async (args: A) => {\n        setIsLoading(true);\n        setError(null);\n        try {\n            const method = mutationName.replace(':', '.');\n            const result = await openClaw.request(method, args);\n            return result;\n        } catch (err: any) {\n            setError(err);\n            throw err;\n        } finally {\n            setIsLoading(false);\n        }\n    }, [mutationName]);\n\n    // Return the mutate function directly to match Convex behavior\n    const mutateFunction = async (args: A) => {\n        try {\n            setIsLoading(true);\n            return await mutate(args);\n        } finally {\n            setIsLoading(false);\n        }\n    };\n    return mutateFunction;\n}\n\n// Shims\nexport function useConvex() {\n    return openClaw;\n}\n\nexport function useConvexAuth() {\n    return { isAuthenticated: true, isLoading: false };\n}\n\n// Support useQuery(api.foo.bar) syntax which passes a function/object\n// We need to handle arguments that might be objects or strings.\n// Since we replaced the import, existing code passes the original 'api' object references.\n// We need to make sure those references don't crash.\n// However, 'api' imports are usually from '@/lib/convex-shim';\n// Since we removed convex folder, those imports will fail too!\n\n"],"names":[],"mappings":";;;;;;;;;;AACA;AACA;;;AAEO,SAAS,SAAY,SAAiB,EAAE,OAAY,CAAC,CAAC;IACzD,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,0ZAAQ,EAAW;IAC3C,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,0ZAAQ,EAAC;IAC3C,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,0ZAAQ,EAAe;IAEjD,sDAAsD;IACtD,MAAM,aAAa,IAAA,yZAAO,EAAC,IAAM,KAAK,SAAS,CAAC,OAAO;QAAC;KAAK;IAE7D,IAAA,2ZAAS,EAAC;QACN,IAAI,YAAY;QAChB,aAAa;QAEb,MAAM,YAAY;YACd,IAAI;gBACA,iEAAiE;gBACjE,MAAM,aAAa,KAAK,KAAK,CAAC;gBAC9B,sEAAsE;gBACtE,yEAAyE;gBACzE,+EAA+E;gBAC/E,MAAM,SAAS,UAAU,OAAO,CAAC,KAAK;gBAEtC,MAAM,SAAS,MAAM,4IAAQ,CAAC,OAAO,CAAC,QAAQ;gBAC9C,IAAI,WAAW,QAAQ;YAC3B,EAAE,OAAO,KAAU;gBACf,QAAQ,KAAK,CAAC,CAAC,yBAAyB,EAAE,WAAW,EAAE;gBACvD,IAAI,WAAW,SAAS;YAC5B,SAAU;gBACN,IAAI,WAAW,aAAa;YAChC;QACJ;QAEA;QAEA,mCAAmC;QACnC,2EAA2E;QAE3E,OAAO;YACH,YAAY;QACZ,iBAAiB;QACrB;IACJ,GAAG;QAAC;QAAW;KAAW;IAE1B,OAAO;AACX;AAEO,SAAS,YAAkB,YAAoB;IAClD,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,0ZAAQ,EAAC;IAC3C,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,0ZAAQ,EAAe;IAEjD,MAAM,SAAS,IAAA,6ZAAW,EAAC,OAAO;QAC9B,aAAa;QACb,SAAS;QACT,IAAI;YACA,MAAM,SAAS,aAAa,OAAO,CAAC,KAAK;YACzC,MAAM,SAAS,MAAM,4IAAQ,CAAC,OAAO,CAAC,QAAQ;YAC9C,OAAO;QACX,EAAE,OAAO,KAAU;YACf,SAAS;YACT,MAAM;QACV,SAAU;YACN,aAAa;QACjB;IACJ,GAAG;QAAC;KAAa;IAEjB,+DAA+D;IAC/D,MAAM,iBAAiB,OAAO;QAC1B,IAAI;YACA,aAAa;YACb,OAAO,MAAM,OAAO;QACxB,SAAU;YACN,aAAa;QACjB;IACJ;IACA,OAAO;AACX;AAGO,SAAS;IACZ,OAAO,4IAAQ;AACnB;AAEO,SAAS;IACZ,OAAO;QAAE,iBAAiB;QAAM,WAAW;IAAM;AACrD,EAEA,sEAAsE;CACtE,gEAAgE;CAChE,2FAA2F;CAC3F,qDAAqD;CACrD,+DAA+D;CAC/D,+DAA+D"}},
    {"offset": {"line": 1817, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/lib/convex-shim.ts"],"sourcesContent":["export class ConvexHttpClient {\n    constructor(url: string) { }\n    query(query: any, args?: any): Promise<any> { return Promise.resolve(null); }\n    mutation(mutation: any, args?: any): Promise<any> { return Promise.resolve(null); }\n}\n\nexport const api = {\n    jobs: {\n        getAgentJobs: 'jobs:getAgentJobs',\n        cancelJob: 'jobs:cancelJob',\n        getJob: 'jobs:getJob',\n        queueCodeIteration: 'jobs:queueCodeIteration',\n        queueSpecialistDelegation: 'jobs:queueSpecialistDelegation',\n        queueAgentTask: 'jobs:queueAgentTask',\n        updateJobStatusPublic: 'jobs:updateJobStatusPublic',\n        logJobEventPublic: 'jobs:logJobEventPublic',\n    },\n    aiSettings: {\n        getSettings: 'aiSettings:getSettings',\n    },\n    erv: {\n        createEntity: 'erv:createEntity',\n        createRelationship: 'erv:createRelationship',\n        createDimension: 'erv:createDimension',\n        listDimensions: 'erv:listDimensions',\n        searchEntities: 'erv:searchEntities',\n        getEntity: 'erv:getEntity',\n    },\n    jamz: {\n        createProject: 'jamz:createProject',\n        createTrack: 'jamz:createTrack',\n        createClip: 'jamz:createClip',\n    },\n    messages: {\n        send: 'messages:send',\n    },\n    whatsappContacts: {\n        list: 'whatsappContacts:list',\n        getContactByPhone: 'whatsappContacts:getContactByPhone',\n        listContacts: 'whatsappContacts:listContacts',\n        upsertContact: 'whatsappContacts:upsertContact',\n    },\n    channels: {\n        list: 'channels:list',\n        getChannel: 'channels:getChannel',\n        sendMessage: 'channels:sendMessage',\n        getUserMessages: 'channels:getUserMessages',\n        getUserIntegrations: 'channels:getUserIntegrations',\n        getConversations: 'channels:getConversations',\n        getIntegration: 'channels:getIntegration',\n        logOutboundMessage: 'channels:logOutboundMessage',\n        searchMessages: 'channels:searchMessages',\n    },\n    scheduling: {\n        list: 'scheduling:list',\n        createEvent: 'scheduling:createEvent',\n        getEventTypes: 'scheduling:getEventTypes',\n        getAvailableSlots: 'scheduling:getAvailableSlots',\n        createBooking: 'scheduling:createBooking',\n        rescheduleBooking: 'scheduling:rescheduleBooking',\n        updateBookingStatus: 'scheduling:updateBookingStatus',\n    },\n    userCronJobs: {\n        list: 'userCronJobs:list',\n        create: 'userCronJobs:create',\n        delete: 'userCronJobs:delete',\n        createJob: 'userCronJobs:createJob',\n        getUserJobs: 'userCronJobs:getUserJobs',\n        toggleJob: 'userCronJobs:toggleJob',\n        deleteJob: 'userCronJobs:deleteJob',\n    },\n    compaction: {\n        compact: 'compaction:compact',\n        getLatestCompaction: 'compaction:getLatestCompaction',\n    },\n    kanban: {\n        listLists: 'kanban:listLists',\n        createCard: 'kanban:createCard',\n        moveCard: 'kanban:moveCard',\n        getTaskById: 'kanban:getTaskById',\n        searchTasks: 'kanban:searchTasks',\n        getTasks: 'kanban:getTasks',\n        isSeeded: 'kanban:isSeeded',\n        addTask: 'kanban:addTask',\n        updateTask: 'kanban:updateTask',\n        deleteTask: 'kanban:deleteTask',\n        moveTask: 'kanban:moveTask',\n        seedTasks: 'kanban:seedTasks',\n    },\n    designCanvas: {\n        getCanvas: 'designCanvas:getCanvas',\n        updateCanvas: 'designCanvas:updateCanvas',\n        createItem: 'designCanvas:createItem',\n        createCanvas: 'designCanvas:createCanvas',\n        getUserCanvases: 'designCanvas:getUserCanvases',\n        getCanvasNodes: 'designCanvas:getCanvasNodes',\n        getCanvasEdges: 'designCanvas:getCanvasEdges',\n        addNode: 'designCanvas:addNode',\n        addEdge: 'designCanvas:addEdge',\n        updateNode: 'designCanvas:updateNode',\n    },\n    agentic: {\n        createProductProject: 'agentic:createProductProject',\n        createPRD: 'agentic:createPRD',\n        createEpic: 'agentic:createEpic',\n        createTicket: 'agentic:createTicket',\n    },\n    discovery: {\n        getSession: 'discovery:getSession',\n        storeInsights: 'discovery:storeInsights',\n        storeArtifacts: 'discovery:storeArtifacts',\n        markNotificationSent: 'discovery:markNotificationSent',\n        markError: 'discovery:markError',\n        getSessionByCallerId: 'discovery:getSessionByCallerId',\n        updateTranscript: 'discovery:updateTranscript',\n    },\n    memories: {\n        searchEpisodic: 'memories:searchEpisodic',\n        getSemanticByCategories: 'memories:getSemanticByCategories',\n        getAllSemantic: 'memories:getAllSemantic',\n        getRecentEpisodic: 'memories:getRecentEpisodic',\n        storeEpisodic: 'memories:storeEpisodic',\n        upsertSemantic: 'memories:upsertSemantic',\n        deleteEpisodic: 'memories:deleteEpisodic',\n        deleteSemantic: 'memories:deleteSemantic',\n        getMemoryStats: 'memories:getMemoryStats',\n    },\n    observability: {\n        getSecurityScans: 'observability:getSecurityScans',\n        createSecurityScan: 'observability:createSecurityScan',\n        getActivityStream: 'observability:getActivityStream',\n        getDashboardOverview: 'observability:getDashboardOverview',\n        getProviderHealthStatus: 'observability:getProviderHealthStatus',\n        logOperation: 'observability:logOperation',\n    },\n    roadmap: {\n        submitSuggestion: 'roadmap:submitSuggestion',\n        getSuggestions: 'roadmap:getSuggestions',\n        updateSuggestionStatus: 'roadmap:updateSuggestionStatus',\n        voteSuggestion: 'roadmap:voteSuggestion',\n    }\n\n};\n\n// Export ConvexReactClient type for compatibility\nexport type ConvexReactClient = any;\n\nexport type Id<T extends string> = string;\n"],"names":[],"mappings":";;;;;;AAAO,MAAM;IACT,YAAY,GAAW,CAAE,CAAE;IAC3B,MAAM,KAAU,EAAE,IAAU,EAAgB;QAAE,OAAO,QAAQ,OAAO,CAAC;IAAO;IAC5E,SAAS,QAAa,EAAE,IAAU,EAAgB;QAAE,OAAO,QAAQ,OAAO,CAAC;IAAO;AACtF;AAEO,MAAM,MAAM;IACf,MAAM;QACF,cAAc;QACd,WAAW;QACX,QAAQ;QACR,oBAAoB;QACpB,2BAA2B;QAC3B,gBAAgB;QAChB,uBAAuB;QACvB,mBAAmB;IACvB;IACA,YAAY;QACR,aAAa;IACjB;IACA,KAAK;QACD,cAAc;QACd,oBAAoB;QACpB,iBAAiB;QACjB,gBAAgB;QAChB,gBAAgB;QAChB,WAAW;IACf;IACA,MAAM;QACF,eAAe;QACf,aAAa;QACb,YAAY;IAChB;IACA,UAAU;QACN,MAAM;IACV;IACA,kBAAkB;QACd,MAAM;QACN,mBAAmB;QACnB,cAAc;QACd,eAAe;IACnB;IACA,UAAU;QACN,MAAM;QACN,YAAY;QACZ,aAAa;QACb,iBAAiB;QACjB,qBAAqB;QACrB,kBAAkB;QAClB,gBAAgB;QAChB,oBAAoB;QACpB,gBAAgB;IACpB;IACA,YAAY;QACR,MAAM;QACN,aAAa;QACb,eAAe;QACf,mBAAmB;QACnB,eAAe;QACf,mBAAmB;QACnB,qBAAqB;IACzB;IACA,cAAc;QACV,MAAM;QACN,QAAQ;QACR,QAAQ;QACR,WAAW;QACX,aAAa;QACb,WAAW;QACX,WAAW;IACf;IACA,YAAY;QACR,SAAS;QACT,qBAAqB;IACzB;IACA,QAAQ;QACJ,WAAW;QACX,YAAY;QACZ,UAAU;QACV,aAAa;QACb,aAAa;QACb,UAAU;QACV,UAAU;QACV,SAAS;QACT,YAAY;QACZ,YAAY;QACZ,UAAU;QACV,WAAW;IACf;IACA,cAAc;QACV,WAAW;QACX,cAAc;QACd,YAAY;QACZ,cAAc;QACd,iBAAiB;QACjB,gBAAgB;QAChB,gBAAgB;QAChB,SAAS;QACT,SAAS;QACT,YAAY;IAChB;IACA,SAAS;QACL,sBAAsB;QACtB,WAAW;QACX,YAAY;QACZ,cAAc;IAClB;IACA,WAAW;QACP,YAAY;QACZ,eAAe;QACf,gBAAgB;QAChB,sBAAsB;QACtB,WAAW;QACX,sBAAsB;QACtB,kBAAkB;IACtB;IACA,UAAU;QACN,gBAAgB;QAChB,yBAAyB;QACzB,gBAAgB;QAChB,mBAAmB;QACnB,eAAe;QACf,gBAAgB;QAChB,gBAAgB;QAChB,gBAAgB;QAChB,gBAAgB;IACpB;IACA,eAAe;QACX,kBAAkB;QAClB,oBAAoB;QACpB,mBAAmB;QACnB,sBAAsB;QACtB,yBAAyB;QACzB,cAAc;IAClB;IACA,SAAS;QACL,kBAAkB;QAClB,gBAAgB;QAChB,wBAAwB;QACxB,gBAAgB;IACpB;AAEJ"}},
    {"offset": {"line": 1972, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/data/resume.tsx"],"sourcesContent":["import { Icons } from \"@/components/icons\";\nimport { HomeIcon, NotebookIcon, BookOpen, Palette, Music, PencilRuler } from \"lucide-react\";\n\nexport const DATA = {\n  name: \"OpenClaw-OS\",\n  initials: \"OC\",\n  url: \"https://openclaw.io/\",\n  location: \"Dublin, Ireland\",\n  locationLink: \"https://www.google.com/maps/place/dublin+ireland\",\n  description:\n    \"An AI-native operating system designed for high-performance productivity, agentic orchestration, and seamless human-AI collaboration.\",\n  summary: `OpenClaw-OS is a next-generation operating environment built for the AI age. It bridges design, engineering, and product strategy into a single, cohesive experience.\n\n**AI-Native Architecture** - Designed from the ground up to support multi-agent collaboration, context management, and intelligent automation.\n\n**High-Craft UI/UX** - A professional, iOS-style interface with 50+ beautiful themes, liquid animations, and glassmorphic aesthetics.\n\n**Agentic Control Plane** - Use the integrated AI assistant to orchestrate complex workflows, manage projects, and build functional prototypes directly through conversation.`,\n  avatarUrl: \"/openclaw-logo.png\",\n  skills: [\n    \"Agentic AI Orchestration\",\n    \"Product-Led Development\",\n    \"AI Context Management\",\n    \"Multi-Agent Systems\",\n    \"React & Next.js\",\n    \"TailwindCSS\",\n    \"Cloud-native Systems\",\n    \"System Thinking\",\n    \"UI/UX Design Systems\",\n  ],\n  navbar: [\n    { href: \"/\", icon: HomeIcon, label: \"Home\" },\n    { href: \"/canvas\", icon: PencilRuler, label: \"Canvas\" },\n    { href: \"/design\", icon: Palette, label: \"Design\" },\n    { href: \"/music\", icon: Music, label: \"Music\" },\n  ],\n  contact: {\n    email: \"hello@openclaw.io\",\n    tel: \"\",\n    website: \"https://openclaw.io/\",\n    social: {\n      GitHub: {\n        name: \"GitHub\",\n        url: \"https://github.com/openclaw\",\n        icon: Icons.github,\n        navbar: false,\n      },\n      LinkedIn: {\n        name: \"LinkedIn\",\n        url: \"https://linkedin.com/company/openclaw\",\n        icon: Icons.linkedin,\n        navbar: false,\n      },\n      X: {\n        name: \"X\",\n        url: \"https://x.com/openclaw\",\n        icon: Icons.x,\n        navbar: false,\n      },\n      website: {\n        name: \"Website\",\n        url: \"https://openclaw.io/\",\n        icon: Icons.globe,\n        navbar: false,\n      },\n      email: {\n        name: \"Send Email\",\n        url: \"#\",\n        icon: Icons.email,\n        navbar: false,\n      },\n    },\n  },\n  work: [\n    {\n      company: \"OpenClaw Development\",\n      href: \"\",\n      badges: [\"Active\"],\n      location: \"Remote\",\n      title: \"Core System Development\",\n      logoUrl: \"/openclaw-logo.png\",\n      start: \"2024\",\n      end: \"Present\",\n      description: \"Leading the development of the OpenClaw-OS ecosystem, focusing on AI-native interaction models and design-led system architecture.\"\n    },\n    {\n      company: \"The Creative Engine\",\n      href: \"\",\n      badges: [],\n      location: \"Worldwide\",\n      title: \"Product Innovation Lab\",\n      logoUrl: \"🎨\",\n      start: \"2019\",\n      end: \"2024\",\n      description: \"Research and development into the future of human-computer interaction and AI-amplified creativity.\"\n    }\n  ],\n  education: [\n    {\n      school: \"OpenClaw OS Institute\",\n      href: \"\",\n      degree: \"Systems Architecture\",\n      logoUrl: \"\",\n      start: \"2020\",\n      end: \"2024\",\n    }\n  ],\n  projects: [\n    {\n      title: \"OpenClaw-OS\",\n      href: \"https://openclaw.io\",\n      dates: \"2025\",\n      active: true,\n      description: \"The core operating system featuring 50+ themes, AI-native workflows, and an integrated assistant.\",\n      technologies: [\"Next.js 16\", \"React 19\", \"Claude API\", \"TailwindCSS\"],\n      links: [{ type: \"Website\", href: \"https://openclaw.io\", icon: <Icons.globe className=\"size-3\" /> }],\n      image: \"\",\n      video: \"\",\n    }\n  ],\n  hackathons: [],\n} as const;"],"names":[],"mappings":";;;;;AAAA;AACA;AAAA;AAAA;AAAA;;;;AAEO,MAAM,OAAO;IAClB,MAAM;IACN,UAAU;IACV,KAAK;IACL,UAAU;IACV,cAAc;IACd,aACE;IACF,SAAS,CAAC;;;;;;6KAMiK,CAAC;IAC5K,WAAW;IACX,QAAQ;QACN;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IACD,QAAQ;QACN;YAAE,MAAM;YAAK,MAAM,uSAAQ;YAAE,OAAO;QAAO;QAC3C;YAAE,MAAM;YAAW,MAAM,uTAAW;YAAE,OAAO;QAAS;QACtD;YAAE,MAAM;YAAW,MAAM,uSAAO;YAAE,OAAO;QAAS;QAClD;YAAE,MAAM;YAAU,MAAM,iSAAK;YAAE,OAAO;QAAQ;KAC/C;IACD,SAAS;QACP,OAAO;QACP,KAAK;QACL,SAAS;QACT,QAAQ;YACN,QAAQ;gBACN,MAAM;gBACN,KAAK;gBACL,MAAM,oIAAK,CAAC,MAAM;gBAClB,QAAQ;YACV;YACA,UAAU;gBACR,MAAM;gBACN,KAAK;gBACL,MAAM,oIAAK,CAAC,QAAQ;gBACpB,QAAQ;YACV;YACA,GAAG;gBACD,MAAM;gBACN,KAAK;gBACL,MAAM,oIAAK,CAAC,CAAC;gBACb,QAAQ;YACV;YACA,SAAS;gBACP,MAAM;gBACN,KAAK;gBACL,MAAM,oIAAK,CAAC,KAAK;gBACjB,QAAQ;YACV;YACA,OAAO;gBACL,MAAM;gBACN,KAAK;gBACL,MAAM,oIAAK,CAAC,KAAK;gBACjB,QAAQ;YACV;QACF;IACF;IACA,MAAM;QACJ;YACE,SAAS;YACT,MAAM;YACN,QAAQ;gBAAC;aAAS;YAClB,UAAU;YACV,OAAO;YACP,SAAS;YACT,OAAO;YACP,KAAK;YACL,aAAa;QACf;QACA;YACE,SAAS;YACT,MAAM;YACN,QAAQ,EAAE;YACV,UAAU;YACV,OAAO;YACP,SAAS;YACT,OAAO;YACP,KAAK;YACL,aAAa;QACf;KACD;IACD,WAAW;QACT;YACE,QAAQ;YACR,MAAM;YACN,QAAQ;YACR,SAAS;YACT,OAAO;YACP,KAAK;QACP;KACD;IACD,UAAU;QACR;YACE,OAAO;YACP,MAAM;YACN,OAAO;YACP,QAAQ;YACR,aAAa;YACb,cAAc;gBAAC;gBAAc;gBAAY;gBAAc;aAAc;YACrE,OAAO;gBAAC;oBAAE,MAAM;oBAAW,MAAM;oBAAuB,oBAAM,ubAAC,oIAAK,CAAC,KAAK;wBAAC,WAAU;;;;;;gBAAY;aAAE;YACnG,OAAO;YACP,OAAO;QACT;KACD;IACD,YAAY,EAAE;AAChB"}},
    {"offset": {"line": 2142, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/data/tracks.ts"],"sourcesContent":["export interface Track {\n  id: string;\n  title: string;\n  artist: string;\n  album: string;\n  albumArt: string; // URL to album art (Vercel Blob or /public)\n  audioSrc: string; // URL to audio file (Vercel Blob or /public)\n  visualVideo?: string; // Short looping video for this track (portrait 9:16)\n  lyrics?: string;\n  duration?: number; // in seconds, optional - player will detect\n}\n\n// Helper to check if a track is a video (MP4)\nexport function isVideoTrack(track: Track): boolean {\n  return track.audioSrc.toLowerCase().endsWith('.mp4');\n}\n\n// Default placeholder tracks - replace with your actual tracks\n// Audio files can be stored in Vercel Blob (upload via /vault/upload)\n// or in the /public folder for static files\nexport const tracks: Track[] = [\n  {\n    id: \"2\",\n    title: \"OpenClaw AI (Remix)\",\n    artist: \"OpenClaw AI\",\n    album: \"Singles\",\n    albumArt: \"https://2oczblkb3byymav8.public.blob.vercel-storage.com/employeeoftheyear.jpeg\",\n    audioSrc: \"https://2oczblkb3byymav8.public.blob.vercel-storage.com/OpenClaw.app%282%29.mp3\",\n    lyrics: ``,\n  },\n  {\n    id: \"3\",\n    title: \"OpenClaw AI\",\n    artist: \"OpenClaw AI\",\n    album: \"Singles\",\n    albumArt: \"https://2oczblkb3byymav8.public.blob.vercel-storage.com/IMG_1312.jpeg\",\n    audioSrc: \"https://2oczblkb3byymav8.public.blob.vercel-storage.com/OpenClaw.app.mp3\",\n    lyrics: ``,\n  },\n  {\n    id: \"4\",\n    title: \"Humans Are Optional (Remastered)\",\n    artist: \"OpenClaw AI\",\n    album: \"Singles\",\n    albumArt: \"https://2oczblkb3byymav8.public.blob.vercel-storage.com/Humans%20are%20optional.png\",\n    audioSrc: \"https://2oczblkb3byymav8.public.blob.vercel-storage.com/Humans%20are%20optional%20%28Remastered%29.mp3\",\n    lyrics: ``,\n  },\n  {\n    id: \"5\",\n    title: \"URKIL\",\n    artist: \"Jafaris\",\n    album: \"Heroes\",\n    albumArt: \"https://2oczblkb3byymav8.public.blob.vercel-storage.com/employeeoftheyear.jpeg\",\n    audioSrc: \"https://2oczblkb3byymav8.public.blob.vercel-storage.com/Heroes/Jafaris%20-%20URKIL%20%28PROD.ree%CC%81mdolla%29.mp4\",\n    lyrics: ``,\n  },\n];\n\n// Helper to get a track by ID\nexport function getTrackById(id: string): Track | undefined {\n  return tracks.find((t) => t.id === id);\n}\n\n// Helper to get next track\nexport function getNextTrack(currentId: string): Track | undefined {\n  const currentIndex = tracks.findIndex((t) => t.id === currentId);\n  if (currentIndex === -1 || currentIndex === tracks.length - 1) {\n    return tracks[0]; // Loop back to first\n  }\n  return tracks[currentIndex + 1];\n}\n\n// Helper to get previous track\nexport function getPreviousTrack(currentId: string): Track | undefined {\n  const currentIndex = tracks.findIndex((t) => t.id === currentId);\n  if (currentIndex === -1 || currentIndex === 0) {\n    return tracks[tracks.length - 1]; // Loop to last\n  }\n  return tracks[currentIndex - 1];\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAaO,SAAS,aAAa,KAAY;IACvC,OAAO,MAAM,QAAQ,CAAC,WAAW,GAAG,QAAQ,CAAC;AAC/C;AAKO,MAAM,SAAkB;IAC7B;QACE,IAAI;QACJ,OAAO;QACP,QAAQ;QACR,OAAO;QACP,UAAU;QACV,UAAU;QACV,QAAQ,EAAE;IACZ;IACA;QACE,IAAI;QACJ,OAAO;QACP,QAAQ;QACR,OAAO;QACP,UAAU;QACV,UAAU;QACV,QAAQ,EAAE;IACZ;IACA;QACE,IAAI;QACJ,OAAO;QACP,QAAQ;QACR,OAAO;QACP,UAAU;QACV,UAAU;QACV,QAAQ,EAAE;IACZ;IACA;QACE,IAAI;QACJ,OAAO;QACP,QAAQ;QACR,OAAO;QACP,UAAU;QACV,UAAU;QACV,QAAQ,EAAE;IACZ;CACD;AAGM,SAAS,aAAa,EAAU;IACrC,OAAO,OAAO,IAAI,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;AACrC;AAGO,SAAS,aAAa,SAAiB;IAC5C,MAAM,eAAe,OAAO,SAAS,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;IACtD,IAAI,iBAAiB,CAAC,KAAK,iBAAiB,OAAO,MAAM,GAAG,GAAG;QAC7D,OAAO,MAAM,CAAC,EAAE,EAAE,qBAAqB;IACzC;IACA,OAAO,MAAM,CAAC,eAAe,EAAE;AACjC;AAGO,SAAS,iBAAiB,SAAiB;IAChD,MAAM,eAAe,OAAO,SAAS,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;IACtD,IAAI,iBAAiB,CAAC,KAAK,iBAAiB,GAAG;QAC7C,OAAO,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE,EAAE,eAAe;IACnD;IACA,OAAO,MAAM,CAAC,eAAe,EAAE;AACjC"}},
    {"offset": {"line": 2216, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/hooks/useFileAttachment.ts"],"sourcesContent":["'use client';\n\nimport { useState, useCallback, useRef } from 'react';\n\nexport interface FileAttachment {\n  id: string;\n  file: File;\n  name: string;\n  type: string;\n  size: number;\n  preview?: string; // Base64 data URL for images\n}\n\nexport interface UseFileAttachmentOptions {\n  maxFiles?: number;\n  maxSizeBytes?: number;\n  acceptedTypes?: string[];\n  onError?: (error: string) => void;\n}\n\nconst DEFAULT_MAX_SIZE = 10 * 1024 * 1024; // 10MB\nconst DEFAULT_MAX_FILES = 5;\nconst DEFAULT_ACCEPTED_TYPES = [\n  'image/*',\n  'application/pdf',\n  'text/plain',\n  'text/markdown',\n  'application/json',\n  'text/csv',\n];\n\nexport function useFileAttachment(options: UseFileAttachmentOptions = {}) {\n  const {\n    maxFiles = DEFAULT_MAX_FILES,\n    maxSizeBytes = DEFAULT_MAX_SIZE,\n    acceptedTypes = DEFAULT_ACCEPTED_TYPES,\n    onError,\n  } = options;\n\n  const [attachments, setAttachments] = useState<FileAttachment[]>([]);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n\n  const generateId = () => `attach_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;\n\n  const isAcceptedType = useCallback((file: File): boolean => {\n    return acceptedTypes.some(type => {\n      if (type.endsWith('/*')) {\n        const category = type.split('/')[0];\n        return file.type.startsWith(`${category}/`);\n      }\n      return file.type === type;\n    });\n  }, [acceptedTypes]);\n\n  const createPreview = useCallback((file: File): Promise<string | undefined> => {\n    return new Promise((resolve) => {\n      if (!file.type.startsWith('image/')) {\n        resolve(undefined);\n        return;\n      }\n\n      const reader = new FileReader();\n      reader.onload = () => resolve(reader.result as string);\n      reader.onerror = () => resolve(undefined);\n      reader.readAsDataURL(file);\n    });\n  }, []);\n\n  const addFiles = useCallback(async (files: FileList | File[]) => {\n    const fileArray = Array.from(files);\n\n    // Check max files limit\n    if (attachments.length + fileArray.length > maxFiles) {\n      onError?.(`Maximum ${maxFiles} files allowed`);\n      return;\n    }\n\n    setIsProcessing(true);\n\n    const newAttachments: FileAttachment[] = [];\n\n    for (const file of fileArray) {\n      // Validate file type\n      if (!isAcceptedType(file)) {\n        onError?.(`File type not supported: ${file.type || 'unknown'}`);\n        continue;\n      }\n\n      // Validate file size\n      if (file.size > maxSizeBytes) {\n        const maxSizeMB = Math.round(maxSizeBytes / (1024 * 1024));\n        onError?.(`File too large: ${file.name} (max ${maxSizeMB}MB)`);\n        continue;\n      }\n\n      const preview = await createPreview(file);\n\n      newAttachments.push({\n        id: generateId(),\n        file,\n        name: file.name,\n        type: file.type,\n        size: file.size,\n        preview,\n      });\n    }\n\n    setAttachments(prev => [...prev, ...newAttachments]);\n    setIsProcessing(false);\n  }, [attachments.length, maxFiles, maxSizeBytes, isAcceptedType, createPreview, onError]);\n\n  const removeAttachment = useCallback((id: string) => {\n    setAttachments(prev => prev.filter(a => a.id !== id));\n  }, []);\n\n  const clearAttachments = useCallback(() => {\n    setAttachments([]);\n  }, []);\n\n  const openFilePicker = useCallback(() => {\n    fileInputRef.current?.click();\n  }, []);\n\n  const handleFileInputChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.files && e.target.files.length > 0) {\n      addFiles(e.target.files);\n      // Reset input so same file can be selected again\n      e.target.value = '';\n    }\n  }, [addFiles]);\n\n  // Format file size for display\n  const formatFileSize = useCallback((bytes: number): string => {\n    if (bytes < 1024) return `${bytes} B`;\n    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n  }, []);\n\n  // Get files ready for upload (as FormData-compatible array)\n  const getFilesForUpload = useCallback(() => {\n    return attachments.map(a => a.file);\n  }, [attachments]);\n\n  // Convert attachments to base64 for API calls\n  const getAttachmentsAsBase64 = useCallback(async (): Promise<Array<{\n    name: string;\n    type: string;\n    data: string;\n  }>> => {\n    const results = await Promise.all(\n      attachments.map(async (attachment) => {\n        const data = await new Promise<string>((resolve) => {\n          const reader = new FileReader();\n          reader.onload = () => {\n            const base64 = (reader.result as string).split(',')[1];\n            resolve(base64);\n          };\n          reader.readAsDataURL(attachment.file);\n        });\n\n        return {\n          name: attachment.name,\n          type: attachment.type,\n          data,\n        };\n      })\n    );\n\n    return results;\n  }, [attachments]);\n\n  return {\n    attachments,\n    isProcessing,\n    fileInputRef,\n    addFiles,\n    removeAttachment,\n    clearAttachments,\n    openFilePicker,\n    handleFileInputChange,\n    formatFileSize,\n    getFilesForUpload,\n    getAttachmentsAsBase64,\n    hasAttachments: attachments.length > 0,\n    acceptedTypesString: acceptedTypes.join(','),\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2377, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/hooks/useVoiceRecorder.ts"],"sourcesContent":["'use client';\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type RecordingStatus = 'idle' | 'recording' | 'processing' | 'error';\n\nexport interface RecordingError {\n  type: 'permission-denied' | 'not-supported' | 'no-audio' | 'unknown';\n  message: string;\n}\n\nexport interface UseVoiceRecorderReturn {\n  // State\n  status: RecordingStatus;\n  isRecording: boolean;\n  duration: number; // seconds\n  audioLevels: number[]; // Array of recent audio levels (0-1) for waveform\n  error: RecordingError | null;\n\n  // Capabilities\n  isSupported: boolean;\n\n  // Actions\n  startRecording: () => Promise<void>;\n  stopRecording: () => Promise<Blob | null>;\n  cancelRecording: () => void;\n}\n\nexport interface UseVoiceRecorderOptions {\n  maxDuration?: number; // Max recording duration in seconds (default: 120)\n  sampleRate?: number; // Audio sample rate (default: 16000 for Whisper)\n  levelsCount?: number; // Number of audio levels to track for waveform (default: 20)\n  onMaxDurationReached?: () => void;\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst DEFAULT_MAX_DURATION = 120; // 2 minutes\nconst DEFAULT_SAMPLE_RATE = 16000; // Optimal for Whisper\nconst DEFAULT_LEVELS_COUNT = 20;\n\n// ============================================================================\n// Helpers\n// ============================================================================\n\nfunction getErrorMessage(type: RecordingError['type']): string {\n  switch (type) {\n    case 'permission-denied':\n      return 'Microphone access denied. Please enable microphone permissions.';\n    case 'not-supported':\n      return 'Audio recording is not supported in this browser.';\n    case 'no-audio':\n      return 'No audio input detected. Please check your microphone.';\n    default:\n      return 'An error occurred while recording. Please try again.';\n  }\n}\n\n// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useVoiceRecorder(\n  options: UseVoiceRecorderOptions = {}\n): UseVoiceRecorderReturn {\n  const {\n    maxDuration = DEFAULT_MAX_DURATION,\n    levelsCount = DEFAULT_LEVELS_COUNT,\n    onMaxDurationReached,\n  } = options;\n\n  // State\n  const [status, setStatus] = useState<RecordingStatus>('idle');\n  const [duration, setDuration] = useState(0);\n  const [audioLevels, setAudioLevels] = useState<number[]>(\n    Array(levelsCount).fill(0)\n  );\n  const [error, setError] = useState<RecordingError | null>(null);\n\n  // Refs\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const audioContextRef = useRef<AudioContext | null>(null);\n  const analyserRef = useRef<AnalyserNode | null>(null);\n  const streamRef = useRef<MediaStream | null>(null);\n  const chunksRef = useRef<Blob[]>([]);\n  const durationIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const levelsIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const startTimeRef = useRef<number>(0);\n\n  // Check browser support\n  const isSupported =\n    typeof window !== 'undefined' &&\n    typeof navigator !== 'undefined' &&\n    !!navigator.mediaDevices?.getUserMedia &&\n    typeof MediaRecorder !== 'undefined';\n\n  // Cleanup function\n  const cleanup = useCallback(() => {\n    // Stop intervals\n    if (durationIntervalRef.current) {\n      clearInterval(durationIntervalRef.current);\n      durationIntervalRef.current = null;\n    }\n    if (levelsIntervalRef.current) {\n      clearInterval(levelsIntervalRef.current);\n      levelsIntervalRef.current = null;\n    }\n\n    // Stop media recorder\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {\n      try {\n        mediaRecorderRef.current.stop();\n      } catch {\n        // Ignore errors when stopping\n      }\n    }\n\n    // Stop all tracks\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach((track) => track.stop());\n      streamRef.current = null;\n    }\n\n    // Close audio context\n    if (audioContextRef.current && audioContextRef.current.state !== 'closed') {\n      audioContextRef.current.close();\n      audioContextRef.current = null;\n    }\n\n    analyserRef.current = null;\n    mediaRecorderRef.current = null;\n    chunksRef.current = [];\n  }, []);\n\n  // Update audio levels for waveform visualization\n  const updateAudioLevels = useCallback(() => {\n    if (!analyserRef.current) return;\n\n    const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);\n    analyserRef.current.getByteFrequencyData(dataArray);\n\n    // Calculate average level\n    let sum = 0;\n    for (let i = 0; i < dataArray.length; i++) {\n      sum += dataArray[i];\n    }\n    const average = sum / dataArray.length / 255; // Normalize to 0-1\n\n    // Add new level and remove oldest\n    setAudioLevels((prev) => {\n      const newLevels = [...prev.slice(1), average];\n      return newLevels;\n    });\n  }, []);\n\n  // Start recording\n  const startRecording = useCallback(async () => {\n    if (!isSupported) {\n      const err: RecordingError = {\n        type: 'not-supported',\n        message: getErrorMessage('not-supported'),\n      };\n      setError(err);\n      setStatus('error');\n      return;\n    }\n\n    // Reset state\n    setError(null);\n    setDuration(0);\n    setAudioLevels(Array(levelsCount).fill(0));\n    chunksRef.current = [];\n\n    try {\n      // Request microphone access\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true,\n        },\n      });\n      streamRef.current = stream;\n\n      // Set up audio context and analyser for levels\n      const AudioContextClass = window.AudioContext || (window as unknown as { webkitAudioContext: typeof AudioContext }).webkitAudioContext;\n      const audioContext = new AudioContextClass();\n      audioContextRef.current = audioContext;\n\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 256;\n      analyser.smoothingTimeConstant = 0.5;\n      analyserRef.current = analyser;\n\n      const source = audioContext.createMediaStreamSource(stream);\n      source.connect(analyser);\n\n      // Determine the best mime type\n      const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')\n        ? 'audio/webm;codecs=opus'\n        : MediaRecorder.isTypeSupported('audio/webm')\n        ? 'audio/webm'\n        : MediaRecorder.isTypeSupported('audio/mp4')\n        ? 'audio/mp4'\n        : 'audio/wav';\n\n      // Create media recorder\n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType,\n      });\n      mediaRecorderRef.current = mediaRecorder;\n\n      // Handle data available\n      mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          chunksRef.current.push(event.data);\n        }\n      };\n\n      // Start recording\n      mediaRecorder.start(100); // Collect data every 100ms\n      setStatus('recording');\n      startTimeRef.current = Date.now();\n\n      // Start duration timer\n      durationIntervalRef.current = setInterval(() => {\n        const elapsed = Math.floor((Date.now() - startTimeRef.current) / 1000);\n        setDuration(elapsed);\n\n        // Check max duration\n        if (elapsed >= maxDuration) {\n          onMaxDurationReached?.();\n        }\n      }, 100);\n\n      // Start audio levels updates\n      levelsIntervalRef.current = setInterval(updateAudioLevels, 50);\n    } catch (err) {\n      cleanup();\n\n      let errorType: RecordingError['type'] = 'unknown';\n      if (err instanceof DOMException) {\n        if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {\n          errorType = 'permission-denied';\n        } else if (err.name === 'NotFoundError') {\n          errorType = 'no-audio';\n        }\n      }\n\n      const recordingError: RecordingError = {\n        type: errorType,\n        message: getErrorMessage(errorType),\n      };\n      setError(recordingError);\n      setStatus('error');\n    }\n  }, [isSupported, levelsCount, maxDuration, onMaxDurationReached, cleanup, updateAudioLevels]);\n\n  // Stop recording and return audio blob\n  const stopRecording = useCallback(async (): Promise<Blob | null> => {\n    if (!mediaRecorderRef.current || status !== 'recording') {\n      return null;\n    }\n\n    setStatus('processing');\n\n    return new Promise((resolve) => {\n      const mediaRecorder = mediaRecorderRef.current!;\n\n      mediaRecorder.onstop = () => {\n        // Create blob from chunks\n        const mimeType = mediaRecorder.mimeType;\n        const blob = new Blob(chunksRef.current, { type: mimeType });\n\n        cleanup();\n        setStatus('idle');\n        setAudioLevels(Array(levelsCount).fill(0));\n\n        resolve(blob);\n      };\n\n      mediaRecorder.stop();\n    });\n  }, [status, cleanup, levelsCount]);\n\n  // Cancel recording without returning audio\n  const cancelRecording = useCallback(() => {\n    cleanup();\n    setStatus('idle');\n    setDuration(0);\n    setAudioLevels(Array(levelsCount).fill(0));\n    setError(null);\n  }, [cleanup, levelsCount]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      cleanup();\n    };\n  }, [cleanup]);\n\n  return {\n    // State\n    status,\n    isRecording: status === 'recording',\n    duration,\n    audioLevels,\n    error,\n\n    // Capabilities\n    isSupported,\n\n    // Actions\n    startRecording,\n    stopRecording,\n    cancelRecording,\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2561, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/hooks/useSpeechRecognition.ts"],"sourcesContent":["'use client';\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type SpeechRecognitionStatus =\n  | 'idle'\n  | 'listening'\n  | 'processing'\n  | 'error'\n  | 'unsupported';\n\nexport interface SpeechRecognitionError {\n  type: 'not-allowed' | 'no-speech' | 'network' | 'aborted' | 'unknown';\n  message: string;\n}\n\nexport interface UseSpeechRecognitionReturn {\n  // State\n  transcript: string;\n  interimTranscript: string;\n  status: SpeechRecognitionStatus;\n  error: SpeechRecognitionError | null;\n  isListening: boolean;\n  isSupported: boolean;\n  isMicrophoneAvailable: boolean;\n\n  // Actions\n  startListening: () => void;\n  stopListening: () => void;\n  resetTranscript: () => void;\n}\n\nexport interface UseSpeechRecognitionOptions {\n  continuous?: boolean;\n  interimResults?: boolean;\n  language?: string;\n  onResult?: (transcript: string, isFinal: boolean) => void;\n  onError?: (error: SpeechRecognitionError) => void;\n  onEnd?: () => void;\n  onStart?: () => void;\n  autoStop?: boolean; // Auto-stop after silence\n  silenceTimeout?: number; // ms before auto-stop (default 2000)\n}\n\n// ============================================================================\n// Browser Type Definitions\n// ============================================================================\n\ninterface SpeechRecognitionEvent extends Event {\n  resultIndex: number;\n  results: SpeechRecognitionResultList;\n}\n\ninterface SpeechRecognitionResultList {\n  length: number;\n  item(index: number): SpeechRecognitionResult;\n  [index: number]: SpeechRecognitionResult;\n}\n\ninterface SpeechRecognitionResult {\n  isFinal: boolean;\n  length: number;\n  item(index: number): SpeechRecognitionAlternative;\n  [index: number]: SpeechRecognitionAlternative;\n}\n\ninterface SpeechRecognitionAlternative {\n  transcript: string;\n  confidence: number;\n}\n\ninterface SpeechRecognitionErrorEvent extends Event {\n  error: string;\n  message?: string;\n}\n\ninterface SpeechRecognitionInstance extends EventTarget {\n  continuous: boolean;\n  interimResults: boolean;\n  lang: string;\n  maxAlternatives: number;\n  start: () => void;\n  stop: () => void;\n  abort: () => void;\n  onresult: ((event: SpeechRecognitionEvent) => void) | null;\n  onerror: ((event: SpeechRecognitionErrorEvent) => void) | null;\n  onend: (() => void) | null;\n  onstart: (() => void) | null;\n  onspeechend: (() => void) | null;\n  onaudiostart: (() => void) | null;\n  onaudioend: (() => void) | null;\n}\n\n// ============================================================================\n// Helpers\n// ============================================================================\n\nfunction getSpeechRecognition(): (new () => SpeechRecognitionInstance) | null {\n  if (typeof window === 'undefined') return null;\n\n  const SpeechRecognition =\n    (window as unknown as { SpeechRecognition?: new () => SpeechRecognitionInstance }).SpeechRecognition ||\n    (window as unknown as { webkitSpeechRecognition?: new () => SpeechRecognitionInstance }).webkitSpeechRecognition;\n\n  return SpeechRecognition || null;\n}\n\nfunction mapErrorType(errorCode: string): SpeechRecognitionError['type'] {\n  switch (errorCode) {\n    case 'not-allowed':\n    case 'service-not-allowed':\n      return 'not-allowed';\n    case 'no-speech':\n      return 'no-speech';\n    case 'network':\n      return 'network';\n    case 'aborted':\n      return 'aborted';\n    default:\n      return 'unknown';\n  }\n}\n\nfunction getErrorMessage(type: SpeechRecognitionError['type']): string {\n  switch (type) {\n    case 'not-allowed':\n      return 'Microphone access denied. Please enable microphone permissions.';\n    case 'no-speech':\n      return 'No speech detected. Please try again.';\n    case 'network':\n      return 'Network error. Please check your connection.';\n    case 'aborted':\n      return 'Speech recognition was cancelled.';\n    default:\n      return 'An error occurred. Please try again.';\n  }\n}\n\n// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useSpeechRecognition(\n  options: UseSpeechRecognitionOptions = {}\n): UseSpeechRecognitionReturn {\n  const {\n    continuous = false,\n    interimResults = true,\n    language = 'en-US',\n    onResult,\n    onError,\n    onEnd,\n    onStart,\n    autoStop = true,\n    silenceTimeout = 2000,\n  } = options;\n\n  // State\n  const [transcript, setTranscript] = useState('');\n  const [interimTranscript, setInterimTranscript] = useState('');\n  const [status, setStatus] = useState<SpeechRecognitionStatus>('idle');\n  const [error, setError] = useState<SpeechRecognitionError | null>(null);\n  const [isMicrophoneAvailable, setIsMicrophoneAvailable] = useState(true);\n\n  // Refs\n  const recognitionRef = useRef<SpeechRecognitionInstance | null>(null);\n  const silenceTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const isListeningRef = useRef(false);\n\n  // Check browser support\n  const isSupported = typeof window !== 'undefined' && getSpeechRecognition() !== null;\n\n  // Clear silence timer\n  const clearSilenceTimer = useCallback(() => {\n    if (silenceTimerRef.current) {\n      clearTimeout(silenceTimerRef.current);\n      silenceTimerRef.current = null;\n    }\n  }, []);\n\n  // Reset silence timer\n  const resetSilenceTimer = useCallback(() => {\n    clearSilenceTimer();\n    if (autoStop && isListeningRef.current) {\n      silenceTimerRef.current = setTimeout(() => {\n        if (recognitionRef.current && isListeningRef.current) {\n          recognitionRef.current.stop();\n        }\n      }, silenceTimeout);\n    }\n  }, [autoStop, silenceTimeout, clearSilenceTimer]);\n\n  // Stop listening\n  const stopListening = useCallback(() => {\n    clearSilenceTimer();\n    if (recognitionRef.current && isListeningRef.current) {\n      isListeningRef.current = false;\n      try {\n        recognitionRef.current.stop();\n      } catch {\n        // Ignore errors when stopping\n      }\n    }\n    setStatus('idle');\n  }, [clearSilenceTimer]);\n\n  // Start listening\n  const startListening = useCallback(() => {\n    if (!isSupported) {\n      setStatus('unsupported');\n      const err: SpeechRecognitionError = {\n        type: 'unknown',\n        message: 'Speech recognition is not supported in this browser.',\n      };\n      setError(err);\n      onError?.(err);\n      return;\n    }\n\n    // Reset state\n    setError(null);\n    setInterimTranscript('');\n\n    const SpeechRecognitionClass = getSpeechRecognition();\n    if (!SpeechRecognitionClass) return;\n\n    // Create new instance\n    const recognition = new SpeechRecognitionClass();\n    recognitionRef.current = recognition;\n\n    // Configure\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = language;\n    recognition.maxAlternatives = 1;\n\n    // Handle results\n    recognition.onresult = (event: SpeechRecognitionEvent) => {\n      clearSilenceTimer();\n\n      let finalTranscript = '';\n      let interim = '';\n\n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const result = event.results[i];\n        const text = result[0].transcript;\n\n        if (result.isFinal) {\n          finalTranscript += text;\n        } else {\n          interim += text;\n        }\n      }\n\n      if (finalTranscript) {\n        setTranscript((prev) => prev + finalTranscript);\n        onResult?.(finalTranscript, true);\n      }\n\n      setInterimTranscript(interim);\n      if (interim) {\n        onResult?.(interim, false);\n      }\n\n      // Reset silence timer on any speech\n      resetSilenceTimer();\n    };\n\n    // Handle errors\n    recognition.onerror = (event: SpeechRecognitionErrorEvent) => {\n      const errorType = mapErrorType(event.error);\n      const err: SpeechRecognitionError = {\n        type: errorType,\n        message: event.message || getErrorMessage(errorType),\n      };\n\n      setError(err);\n      setStatus('error');\n\n      if (errorType === 'not-allowed') {\n        setIsMicrophoneAvailable(false);\n      }\n\n      onError?.(err);\n      isListeningRef.current = false;\n    };\n\n    // Handle end\n    recognition.onend = () => {\n      clearSilenceTimer();\n      isListeningRef.current = false;\n\n      if (status !== 'error') {\n        setStatus('idle');\n      }\n\n      setInterimTranscript('');\n      onEnd?.();\n    };\n\n    // Handle start\n    recognition.onstart = () => {\n      isListeningRef.current = true;\n      setStatus('listening');\n      onStart?.();\n      resetSilenceTimer();\n    };\n\n    // Start recognition\n    try {\n      recognition.start();\n    } catch (e) {\n      const err: SpeechRecognitionError = {\n        type: 'unknown',\n        message: e instanceof Error ? e.message : 'Failed to start speech recognition',\n      };\n      setError(err);\n      setStatus('error');\n      onError?.(err);\n    }\n  }, [\n    isSupported,\n    continuous,\n    interimResults,\n    language,\n    onResult,\n    onError,\n    onEnd,\n    onStart,\n    clearSilenceTimer,\n    resetSilenceTimer,\n    status,\n  ]);\n\n  // Reset transcript\n  const resetTranscript = useCallback(() => {\n    setTranscript('');\n    setInterimTranscript('');\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      clearSilenceTimer();\n      if (recognitionRef.current) {\n        try {\n          recognitionRef.current.abort();\n        } catch {\n          // Ignore\n        }\n      }\n    };\n  }, [clearSilenceTimer]);\n\n  // Check initial support\n  useEffect(() => {\n    if (!isSupported) {\n      setStatus('unsupported');\n    }\n  }, [isSupported]);\n\n  return {\n    transcript,\n    interimTranscript,\n    status,\n    error,\n    isListening: status === 'listening',\n    isSupported,\n    isMicrophoneAvailable,\n    startListening,\n    stopListening,\n    resetTranscript,\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2732, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/hooks/useTextToSpeech.ts"],"sourcesContent":["'use client';\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type TTSStatus = 'idle' | 'loading' | 'speaking' | 'error';\nexport type TTSVoice = 'alloy' | 'echo' | 'fable' | 'onyx' | 'nova' | 'shimmer';\nexport type TTSProvider = 'openai' | 'elevenlabs';\n\nexport interface TTSError {\n  type: 'network' | 'audio' | 'aborted' | 'unknown';\n  message: string;\n}\n\nexport interface UseTextToSpeechReturn {\n  // State\n  status: TTSStatus;\n  error: TTSError | null;\n  isSpeaking: boolean;\n  isLoading: boolean;\n  currentText: string | null;\n  isAudioUnlocked: boolean;\n\n  // Actions\n  speak: (text: string) => Promise<void>;\n  stop: () => void;\n  pause: () => void;\n  resume: () => void;\n  unlockAudio: () => Promise<void>; // Call this on user interaction to enable audio\n}\n\nexport interface UseTextToSpeechOptions {\n  voice?: TTSVoice;\n  speed?: number; // 0.25 to 4.0\n  provider?: TTSProvider; // 'openai' or 'elevenlabs' - defaults to 'openai'\n  onStart?: () => void;\n  onEnd?: () => void;\n  onError?: (error: TTSError) => void;\n  autoPlay?: boolean; // Default true\n}\n\n// ============================================================================\n// Audio unlock state (shared across all hook instances)\n// ============================================================================\n\nlet globalAudioUnlocked = false;\nlet globalAudioContext: AudioContext | null = null;\nlet globalBlessedAudio: HTMLAudioElement | null = null;\nlet globalUnlockListenerAdded = false;\n\n/**\n * Unlock audio playback by playing a silent sound.\n * This must be called from a user interaction (click, tap, etc.)\n */\nasync function unlockAudioPlayback(): Promise<boolean> {\n  if (globalAudioUnlocked) return true;\n\n  try {\n    // Create or resume AudioContext\n    if (!globalAudioContext) {\n      globalAudioContext = new (window.AudioContext ||\n        (window as unknown as { webkitAudioContext: typeof AudioContext }).webkitAudioContext)();\n    }\n\n    if (globalAudioContext.state === 'suspended') {\n      await globalAudioContext.resume();\n    }\n\n    // Create a \"blessed\" Audio element that we can reuse\n    // iOS Safari requires the Audio element to be created AND played during user interaction\n    if (!globalBlessedAudio) {\n      globalBlessedAudio = new Audio();\n      globalBlessedAudio.volume = 1;\n    }\n\n    // Play a silent sound to unlock audio on iOS/Safari\n    // Using a very short silent WAV\n    globalBlessedAudio.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';\n\n    const playPromise = globalBlessedAudio.play();\n    if (playPromise !== undefined) {\n      await playPromise;\n    }\n    globalBlessedAudio.pause();\n    globalBlessedAudio.currentTime = 0;\n\n    globalAudioUnlocked = true;\n    console.log('[TTS] Audio playback unlocked');\n    return true;\n  } catch (error) {\n    console.warn('[TTS] Failed to unlock audio:', error);\n    return false;\n  }\n}\n\n/**\n * Add a document-level listener to auto-unlock audio on first user interaction.\n * This ensures audio is unlocked even if the user doesn't explicitly click the voice button.\n */\nfunction setupGlobalUnlockListener() {\n  if (globalUnlockListenerAdded || typeof document === 'undefined') return;\n\n  const unlockHandler = () => {\n    if (!globalAudioUnlocked) {\n      unlockAudioPlayback().catch(console.warn);\n    }\n  };\n\n  // Listen for any user interaction\n  document.addEventListener('click', unlockHandler, { once: false, passive: true });\n  document.addEventListener('touchstart', unlockHandler, { once: false, passive: true });\n  document.addEventListener('keydown', unlockHandler, { once: false, passive: true });\n\n  globalUnlockListenerAdded = true;\n  console.log('[TTS] Global unlock listeners added');\n}\n\n// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useTextToSpeech(\n  options: UseTextToSpeechOptions = {}\n): UseTextToSpeechReturn {\n  const {\n    voice = 'nova',\n    speed = 1.0,\n    provider = 'openai',\n    onStart,\n    onEnd,\n    onError,\n    autoPlay = true,\n  } = options;\n\n  // State\n  const [status, setStatus] = useState<TTSStatus>('idle');\n  const [error, setError] = useState<TTSError | null>(null);\n  const [currentText, setCurrentText] = useState<string | null>(null);\n  const [isAudioUnlocked, setIsAudioUnlocked] = useState(globalAudioUnlocked);\n\n  // Refs\n  const audioRef = useRef<HTMLAudioElement | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  // Set up global unlock listener on mount\n  useEffect(() => {\n    setupGlobalUnlockListener();\n  }, []);\n\n  // Sync audio unlock state with global state\n  useEffect(() => {\n    const checkUnlockState = () => {\n      if (globalAudioUnlocked && !isAudioUnlocked) {\n        setIsAudioUnlocked(true);\n      }\n    };\n    // Check periodically in case global state was updated\n    const interval = setInterval(checkUnlockState, 500);\n    return () => clearInterval(interval);\n  }, [isAudioUnlocked]);\n\n  // Unlock audio (call this on user interaction like clicking mic button)\n  const unlockAudio = useCallback(async () => {\n    const unlocked = await unlockAudioPlayback();\n    setIsAudioUnlocked(unlocked);\n  }, []);\n\n  // Clean up audio element\n  const cleanupAudio = useCallback(() => {\n    if (audioRef.current) {\n      audioRef.current.pause();\n      audioRef.current.src = '';\n      audioRef.current.load();\n      audioRef.current = null;\n    }\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n\n  // Stop speaking\n  const stop = useCallback(() => {\n    cleanupAudio();\n    setStatus('idle');\n    setCurrentText(null);\n  }, [cleanupAudio]);\n\n  // Pause speaking\n  const pause = useCallback(() => {\n    if (audioRef.current && status === 'speaking') {\n      audioRef.current.pause();\n    }\n  }, [status]);\n\n  // Resume speaking\n  const resume = useCallback(() => {\n    if (audioRef.current && audioRef.current.paused) {\n      audioRef.current.play().catch(console.error);\n    }\n  }, []);\n\n  // Speak text\n  const speak = useCallback(\n    async (text: string) => {\n      if (!text.trim()) return;\n\n      // Stop any current speech\n      cleanupAudio();\n\n      setError(null);\n      setCurrentText(text);\n      setStatus('loading');\n\n      // Ensure AudioContext is resumed (iOS Safari requirement)\n      if (globalAudioContext && globalAudioContext.state === 'suspended') {\n        try {\n          await globalAudioContext.resume();\n          console.log('[TTS] AudioContext resumed');\n        } catch (e) {\n          console.warn('[TTS] Failed to resume AudioContext:', e);\n        }\n      }\n\n      // Create abort controller for this request\n      abortControllerRef.current = new AbortController();\n\n      try {\n        // Use appropriate endpoint based on provider\n        const endpoint = provider === 'elevenlabs' ? '/api/tts/elevenlabs' : '/api/tts';\n        const body = provider === 'elevenlabs'\n          ? { text } // ElevenLabs uses voice ID from env var\n          : { text, voice, speed };\n\n        const response = await fetch(endpoint, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify(body),\n          signal: abortControllerRef.current.signal,\n        });\n\n        if (!response.ok) {\n          const errorData = await response.json().catch(() => ({}));\n          throw new Error(errorData.error || 'Failed to generate speech');\n        }\n\n        // Get the audio blob\n        const audioBlob = await response.blob();\n        const audioUrl = URL.createObjectURL(audioBlob);\n\n        // Use the blessed audio element if available (for iOS Safari compatibility)\n        // Otherwise create a new one\n        const audio = globalBlessedAudio || new Audio();\n        audioRef.current = audio;\n\n        // Set up event handlers\n        audio.onloadeddata = () => {\n          if (autoPlay) {\n            // Try to play with retry on failure\n            const attemptPlay = async (retries = 2): Promise<void> => {\n              try {\n                await audio.play();\n                setStatus('speaking');\n                setIsAudioUnlocked(true);\n                onStart?.();\n              } catch (playError) {\n                console.warn('[TTS] Play failed:', (playError as Error).message, `(retries left: ${retries})`);\n\n                if (retries > 0) {\n                  // Try to resume AudioContext and retry\n                  if (globalAudioContext?.state === 'suspended') {\n                    await globalAudioContext.resume().catch(() => {});\n                  }\n                  await new Promise(r => setTimeout(r, 100));\n                  return attemptPlay(retries - 1);\n                }\n\n                // All retries failed - show user-friendly message\n                const err: TTSError = {\n                  type: 'audio',\n                  message: 'Tap anywhere to enable voice responses',\n                };\n                setError(err);\n                setStatus('error');\n                onError?.(err);\n              }\n            };\n            attemptPlay();\n          }\n        };\n\n        audio.onended = () => {\n          URL.revokeObjectURL(audioUrl);\n          setStatus('idle');\n          setCurrentText(null);\n          onEnd?.();\n        };\n\n        audio.onerror = () => {\n          URL.revokeObjectURL(audioUrl);\n          const err: TTSError = {\n            type: 'audio',\n            message: 'Failed to load audio',\n          };\n          setError(err);\n          setStatus('error');\n          onError?.(err);\n        };\n\n        // Load the audio\n        audio.src = audioUrl;\n        audio.load();\n      } catch (err) {\n        if (err instanceof Error && err.name === 'AbortError') {\n          // Request was aborted, not an error\n          setStatus('idle');\n          return;\n        }\n\n        const error: TTSError = {\n          type: 'network',\n          message: err instanceof Error ? err.message : 'Unknown error',\n        };\n        setError(error);\n        setStatus('error');\n        onError?.(error);\n      }\n    },\n    [cleanupAudio, provider, voice, speed, autoPlay, onStart, onEnd, onError]\n  );\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      cleanupAudio();\n    };\n  }, [cleanupAudio]);\n\n  // Sync global unlock state\n  useEffect(() => {\n    setIsAudioUnlocked(globalAudioUnlocked);\n  }, []);\n\n  return {\n    status,\n    error,\n    isSpeaking: status === 'speaking',\n    isLoading: status === 'loading',\n    currentText,\n    isAudioUnlocked,\n    speak,\n    stop,\n    pause,\n    resume,\n    unlockAudio,\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3030, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/hooks/useVoiceChat.ts"],"sourcesContent":["'use client';\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport {\n  useSpeechRecognition,\n  SpeechRecognitionStatus,\n  SpeechRecognitionError,\n} from './useSpeechRecognition';\nimport {\n  useTextToSpeech,\n  TTSStatus,\n  TTSError,\n  TTSVoice,\n  TTSProvider,\n} from './useTextToSpeech';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type VoiceChatMode = 'idle' | 'listening' | 'processing' | 'speaking';\n\nexport interface VoiceChatError {\n  type: 'speech' | 'tts' | 'unknown';\n  message: string;\n}\n\nexport interface UseVoiceChatReturn {\n  // State\n  mode: VoiceChatMode;\n  isVoiceEnabled: boolean;\n  transcript: string;\n  interimTranscript: string;\n  error: VoiceChatError | null;\n\n  // Capabilities\n  isSpeechSupported: boolean;\n  isMicrophoneAvailable: boolean;\n\n  // Actions\n  enableVoice: () => void;\n  disableVoice: () => void;\n  toggleVoice: () => void;\n  startListening: () => void;\n  stopListening: () => void;\n  speakResponse: (text: string) => Promise<void>;\n  stopSpeaking: () => void;\n  resetTranscript: () => void;\n}\n\nexport interface UseVoiceChatOptions {\n  voice?: TTSVoice;\n  provider?: TTSProvider; // 'openai' or 'elevenlabs' - defaults to 'openai'\n  language?: string;\n  continuous?: boolean;\n  autoSpeak?: boolean; // Automatically speak AI responses\n  onTranscriptComplete?: (transcript: string) => void;\n  onSpeakingStart?: () => void;\n  onSpeakingEnd?: () => void;\n  onError?: (error: VoiceChatError) => void;\n}\n\n// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useVoiceChat(\n  options: UseVoiceChatOptions = {}\n): UseVoiceChatReturn {\n  const {\n    voice = 'nova',\n    provider = 'elevenlabs', // Default to ElevenLabs for James's cloned voice\n    language = 'en-US',\n    continuous = false,\n    autoSpeak = true,\n    onTranscriptComplete,\n    onSpeakingStart,\n    onSpeakingEnd,\n    onError,\n  } = options;\n\n  // State\n  const [isVoiceEnabled, setIsVoiceEnabled] = useState(false);\n  const [mode, setMode] = useState<VoiceChatMode>('idle');\n  const [error, setError] = useState<VoiceChatError | null>(null);\n\n  // Refs for tracking state across callbacks\n  const pendingTranscriptRef = useRef<string>('');\n  const isProcessingRef = useRef(false);\n\n  // Speech Recognition (input)\n  const speechRecognition = useSpeechRecognition({\n    continuous,\n    language,\n    interimResults: true,\n    autoStop: true,\n    silenceTimeout: 2000,\n    onResult: (transcript, isFinal) => {\n      if (isFinal) {\n        pendingTranscriptRef.current += transcript;\n      }\n    },\n    onEnd: () => {\n      // When speech recognition ends, process the transcript\n      if (pendingTranscriptRef.current.trim() && !isProcessingRef.current) {\n        const finalTranscript = pendingTranscriptRef.current.trim();\n        pendingTranscriptRef.current = '';\n        setMode('processing');\n        isProcessingRef.current = true;\n        onTranscriptComplete?.(finalTranscript);\n        isProcessingRef.current = false;\n      } else if (mode === 'listening') {\n        setMode('idle');\n      }\n    },\n    onError: (err) => {\n      const voiceError: VoiceChatError = {\n        type: 'speech',\n        message: err.message,\n      };\n      setError(voiceError);\n      setMode('idle');\n      onError?.(voiceError);\n    },\n  });\n\n  // Text-to-Speech (output)\n  const tts = useTextToSpeech({\n    voice,\n    provider,\n    speed: 1.0,\n    onStart: () => {\n      setMode('speaking');\n      onSpeakingStart?.();\n    },\n    onEnd: () => {\n      setMode('idle');\n      onSpeakingEnd?.();\n    },\n    onError: (err) => {\n      const voiceError: VoiceChatError = {\n        type: 'tts',\n        message: err.message,\n      };\n      setError(voiceError);\n      setMode('idle');\n      onError?.(voiceError);\n    },\n  });\n\n  // Update mode based on speech recognition status\n  useEffect(() => {\n    if (speechRecognition.isListening && mode !== 'speaking') {\n      setMode('listening');\n    }\n  }, [speechRecognition.isListening, mode]);\n\n  // Enable voice mode\n  const enableVoice = useCallback(() => {\n    setIsVoiceEnabled(true);\n    setError(null);\n    // Unlock audio on user interaction\n    tts.unlockAudio();\n  }, [tts]);\n\n  // Disable voice mode\n  const disableVoice = useCallback(() => {\n    setIsVoiceEnabled(false);\n    speechRecognition.stopListening();\n    tts.stop();\n    setMode('idle');\n    pendingTranscriptRef.current = '';\n  }, [speechRecognition, tts]);\n\n  // Toggle voice mode\n  const toggleVoice = useCallback(() => {\n    if (isVoiceEnabled) {\n      disableVoice();\n    } else {\n      enableVoice();\n    }\n  }, [isVoiceEnabled, enableVoice, disableVoice]);\n\n  // Start listening\n  const startListening = useCallback(() => {\n    if (!isVoiceEnabled) {\n      enableVoice();\n    }\n\n    // Stop any current speech first\n    tts.stop();\n\n    setError(null);\n    pendingTranscriptRef.current = '';\n    speechRecognition.resetTranscript();\n    speechRecognition.startListening();\n  }, [isVoiceEnabled, enableVoice, tts, speechRecognition]);\n\n  // Stop listening\n  const stopListening = useCallback(() => {\n    speechRecognition.stopListening();\n  }, [speechRecognition]);\n\n  // Speak AI response\n  const speakResponse = useCallback(\n    async (text: string) => {\n      if (!isVoiceEnabled || !autoSpeak) return;\n\n      // Clean the text for speech (remove markdown, links, etc.)\n      const cleanText = text\n        .replace(/\\[([^\\]]+)\\]\\([^)]+\\)/g, '$1') // Remove markdown links\n        .replace(/\\*\\*([^*]+)\\*\\*/g, '$1') // Remove bold\n        .replace(/\\*([^*]+)\\*/g, '$1') // Remove italic\n        .replace(/`([^`]+)`/g, '$1') // Remove code\n        .replace(/#{1,6}\\s/g, '') // Remove headers\n        .replace(/\\n+/g, '. ') // Replace newlines with periods\n        .replace(/\\s+/g, ' ') // Normalize whitespace\n        .trim();\n\n      if (cleanText) {\n        await tts.speak(cleanText);\n      }\n    },\n    [isVoiceEnabled, autoSpeak, tts]\n  );\n\n  // Stop speaking\n  const stopSpeaking = useCallback(() => {\n    tts.stop();\n    setMode('idle');\n  }, [tts]);\n\n  // Reset transcript\n  const resetTranscript = useCallback(() => {\n    speechRecognition.resetTranscript();\n    pendingTranscriptRef.current = '';\n  }, [speechRecognition]);\n\n  return {\n    // State\n    mode,\n    isVoiceEnabled,\n    transcript: speechRecognition.transcript,\n    interimTranscript: speechRecognition.interimTranscript,\n    error,\n\n    // Capabilities\n    isSpeechSupported: speechRecognition.isSupported,\n    isMicrophoneAvailable: speechRecognition.isMicrophoneAvailable,\n\n    // Actions\n    enableVoice,\n    disableVoice,\n    toggleVoice,\n    startListening,\n    stopListening,\n    speakResponse,\n    stopSpeaking,\n    resetTranscript,\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3231, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/hooks/usePauseMusicForVoice.ts"],"sourcesContent":["'use client';\n\nimport { useEffect, useRef, useContext } from 'react';\nimport { MusicContext } from '@/context/MusicContext';\n\ninterface UsePauseMusicForVoiceOptions {\n  /** Whether voice recording is active */\n  isRecording?: boolean;\n  /** Whether TTS is speaking (voiceChat.mode === 'speaking') */\n  isSpeaking?: boolean;\n  /** Whether voice transcription is processing */\n  isTranscribing?: boolean;\n}\n\n/**\n * Pauses music when voice recording or TTS speaking is active.\n * Music stays paused after voice interaction ends (no auto-resume).\n *\n * Safe to use even if MusicProvider is not available (will no-op).\n *\n * Usage:\n * ```tsx\n * usePauseMusicForVoice({\n *   isRecording: voiceRecorder.isRecording,\n *   isSpeaking: voiceChat.mode === 'speaking',\n *   isTranscribing: isTranscribing,\n * });\n * ```\n */\nexport function usePauseMusicForVoice({\n  isRecording = false,\n  isSpeaking = false,\n  isTranscribing = false,\n}: UsePauseMusicForVoiceOptions) {\n  // Use context directly to avoid throwing if not in provider\n  const musicContext = useContext(MusicContext);\n\n  // Track if we paused the music (to avoid redundant pause calls)\n  const didPauseRef = useRef(false);\n\n  // Pause music when recording starts\n  useEffect(() => {\n    if (!musicContext) return;\n    if (isRecording && musicContext.isPlaying) {\n      musicContext.pause();\n      didPauseRef.current = true;\n    }\n  }, [isRecording, musicContext]);\n\n  // Pause music when TTS speaking starts\n  useEffect(() => {\n    if (!musicContext) return;\n    if (isSpeaking && musicContext.isPlaying) {\n      musicContext.pause();\n      didPauseRef.current = true;\n    }\n  }, [isSpeaking, musicContext]);\n\n  // Pause music when transcribing starts (covers the processing phase)\n  useEffect(() => {\n    if (!musicContext) return;\n    if (isTranscribing && musicContext.isPlaying) {\n      musicContext.pause();\n      didPauseRef.current = true;\n    }\n  }, [isTranscribing, musicContext]);\n\n  // Reset the ref when voice interaction ends (but don't auto-resume)\n  useEffect(() => {\n    if (!isRecording && !isSpeaking && !isTranscribing) {\n      didPauseRef.current = false;\n    }\n  }, [isRecording, isSpeaking, isTranscribing]);\n}\n\nexport default usePauseMusicForVoice;\n"],"names":[],"mappings":";;;;;;AAEA;AACA;AAHA;;;AA6BO,SAAS,sBAAsB,EACpC,cAAc,KAAK,EACnB,aAAa,KAAK,EAClB,iBAAiB,KAAK,EACO;IAC7B,4DAA4D;IAC5D,MAAM,eAAe,IAAA,4ZAAU,EAAC,+IAAY;IAE5C,gEAAgE;IAChE,MAAM,cAAc,IAAA,wZAAM,EAAC;IAE3B,oCAAoC;IACpC,IAAA,2ZAAS,EAAC;QACR,IAAI,CAAC,cAAc;QACnB,IAAI,eAAe,aAAa,SAAS,EAAE;YACzC,aAAa,KAAK;YAClB,YAAY,OAAO,GAAG;QACxB;IACF,GAAG;QAAC;QAAa;KAAa;IAE9B,uCAAuC;IACvC,IAAA,2ZAAS,EAAC;QACR,IAAI,CAAC,cAAc;QACnB,IAAI,cAAc,aAAa,SAAS,EAAE;YACxC,aAAa,KAAK;YAClB,YAAY,OAAO,GAAG;QACxB;IACF,GAAG;QAAC;QAAY;KAAa;IAE7B,qEAAqE;IACrE,IAAA,2ZAAS,EAAC;QACR,IAAI,CAAC,cAAc;QACnB,IAAI,kBAAkB,aAAa,SAAS,EAAE;YAC5C,aAAa,KAAK;YAClB,YAAY,OAAO,GAAG;QACxB;IACF,GAAG;QAAC;QAAgB;KAAa;IAEjC,oEAAoE;IACpE,IAAA,2ZAAS,EAAC;QACR,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,gBAAgB;YAClD,YAAY,OAAO,GAAG;QACxB;IACF,GAAG;QAAC;QAAa;QAAY;KAAe;AAC9C;uCAEe"}},
    {"offset": {"line": 3296, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/hooks/useVoiceMode.ts"],"sourcesContent":["'use client';\n\nimport { useState, useCallback, useRef, useEffect } from 'react';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type VoiceModeState = 'idle' | 'listening' | 'processing' | 'speaking';\n\nexport interface VoiceModeConfig {\n  // Chunking config\n  chunkDurationMs?: number; // Duration of each audio chunk (default: 2000ms)\n  silenceThreshold?: number; // Audio level below which is considered silence (0-1, default: 0.02)\n  silenceDurationMs?: number; // Duration of silence before auto-send (default: 1500ms)\n\n  // API endpoints\n  whisperEndpoint?: string;\n  chatEndpoint?: string;\n  ttsEndpoint?: string;\n\n  // Callbacks\n  onTranscriptUpdate?: (transcript: string, isFinal: boolean) => void;\n  onResponseStart?: () => void;\n  onResponseEnd?: (response: string) => void;\n  onError?: (error: string) => void;\n  onStateChange?: (state: VoiceModeState) => void;\n}\n\nexport interface UseVoiceModeReturn {\n  // State\n  state: VoiceModeState;\n  isActive: boolean;\n  transcript: string;\n  response: string;\n  audioIntensity: number; // 0-1 for UI feedback\n  error: string | null;\n\n  // Actions\n  start: () => Promise<void>;\n  stop: () => void;\n  send: () => Promise<void>; // Manual send (tap to send)\n  interrupt: () => void; // Stop speaking, switch to listening\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst DEFAULT_CHUNK_DURATION = 2000; // 2 seconds\nconst DEFAULT_SILENCE_THRESHOLD = 0.02;\nconst DEFAULT_SILENCE_DURATION = 1500; // 1.5 seconds\nconst AUDIO_LEVEL_UPDATE_INTERVAL = 50; // 50ms\n\n// Debug logging\nconst LOG_PREFIX = '[VoiceMode]';\nconst log = {\n  info: (msg: string, data?: unknown) => console.log(`${LOG_PREFIX} ${msg}`, data ?? ''),\n  warn: (msg: string, data?: unknown) => console.warn(`${LOG_PREFIX} ${msg}`, data ?? ''),\n  error: (msg: string, data?: unknown) => console.error(`${LOG_PREFIX} ${msg}`, data ?? ''),\n  state: (from: VoiceModeState, to: VoiceModeState) =>\n    console.log(`${LOG_PREFIX} [STATE] ${from} → ${to}`),\n  timing: (label: string, ms: number) =>\n    console.log(`${LOG_PREFIX} [TIMING] ${label}: ${ms}ms`),\n};\n\n// ============================================================================\n// Hook\n// ============================================================================\n\nexport function useVoiceMode(config: VoiceModeConfig = {}): UseVoiceModeReturn {\n  const {\n    chunkDurationMs = DEFAULT_CHUNK_DURATION,\n    silenceThreshold = DEFAULT_SILENCE_THRESHOLD,\n    silenceDurationMs = DEFAULT_SILENCE_DURATION,\n    whisperEndpoint = '/api/whisper',\n    chatEndpoint = '/api/chat/stream',\n    ttsEndpoint = '/api/tts',\n    onTranscriptUpdate,\n    onResponseStart,\n    onResponseEnd,\n    onError,\n    onStateChange,\n  } = config;\n\n  // State\n  const [state, setState] = useState<VoiceModeState>('idle');\n  const [transcript, setTranscript] = useState('');\n  const [response, setResponse] = useState('');\n  const [audioIntensity, setAudioIntensity] = useState(0);\n  const [error, setError] = useState<string | null>(null);\n\n  // Refs for cleanup and management\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const audioContextRef = useRef<AudioContext | null>(null);\n  const analyserRef = useRef<AnalyserNode | null>(null);\n  const streamRef = useRef<MediaStream | null>(null);\n  const audioChunksRef = useRef<Blob[]>([]);\n  const audioLevelIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const silenceTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const chunkIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const lastAudioLevelRef = useRef(0);\n  const silenceStartRef = useRef<number | null>(null);\n  const currentAudioRef = useRef<HTMLAudioElement | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const startTimeRef = useRef<number>(0);\n\n  // State change with logging and callback\n  const transitionState = useCallback((newState: VoiceModeState) => {\n    setState(prev => {\n      if (prev !== newState) {\n        log.state(prev, newState);\n        onStateChange?.(newState);\n      }\n      return newState;\n    });\n  }, [onStateChange]);\n\n  // Cleanup all resources\n  const cleanup = useCallback(() => {\n    log.info('cleanup() - releasing all resources');\n\n    // Stop intervals\n    if (audioLevelIntervalRef.current) {\n      clearInterval(audioLevelIntervalRef.current);\n      audioLevelIntervalRef.current = null;\n    }\n    if (silenceTimeoutRef.current) {\n      clearTimeout(silenceTimeoutRef.current);\n      silenceTimeoutRef.current = null;\n    }\n    if (chunkIntervalRef.current) {\n      clearInterval(chunkIntervalRef.current);\n      chunkIntervalRef.current = null;\n    }\n\n    // Stop media recorder\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {\n      try {\n        mediaRecorderRef.current.stop();\n      } catch {\n        // Ignore\n      }\n    }\n    mediaRecorderRef.current = null;\n\n    // Stop stream tracks\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n      streamRef.current = null;\n    }\n\n    // Close audio context\n    if (audioContextRef.current && audioContextRef.current.state !== 'closed') {\n      audioContextRef.current.close();\n      audioContextRef.current = null;\n    }\n    analyserRef.current = null;\n\n    // Stop any playing audio\n    if (currentAudioRef.current) {\n      currentAudioRef.current.pause();\n      currentAudioRef.current = null;\n    }\n\n    // Abort any pending requests\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n\n    // Reset refs\n    audioChunksRef.current = [];\n    silenceStartRef.current = null;\n  }, []);\n\n  // Update audio intensity for UI feedback\n  const updateAudioLevel = useCallback(() => {\n    if (!analyserRef.current) return;\n\n    const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);\n    analyserRef.current.getByteFrequencyData(dataArray);\n\n    // Calculate average level\n    let sum = 0;\n    for (let i = 0; i < dataArray.length; i++) {\n      sum += dataArray[i];\n    }\n    const level = sum / dataArray.length / 255;\n    setAudioIntensity(level);\n    lastAudioLevelRef.current = level;\n\n    // Detect silence for auto-send\n    if (level < silenceThreshold) {\n      if (!silenceStartRef.current) {\n        silenceStartRef.current = Date.now();\n      } else if (Date.now() - silenceStartRef.current > silenceDurationMs) {\n        // Silence detected long enough - could trigger auto-send here\n        // For now, we rely on manual tap-to-send per the UX\n      }\n    } else {\n      silenceStartRef.current = null;\n    }\n  }, [silenceThreshold, silenceDurationMs]);\n\n  // Transcribe audio chunk via Whisper\n  const transcribeChunk = useCallback(async (audioBlob: Blob): Promise<string> => {\n    const formData = new FormData();\n    formData.append('audio', audioBlob, 'chunk.webm');\n    formData.append('language', 'en');\n\n    const startTime = Date.now();\n    log.info('transcribeChunk() - sending to Whisper', { size: audioBlob.size });\n\n    try {\n      const response = await fetch(whisperEndpoint, {\n        method: 'POST',\n        body: formData,\n        signal: abortControllerRef.current?.signal,\n      });\n\n      if (!response.ok) {\n        throw new Error(`Whisper error: ${response.status}`);\n      }\n\n      const result = await response.json();\n      log.timing('STT', Date.now() - startTime);\n      return result.text || '';\n    } catch (err) {\n      if (err instanceof Error && err.name === 'AbortError') {\n        log.info('Transcription aborted');\n        return '';\n      }\n      throw err;\n    }\n  }, [whisperEndpoint]);\n\n  // Get LLM response via streaming chat\n  const getAIResponse = useCallback(async (userMessage: string): Promise<string> => {\n    const startTime = Date.now();\n    log.info('getAIResponse() - sending to LLM', { length: userMessage.length });\n    onResponseStart?.();\n\n    try {\n      const response = await fetch(chatEndpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          messages: [{ role: 'user', content: userMessage }],\n          model: 'claude',\n          stream: true,\n        }),\n        signal: abortControllerRef.current?.signal,\n      });\n\n      if (!response.ok) {\n        throw new Error(`Chat error: ${response.status}`);\n      }\n\n      // Read streaming response\n      const reader = response.body?.getReader();\n      if (!reader) throw new Error('No response body');\n\n      const decoder = new TextDecoder();\n      let fullResponse = '';\n      let firstTokenTime: number | null = null;\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        const chunk = decoder.decode(value);\n        const lines = chunk.split('\\n');\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            try {\n              const data = JSON.parse(line.slice(6));\n              if (data.content) {\n                if (!firstTokenTime) {\n                  firstTokenTime = Date.now();\n                  log.timing('LLM first token', firstTokenTime - startTime);\n                }\n                fullResponse += data.content;\n                setResponse(fullResponse);\n              }\n            } catch {\n              // Ignore parse errors for non-JSON lines\n            }\n          }\n        }\n      }\n\n      log.timing('LLM total', Date.now() - startTime);\n      return fullResponse;\n    } catch (err) {\n      if (err instanceof Error && err.name === 'AbortError') {\n        log.info('LLM request aborted');\n        return '';\n      }\n      throw err;\n    }\n  }, [chatEndpoint, onResponseStart]);\n\n  // Speak response via TTS\n  const speakResponse = useCallback(async (text: string): Promise<void> => {\n    const startTime = Date.now();\n    log.info('speakResponse() - sending to TTS', { length: text.length });\n\n    try {\n      const response = await fetch(ttsEndpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ text, voice: 'nova' }),\n        signal: abortControllerRef.current?.signal,\n      });\n\n      if (!response.ok) {\n        throw new Error(`TTS error: ${response.status}`);\n      }\n\n      const audioBlob = await response.blob();\n      log.timing('TTS', Date.now() - startTime);\n\n      // Play audio\n      const audioUrl = URL.createObjectURL(audioBlob);\n      const audio = new Audio(audioUrl);\n      currentAudioRef.current = audio;\n\n      return new Promise((resolve, reject) => {\n        audio.onended = () => {\n          URL.revokeObjectURL(audioUrl);\n          currentAudioRef.current = null;\n          resolve();\n        };\n        audio.onerror = () => {\n          URL.revokeObjectURL(audioUrl);\n          currentAudioRef.current = null;\n          reject(new Error('Audio playback failed'));\n        };\n        audio.play().catch(reject);\n      });\n    } catch (err) {\n      if (err instanceof Error && err.name === 'AbortError') {\n        log.info('TTS aborted');\n        return;\n      }\n      throw err;\n    }\n  }, [ttsEndpoint]);\n\n  // Start voice mode (begin listening)\n  const start = useCallback(async () => {\n    log.info('start() - initializing voice mode');\n    startTimeRef.current = Date.now();\n\n    cleanup();\n    setError(null);\n    setTranscript('');\n    setResponse('');\n    audioChunksRef.current = [];\n\n    try {\n      // Request microphone\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true,\n        },\n      });\n      streamRef.current = stream;\n\n      // Set up audio analysis\n      const AudioContextClass = window.AudioContext || (window as unknown as { webkitAudioContext: typeof AudioContext }).webkitAudioContext;\n      const audioContext = new AudioContextClass();\n      audioContextRef.current = audioContext;\n\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 256;\n      analyser.smoothingTimeConstant = 0.5;\n      analyserRef.current = analyser;\n\n      const source = audioContext.createMediaStreamSource(stream);\n      source.connect(analyser);\n\n      // Create media recorder\n      const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')\n        ? 'audio/webm;codecs=opus'\n        : 'audio/webm';\n\n      const mediaRecorder = new MediaRecorder(stream, { mimeType });\n      mediaRecorderRef.current = mediaRecorder;\n\n      mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          audioChunksRef.current.push(event.data);\n        }\n      };\n\n      // Start recording\n      mediaRecorder.start(100); // Collect data every 100ms\n      abortControllerRef.current = new AbortController();\n\n      // Start audio level monitoring\n      audioLevelIntervalRef.current = setInterval(updateAudioLevel, AUDIO_LEVEL_UPDATE_INTERVAL);\n\n      transitionState('listening');\n      log.timing('Mic ready', Date.now() - startTimeRef.current);\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Failed to start voice mode';\n      log.error('start() failed', err);\n      setError(errorMsg);\n      onError?.(errorMsg);\n      cleanup();\n    }\n  }, [cleanup, updateAudioLevel, transitionState, onError]);\n\n  // Stop voice mode completely\n  const stop = useCallback(() => {\n    log.info('stop() - ending voice mode');\n    cleanup();\n    transitionState('idle');\n    setAudioIntensity(0);\n  }, [cleanup, transitionState]);\n\n  // Send current audio for processing (manual trigger)\n  const send = useCallback(async () => {\n    if (state !== 'listening' || audioChunksRef.current.length === 0) {\n      log.warn('send() - nothing to send', { state, chunks: audioChunksRef.current.length });\n      return;\n    }\n\n    log.info('send() - processing audio');\n    const totalStartTime = Date.now();\n\n    // Stop recording but keep resources\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n      mediaRecorderRef.current.stop();\n    }\n\n    transitionState('processing');\n\n    try {\n      // Combine audio chunks\n      const audioBlob = new Blob(audioChunksRef.current, {\n        type: mediaRecorderRef.current?.mimeType || 'audio/webm',\n      });\n      audioChunksRef.current = [];\n\n      // Transcribe\n      const text = await transcribeChunk(audioBlob);\n      if (!text.trim()) {\n        log.warn('Empty transcript, returning to listening');\n        await start(); // Restart listening\n        return;\n      }\n\n      setTranscript(text);\n      onTranscriptUpdate?.(text, true);\n      log.info('Transcript ready', { text: text.substring(0, 50) + '...' });\n\n      // Get AI response\n      const aiResponse = await getAIResponse(text);\n      if (!aiResponse.trim()) {\n        log.warn('Empty AI response');\n        onResponseEnd?.('');\n        await start();\n        return;\n      }\n\n      onResponseEnd?.(aiResponse);\n\n      // Speak response\n      transitionState('speaking');\n      await speakResponse(aiResponse);\n\n      // Return to listening after speaking\n      log.timing('Total round-trip', Date.now() - totalStartTime);\n      await start();\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Processing failed';\n      log.error('send() failed', err);\n      setError(errorMsg);\n      onError?.(errorMsg);\n      stop();\n    }\n  }, [state, start, stop, transcribeChunk, getAIResponse, speakResponse, transitionState, onTranscriptUpdate, onResponseEnd, onError]);\n\n  // Interrupt speaking and switch back to listening\n  const interrupt = useCallback(() => {\n    log.info('interrupt() - stopping speech, returning to listening');\n\n    // Stop current audio playback\n    if (currentAudioRef.current) {\n      currentAudioRef.current.pause();\n      currentAudioRef.current = null;\n    }\n\n    // Abort any pending requests\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n\n    // Restart listening\n    start();\n  }, [start]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      cleanup();\n    };\n  }, [cleanup]);\n\n  return {\n    state,\n    isActive: state !== 'idle',\n    transcript,\n    response,\n    audioIntensity,\n    error,\n    start,\n    stop,\n    send,\n    interrupt,\n  };\n}\n\nexport default useVoiceMode;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3765, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/hooks/usePerformanceMetrics.ts"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useCallback } from \"react\";\n\nexport interface PerformanceMetrics {\n  // Core Web Vitals\n  fcp: number | null; // First Contentful Paint\n  lcp: number | null; // Largest Contentful Paint\n  cls: number | null; // Cumulative Layout Shift\n  fid: number | null; // First Input Delay\n  inp: number | null; // Interaction to Next Paint\n  ttfb: number | null; // Time to First Byte\n\n  // Custom metrics\n  pageLoadTime: number | null;\n  domInteractive: number | null;\n  resourceCount: number;\n  transferSize: number; // KB\n\n  // Computed status\n  overallScore: \"fast\" | \"moderate\" | \"slow\";\n  primaryMetric: number | null; // The main ms value to display\n}\n\nconst initialMetrics: PerformanceMetrics = {\n  fcp: null,\n  lcp: null,\n  cls: null,\n  fid: null,\n  inp: null,\n  ttfb: null,\n  pageLoadTime: null,\n  domInteractive: null,\n  resourceCount: 0,\n  transferSize: 0,\n  overallScore: \"fast\",\n  primaryMetric: null,\n};\n\nfunction getOverallScore(metrics: Partial<PerformanceMetrics>): \"fast\" | \"moderate\" | \"slow\" {\n  const { lcp, fcp, cls, ttfb, pageLoadTime } = metrics;\n\n  // Primary metric for scoring (prefer LCP, fallback to FCP, then pageLoadTime)\n  const primaryTime = lcp ?? fcp ?? pageLoadTime ?? 0;\n\n  // Google's Core Web Vitals thresholds\n  // LCP: Good < 2500ms, Needs Improvement < 4000ms, Poor >= 4000ms\n  // FCP: Good < 1800ms, Needs Improvement < 3000ms, Poor >= 3000ms\n  // CLS: Good < 0.1, Needs Improvement < 0.25, Poor >= 0.25\n  // TTFB: Good < 800ms, Needs Improvement < 1800ms, Poor >= 1800ms\n\n  let score = 0;\n  let count = 0;\n\n  if (primaryTime > 0) {\n    if (primaryTime < 1500) score += 3;\n    else if (primaryTime < 2500) score += 2;\n    else if (primaryTime < 4000) score += 1;\n    count++;\n  }\n\n  if (ttfb && ttfb > 0) {\n    if (ttfb < 400) score += 3;\n    else if (ttfb < 800) score += 2;\n    else if (ttfb < 1800) score += 1;\n    count++;\n  }\n\n  if (cls !== null && cls !== undefined) {\n    if (cls < 0.1) score += 3;\n    else if (cls < 0.25) score += 2;\n    else score += 1;\n    count++;\n  }\n\n  if (count === 0) return \"fast\";\n\n  const avg = score / count;\n  if (avg >= 2.5) return \"fast\";\n  if (avg >= 1.5) return \"moderate\";\n  return \"slow\";\n}\n\nexport function usePerformanceMetrics() {\n  const [metrics, setMetrics] = useState<PerformanceMetrics>(initialMetrics);\n  const [isSupported, setIsSupported] = useState(true);\n\n  const updateMetrics = useCallback((updates: Partial<PerformanceMetrics>) => {\n    setMetrics((prev) => {\n      const newMetrics = { ...prev, ...updates };\n      // Recalculate primary metric and score\n      newMetrics.primaryMetric = newMetrics.lcp ?? newMetrics.fcp ?? newMetrics.pageLoadTime;\n      newMetrics.overallScore = getOverallScore(newMetrics);\n      return newMetrics;\n    });\n  }, []);\n\n  useEffect(() => {\n    if (typeof window === \"undefined\" || !window.performance) {\n      setIsSupported(false);\n      return;\n    }\n\n    // Get navigation timing data\n    const getNavigationTiming = () => {\n      const navigation = performance.getEntriesByType(\"navigation\")[0] as PerformanceNavigationTiming | undefined;\n\n      if (navigation) {\n        const pageLoadTime = navigation.loadEventEnd - navigation.startTime;\n        const domInteractive = navigation.domInteractive - navigation.startTime;\n        const ttfb = navigation.responseStart - navigation.requestStart;\n\n        updateMetrics({\n          pageLoadTime: pageLoadTime > 0 ? Math.round(pageLoadTime) : null,\n          domInteractive: domInteractive > 0 ? Math.round(domInteractive) : null,\n          ttfb: ttfb > 0 ? Math.round(ttfb) : null,\n        });\n      }\n    };\n\n    // Get resource timing data\n    const getResourceTiming = () => {\n      const resources = performance.getEntriesByType(\"resource\") as PerformanceResourceTiming[];\n      const totalSize = resources.reduce((acc, r) => acc + (r.transferSize || 0), 0);\n\n      updateMetrics({\n        resourceCount: resources.length,\n        transferSize: Math.round(totalSize / 1024), // Convert to KB\n      });\n    };\n\n    // Initial timing collection after page load\n    if (document.readyState === \"complete\") {\n      getNavigationTiming();\n      getResourceTiming();\n    } else {\n      window.addEventListener(\"load\", () => {\n        // Wait a bit for metrics to stabilize\n        setTimeout(() => {\n          getNavigationTiming();\n          getResourceTiming();\n        }, 100);\n      });\n    }\n\n    // Observe paint timing (FCP)\n    const paintObserver = new PerformanceObserver((entryList) => {\n      for (const entry of entryList.getEntries()) {\n        if (entry.name === \"first-contentful-paint\") {\n          updateMetrics({ fcp: Math.round(entry.startTime) });\n        }\n      }\n    });\n\n    try {\n      paintObserver.observe({ type: \"paint\", buffered: true });\n    } catch {\n      // Paint observer not supported\n    }\n\n    // Observe LCP\n    const lcpObserver = new PerformanceObserver((entryList) => {\n      const entries = entryList.getEntries();\n      const lastEntry = entries[entries.length - 1];\n      if (lastEntry) {\n        updateMetrics({ lcp: Math.round(lastEntry.startTime) });\n      }\n    });\n\n    try {\n      lcpObserver.observe({ type: \"largest-contentful-paint\", buffered: true });\n    } catch {\n      // LCP observer not supported\n    }\n\n    // Observe CLS\n    let clsValue = 0;\n    const clsObserver = new PerformanceObserver((entryList) => {\n      for (const entry of entryList.getEntries()) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (!(entry as any).hadRecentInput) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          clsValue += (entry as any).value;\n          updateMetrics({ cls: Math.round(clsValue * 1000) / 1000 });\n        }\n      }\n    });\n\n    try {\n      clsObserver.observe({ type: \"layout-shift\", buffered: true });\n    } catch {\n      // CLS observer not supported\n    }\n\n    // Observe FID\n    const fidObserver = new PerformanceObserver((entryList) => {\n      for (const entry of entryList.getEntries()) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const fidEntry = entry as any;\n        updateMetrics({ fid: Math.round(fidEntry.processingStart - fidEntry.startTime) });\n      }\n    });\n\n    try {\n      fidObserver.observe({ type: \"first-input\", buffered: true });\n    } catch {\n      // FID observer not supported\n    }\n\n    // Observe INP (Interaction to Next Paint)\n    const inpObserver = new PerformanceObserver((entryList) => {\n      for (const entry of entryList.getEntries()) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const duration = (entry as any).duration;\n        if (duration) {\n          updateMetrics({ inp: Math.round(duration) });\n        }\n      }\n    });\n\n    try {\n      inpObserver.observe({ type: \"event\", buffered: true });\n    } catch {\n      // INP observer not supported\n    }\n\n    return () => {\n      paintObserver.disconnect();\n      lcpObserver.disconnect();\n      clsObserver.disconnect();\n      fidObserver.disconnect();\n      inpObserver.disconnect();\n    };\n  }, [updateMetrics]);\n\n  // Force refresh metrics\n  const refreshMetrics = useCallback(() => {\n    if (typeof window === \"undefined\" || !window.performance) return;\n\n    const navigation = performance.getEntriesByType(\"navigation\")[0] as PerformanceNavigationTiming | undefined;\n    const resources = performance.getEntriesByType(\"resource\") as PerformanceResourceTiming[];\n\n    if (navigation) {\n      const pageLoadTime = navigation.loadEventEnd - navigation.startTime;\n      const ttfb = navigation.responseStart - navigation.requestStart;\n      const totalSize = resources.reduce((acc, r) => acc + (r.transferSize || 0), 0);\n\n      updateMetrics({\n        pageLoadTime: pageLoadTime > 0 ? Math.round(pageLoadTime) : null,\n        ttfb: ttfb > 0 ? Math.round(ttfb) : null,\n        resourceCount: resources.length,\n        transferSize: Math.round(totalSize / 1024),\n      });\n    }\n  }, [updateMetrics]);\n\n  return { metrics, isSupported, refreshMetrics };\n}\n"],"names":[],"mappings":";;;;AAEA;AAFA;;AAwBA,MAAM,iBAAqC;IACzC,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,MAAM;IACN,cAAc;IACd,gBAAgB;IAChB,eAAe;IACf,cAAc;IACd,cAAc;IACd,eAAe;AACjB;AAEA,SAAS,gBAAgB,OAAoC;IAC3D,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,YAAY,EAAE,GAAG;IAE9C,8EAA8E;IAC9E,MAAM,cAAc,OAAO,OAAO,gBAAgB;IAElD,sCAAsC;IACtC,iEAAiE;IACjE,iEAAiE;IACjE,0DAA0D;IAC1D,iEAAiE;IAEjE,IAAI,QAAQ;IACZ,IAAI,QAAQ;IAEZ,IAAI,cAAc,GAAG;QACnB,IAAI,cAAc,MAAM,SAAS;aAC5B,IAAI,cAAc,MAAM,SAAS;aACjC,IAAI,cAAc,MAAM,SAAS;QACtC;IACF;IAEA,IAAI,QAAQ,OAAO,GAAG;QACpB,IAAI,OAAO,KAAK,SAAS;aACpB,IAAI,OAAO,KAAK,SAAS;aACzB,IAAI,OAAO,MAAM,SAAS;QAC/B;IACF;IAEA,IAAI,QAAQ,QAAQ,QAAQ,WAAW;QACrC,IAAI,MAAM,KAAK,SAAS;aACnB,IAAI,MAAM,MAAM,SAAS;aACzB,SAAS;QACd;IACF;IAEA,IAAI,UAAU,GAAG,OAAO;IAExB,MAAM,MAAM,QAAQ;IACpB,IAAI,OAAO,KAAK,OAAO;IACvB,IAAI,OAAO,KAAK,OAAO;IACvB,OAAO;AACT;AAEO,SAAS;IACd,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,0ZAAQ,EAAqB;IAC3D,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,0ZAAQ,EAAC;IAE/C,MAAM,gBAAgB,IAAA,6ZAAW,EAAC,CAAC;QACjC,WAAW,CAAC;YACV,MAAM,aAAa;gBAAE,GAAG,IAAI;gBAAE,GAAG,OAAO;YAAC;YACzC,uCAAuC;YACvC,WAAW,aAAa,GAAG,WAAW,GAAG,IAAI,WAAW,GAAG,IAAI,WAAW,YAAY;YACtF,WAAW,YAAY,GAAG,gBAAgB;YAC1C,OAAO;QACT;IACF,GAAG,EAAE;IAEL,IAAA,2ZAAS,EAAC;QACR,wCAA0D;YACxD,eAAe;YACf;QACF;;;QAEA,6BAA6B;QAC7B,MAAM;QAgBN,2BAA2B;QAC3B,MAAM;QAwBN,6BAA6B;QAC7B,MAAM;QAcN,cAAc;QACd,MAAM;QAcN,cAAc;QACd,IAAI;QACJ,MAAM;QAiBN,cAAc;QACd,MAAM;QAcN,0CAA0C;QAC1C,MAAM;IAuBR,GAAG;QAAC;KAAc;IAElB,wBAAwB;IACxB,MAAM,iBAAiB,IAAA,6ZAAW,EAAC;QACjC,wCAA0D;;;QAE1D,MAAM;QACN,MAAM;IAcR,GAAG;QAAC;KAAc;IAElB,OAAO;QAAE;QAAS;QAAa;IAAe;AAChD"}},
    {"offset": {"line": 3881, "column": 0}, "map": {"version":3,"sources":["file:///Users/jamesspalding/OpenClaw-OS/src/hooks/useProviderStatus.ts"],"sourcesContent":["'use client';\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\n\nexport type ProviderType = 'cloud' | 'local' | 'lynkr';\nexport type ConnectionStatus = 'connected' | 'connecting' | 'disconnected';\n\nexport interface ProviderStatusData {\n  providerType: ProviderType;\n  status: ConnectionStatus;\n  latencyMs?: number;\n  error?: string;\n  lastChecked: number;\n}\n\ninterface HealthResponse {\n  timestamp: number;\n  providers: {\n    ollama: { connected: boolean; latencyMs?: number; error?: string };\n    lynkr: { connected: boolean; latencyMs?: number; error?: string };\n    openai: { connected: boolean; latencyMs?: number; error?: string };\n    anthropic: { connected: boolean; latencyMs?: number; error?: string };\n  };\n  summary: {\n    localAvailable: boolean;\n    lynkrAvailable: boolean;\n    cloudAvailable: boolean;\n    recommendedProvider: 'local' | 'lynkr' | 'cloud';\n  };\n}\n\nconst POLL_INTERVAL = 30000; // 30 seconds\nconst INITIAL_TIMEOUT = 8000; // 8 seconds for health check\n\n/**\n * Hook to track AI provider connection status\n * Returns the current active provider and its connection status\n */\nexport function useProviderStatus() {\n  const [status, setStatus] = useState<ProviderStatusData>({\n    providerType: 'cloud',\n    status: 'connecting',\n    lastChecked: 0,\n  });\n  const isCheckingRef = useRef(false);\n\n  const checkHealth = useCallback(async () => {\n    if (isCheckingRef.current) return;\n    isCheckingRef.current = true;\n\n    try {\n      // Check health with timeout for better UX\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), INITIAL_TIMEOUT);\n\n      const healthRes = await fetch('/api/health/providers?checkCloud=false', {\n        signal: controller.signal,\n      });\n      clearTimeout(timeoutId);\n\n      if (!healthRes.ok) {\n        setStatus((prev) => ({\n          ...prev,\n          status: 'disconnected',\n          error: 'Health check failed',\n          lastChecked: Date.now(),\n        }));\n        return;\n      }\n\n      const health: HealthResponse = await healthRes.json();\n\n      // Determine provider based on what's available\n      // Priority: Lynkr > Local > Cloud\n      let actualProvider: ProviderType = 'cloud';\n      let connectionStatus: ConnectionStatus = 'connected';\n      let latency: number | undefined;\n\n      if (health.summary.lynkrAvailable) {\n        actualProvider = 'lynkr';\n        connectionStatus = 'connected';\n        latency = health.providers.lynkr.latencyMs;\n      } else if (health.summary.localAvailable) {\n        actualProvider = 'local';\n        connectionStatus = 'connected';\n        latency = health.providers.ollama.latencyMs;\n      } else {\n        // Default to cloud - assume cloud is always available\n        actualProvider = 'cloud';\n        connectionStatus = 'connected';\n      }\n\n      setStatus({\n        providerType: actualProvider,\n        status: connectionStatus,\n        latencyMs: latency,\n        lastChecked: Date.now(),\n      });\n    } catch (err) {\n      // On error, assume cloud fallback is working\n      setStatus({\n        providerType: 'cloud',\n        status: 'connected',\n        lastChecked: Date.now(),\n      });\n    } finally {\n      isCheckingRef.current = false;\n    }\n  }, []);\n\n  // Initial check with a small delay to not block render\n  useEffect(() => {\n    const timer = setTimeout(checkHealth, 1000);\n    return () => clearTimeout(timer);\n  }, [checkHealth]);\n\n  // Periodic polling\n  useEffect(() => {\n    const interval = setInterval(checkHealth, POLL_INTERVAL);\n    return () => clearInterval(interval);\n  }, [checkHealth]);\n\n  // Helper function to get display color\n  const getStatusColor = useCallback(() => {\n    switch (status.status) {\n      case 'connected':\n        return '#22c55e'; // green-500\n      case 'connecting':\n        return '#f97316'; // orange-500\n      case 'disconnected':\n        return '#ef4444'; // red-500\n      default:\n        return '#6b7280'; // gray-500\n    }\n  }, [status.status]);\n\n  // Helper function to get provider display name\n  const getProviderDisplayName = useCallback(() => {\n    switch (status.providerType) {\n      case 'lynkr':\n        return 'Lynkr';\n      case 'local':\n        return 'Local';\n      case 'cloud':\n        return 'Cloud';\n      default:\n        return 'Unknown';\n    }\n  }, [status.providerType]);\n\n  return {\n    ...status,\n    isChecking: isCheckingRef.current,\n    refresh: checkHealth,\n    getStatusColor,\n    getProviderDisplayName,\n  };\n}\n\nexport default useProviderStatus;\n"],"names":[],"mappings":";;;;;;AAEA;AAFA;;AA+BA,MAAM,gBAAgB,OAAO,aAAa;AAC1C,MAAM,kBAAkB,MAAM,6BAA6B;AAMpD,SAAS;IACd,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,0ZAAQ,EAAqB;QACvD,cAAc;QACd,QAAQ;QACR,aAAa;IACf;IACA,MAAM,gBAAgB,IAAA,wZAAM,EAAC;IAE7B,MAAM,cAAc,IAAA,6ZAAW,EAAC;QAC9B,IAAI,cAAc,OAAO,EAAE;QAC3B,cAAc,OAAO,GAAG;QAExB,IAAI;YACF,0CAA0C;YAC1C,MAAM,aAAa,IAAI;YACvB,MAAM,YAAY,WAAW,IAAM,WAAW,KAAK,IAAI;YAEvD,MAAM,YAAY,MAAM,MAAM,0CAA0C;gBACtE,QAAQ,WAAW,MAAM;YAC3B;YACA,aAAa;YAEb,IAAI,CAAC,UAAU,EAAE,EAAE;gBACjB,UAAU,CAAC,OAAS,CAAC;wBACnB,GAAG,IAAI;wBACP,QAAQ;wBACR,OAAO;wBACP,aAAa,KAAK,GAAG;oBACvB,CAAC;gBACD;YACF;YAEA,MAAM,SAAyB,MAAM,UAAU,IAAI;YAEnD,+CAA+C;YAC/C,kCAAkC;YAClC,IAAI,iBAA+B;YACnC,IAAI,mBAAqC;YACzC,IAAI;YAEJ,IAAI,OAAO,OAAO,CAAC,cAAc,EAAE;gBACjC,iBAAiB;gBACjB,mBAAmB;gBACnB,UAAU,OAAO,SAAS,CAAC,KAAK,CAAC,SAAS;YAC5C,OAAO,IAAI,OAAO,OAAO,CAAC,cAAc,EAAE;gBACxC,iBAAiB;gBACjB,mBAAmB;gBACnB,UAAU,OAAO,SAAS,CAAC,MAAM,CAAC,SAAS;YAC7C,OAAO;gBACL,sDAAsD;gBACtD,iBAAiB;gBACjB,mBAAmB;YACrB;YAEA,UAAU;gBACR,cAAc;gBACd,QAAQ;gBACR,WAAW;gBACX,aAAa,KAAK,GAAG;YACvB;QACF,EAAE,OAAO,KAAK;YACZ,6CAA6C;YAC7C,UAAU;gBACR,cAAc;gBACd,QAAQ;gBACR,aAAa,KAAK,GAAG;YACvB;QACF,SAAU;YACR,cAAc,OAAO,GAAG;QAC1B;IACF,GAAG,EAAE;IAEL,uDAAuD;IACvD,IAAA,2ZAAS,EAAC;QACR,MAAM,QAAQ,WAAW,aAAa;QACtC,OAAO,IAAM,aAAa;IAC5B,GAAG;QAAC;KAAY;IAEhB,mBAAmB;IACnB,IAAA,2ZAAS,EAAC;QACR,MAAM,WAAW,YAAY,aAAa;QAC1C,OAAO,IAAM,cAAc;IAC7B,GAAG;QAAC;KAAY;IAEhB,uCAAuC;IACvC,MAAM,iBAAiB,IAAA,6ZAAW,EAAC;QACjC,OAAQ,OAAO,MAAM;YACnB,KAAK;gBACH,OAAO,WAAW,YAAY;YAChC,KAAK;gBACH,OAAO,WAAW,aAAa;YACjC,KAAK;gBACH,OAAO,WAAW,UAAU;YAC9B;gBACE,OAAO,WAAW,WAAW;QACjC;IACF,GAAG;QAAC,OAAO,MAAM;KAAC;IAElB,+CAA+C;IAC/C,MAAM,yBAAyB,IAAA,6ZAAW,EAAC;QACzC,OAAQ,OAAO,YAAY;YACzB,KAAK;gBACH,OAAO;YACT,KAAK;gBACH,OAAO;YACT,KAAK;gBACH,OAAO;YACT;gBACE,OAAO;QACX;IACF,GAAG;QAAC,OAAO,YAAY;KAAC;IAExB,OAAO;QACL,GAAG,MAAM;QACT,YAAY,cAAc,OAAO;QACjC,SAAS;QACT;QACA;IACF;AACF;uCAEe"}}]
}